(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["nteract"] = factory();
	else
		root["nteract"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 234);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(238);
} else {}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(245)();
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactCSS = exports.loop = exports.handleActive = exports.handleHover = exports.hover = undefined;

var _flattenNames = __webpack_require__(336);

var _flattenNames2 = _interopRequireDefault(_flattenNames);

var _mergeClasses = __webpack_require__(408);

var _mergeClasses2 = _interopRequireDefault(_mergeClasses);

var _autoprefix = __webpack_require__(428);

var _autoprefix2 = _interopRequireDefault(_autoprefix);

var _hover2 = __webpack_require__(429);

var _hover3 = _interopRequireDefault(_hover2);

var _active = __webpack_require__(430);

var _active2 = _interopRequireDefault(_active);

var _loop2 = __webpack_require__(431);

var _loop3 = _interopRequireDefault(_loop2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.hover = _hover3.default;
exports.handleHover = _hover3.default;
exports.handleActive = _active2.default;
exports.loop = _loop3.default;
var ReactCSS = exports.ReactCSS = function ReactCSS(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }

  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};

exports.default = ReactCSS;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bisect", function() { return /* reexport */ bisect; });
__webpack_require__.d(__webpack_exports__, "bisectRight", function() { return /* reexport */ bisectRight; });
__webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return /* reexport */ bisectLeft; });
__webpack_require__.d(__webpack_exports__, "ascending", function() { return /* reexport */ ascending; });
__webpack_require__.d(__webpack_exports__, "bisector", function() { return /* reexport */ bisector; });
__webpack_require__.d(__webpack_exports__, "cross", function() { return /* reexport */ cross; });
__webpack_require__.d(__webpack_exports__, "descending", function() { return /* reexport */ descending; });
__webpack_require__.d(__webpack_exports__, "deviation", function() { return /* reexport */ deviation; });
__webpack_require__.d(__webpack_exports__, "extent", function() { return /* reexport */ extent; });
__webpack_require__.d(__webpack_exports__, "histogram", function() { return /* reexport */ src_histogram; });
__webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return /* reexport */ freedmanDiaconis; });
__webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return /* reexport */ scott; });
__webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return /* reexport */ sturges; });
__webpack_require__.d(__webpack_exports__, "max", function() { return /* reexport */ src_max; });
__webpack_require__.d(__webpack_exports__, "mean", function() { return /* reexport */ src_mean; });
__webpack_require__.d(__webpack_exports__, "median", function() { return /* reexport */ median; });
__webpack_require__.d(__webpack_exports__, "merge", function() { return /* reexport */ merge; });
__webpack_require__.d(__webpack_exports__, "min", function() { return /* reexport */ src_min; });
__webpack_require__.d(__webpack_exports__, "pairs", function() { return /* reexport */ pairs; });
__webpack_require__.d(__webpack_exports__, "permute", function() { return /* reexport */ permute; });
__webpack_require__.d(__webpack_exports__, "quantile", function() { return /* reexport */ quantile; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ range; });
__webpack_require__.d(__webpack_exports__, "scan", function() { return /* reexport */ scan; });
__webpack_require__.d(__webpack_exports__, "shuffle", function() { return /* reexport */ shuffle; });
__webpack_require__.d(__webpack_exports__, "sum", function() { return /* reexport */ src_sum; });
__webpack_require__.d(__webpack_exports__, "ticks", function() { return /* reexport */ ticks; });
__webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return /* reexport */ tickIncrement; });
__webpack_require__.d(__webpack_exports__, "tickStep", function() { return /* reexport */ tickStep; });
__webpack_require__.d(__webpack_exports__, "transpose", function() { return /* reexport */ src_transpose; });
__webpack_require__.d(__webpack_exports__, "variance", function() { return /* reexport */ variance; });
__webpack_require__.d(__webpack_exports__, "zip", function() { return /* reexport */ zip; });

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/bisector.js


/* harmony default export */ var bisector = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/cross.js


/* harmony default export */ var cross = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/variance.js


/* harmony default export */ var variance = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/deviation.js


/* harmony default export */ var deviation = (function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/range.js
/* harmony default export */ var range = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/histogram.js









/* harmony default export */ var src_histogram = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/quantile.js


/* harmony default export */ var quantile = (function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/threshold/scott.js


/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/mean.js


/* harmony default export */ var src_mean = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/median.js




/* harmony default export */ var median = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/merge.js
/* harmony default export */ var merge = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/scan.js


/* harmony default export */ var scan = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-array/src/index.js





























/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return newInterval; });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nogamma; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(isNaN(a) ? b : a);
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Alpha = __webpack_require__(432);

Object.defineProperty(exports, 'Alpha', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Checkboard = __webpack_require__(148);

Object.defineProperty(exports, 'Checkboard', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Checkboard).default;
  }
});

var _EditableInput = __webpack_require__(435);

Object.defineProperty(exports, 'EditableInput', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_EditableInput).default;
  }
});

var _Hue = __webpack_require__(436);

Object.defineProperty(exports, 'Hue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Raised = __webpack_require__(438);

Object.defineProperty(exports, 'Raised', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Raised).default;
  }
});

var _Saturation = __webpack_require__(452);

Object.defineProperty(exports, 'Saturation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Saturation).default;
  }
});

var _ColorWrap = __webpack_require__(217);

Object.defineProperty(exports, 'ColorWrap', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Swatch = __webpack_require__(460);

Object.defineProperty(exports, 'Swatch', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatch).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Rgb; });
/* unused harmony export hslConvert */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return hsl; });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Rgb, rgb, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* extend */ "b"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Hsl, hsl, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* extend */ "b"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "create", function() { return /* reexport */ create; });
__webpack_require__.d(__webpack_exports__, "creator", function() { return /* reexport */ creator["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "local", function() { return /* reexport */ local; });
__webpack_require__.d(__webpack_exports__, "matcher", function() { return /* reexport */ matcher["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "mouse", function() { return /* reexport */ mouse["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "namespace", function() { return /* reexport */ namespace["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "namespaces", function() { return /* reexport */ namespaces["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "clientPoint", function() { return /* reexport */ point["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "select", function() { return /* reexport */ src_select["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selectAll", function() { return /* reexport */ selectAll; });
__webpack_require__.d(__webpack_exports__, "selection", function() { return /* reexport */ selection["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selector", function() { return /* reexport */ src_selector["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "selectorAll", function() { return /* reexport */ selectorAll["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "style", function() { return /* reexport */ style["b" /* styleValue */]; });
__webpack_require__.d(__webpack_exports__, "touch", function() { return /* reexport */ touch["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "touches", function() { return /* reexport */ src_touches; });
__webpack_require__.d(__webpack_exports__, "window", function() { return /* reexport */ src_window["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "event", function() { return /* reexport */ on["c" /* event */]; });
__webpack_require__.d(__webpack_exports__, "customEvent", function() { return /* reexport */ on["a" /* customEvent */]; });

// EXTERNAL MODULE: ./node_modules/d3-selection/src/creator.js
var creator = __webpack_require__(35);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(99);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/create.js



/* harmony default export */ var create = (function(name) {
  return Object(src_select["a" /* default */])(Object(creator["a" /* default */])(name).call(document.documentElement));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/local.js
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(101);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(165);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespaces.js
var namespaces = __webpack_require__(38);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/point.js
var point = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/index.js + 31 modules
var selection = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selectAll.js


/* harmony default export */ var selectAll = (function(selector) {
  return typeof selector === "string"
      ? new selection["a" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement])
      : new selection["a" /* Selection */]([selector == null ? [] : selector], selection["c" /* root */]);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var src_selector = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(100);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(102);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/touch.js
var touch = __webpack_require__(166);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/sourceEvent.js
var sourceEvent = __webpack_require__(62);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/touches.js



/* harmony default export */ var src_touches = (function(node, touches) {
  if (touches == null) touches = Object(sourceEvent["a" /* default */])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(point["a" /* default */])(node, touches[i]);
  }

  return points;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(59);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/index.js




















/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "interpolate", function() { return /* reexport */ value["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return /* reexport */ array["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return /* reexport */ basis["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return /* reexport */ basisClosed["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return /* reexport */ date["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return /* reexport */ discrete; });
__webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return /* reexport */ src_hue; });
__webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return /* reexport */ number["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return /* reexport */ numberArray["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return /* reexport */ object["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return /* reexport */ round["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateString", function() { return /* reexport */ string["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return /* reexport */ transform["a" /* interpolateTransformCss */]; });
__webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return /* reexport */ transform["b" /* interpolateTransformSvg */]; });
__webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return /* reexport */ zoom; });
__webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return /* reexport */ rgb["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return /* reexport */ rgb["b" /* rgbBasis */]; });
__webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return /* reexport */ rgb["c" /* rgbBasisClosed */]; });
__webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return /* reexport */ src_hsl; });
__webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return /* reexport */ hslLong; });
__webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return /* reexport */ lab_lab; });
__webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return /* reexport */ src_hcl; });
__webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return /* reexport */ hclLong; });
__webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return /* reexport */ cubehelix["b" /* default */]; });
__webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return /* reexport */ cubehelix["a" /* cubehelixLong */]; });
__webpack_require__.d(__webpack_exports__, "piecewise", function() { return /* reexport */ piecewise["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "quantize", function() { return /* reexport */ quantize; });

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/value.js
var value = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/array.js
var array = __webpack_require__(106);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/basis.js
var basis = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/basisClosed.js
var basisClosed = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/date.js
var date = __webpack_require__(105);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/discrete.js
/* harmony default export */ var discrete = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/color.js
var color = __webpack_require__(7);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hue.js


/* harmony default export */ var src_hue = (function(a, b) {
  var i = Object(color["c" /* hue */])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/numberArray.js
var numberArray = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/object.js
var object = __webpack_require__(107);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/round.js
var round = __webpack_require__(167);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/string.js
var string = __webpack_require__(104);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/transform/index.js + 2 modules
var transform = __webpack_require__(150);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/zoom.js
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ var zoom = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/rgb.js
var rgb = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/d3-color/src/color.js
var src_color = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hsl.js



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(src_color["f" /* hsl */])(start)).h, (end = Object(src_color["f" /* hsl */])(end)).h),
        s = Object(color["a" /* default */])(start.s, end.s),
        l = Object(color["a" /* default */])(start.l, end.l),
        opacity = Object(color["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ var src_hsl = (hsl(color["c" /* hue */]));
var hslLong = hsl(color["a" /* default */]);

// EXTERNAL MODULE: ./node_modules/d3-color/src/define.js
var define = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/d3-color/src/math.js
var math = __webpack_require__(65);

// CONCATENATED MODULE: ./node_modules/d3-color/src/lab.js




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof src_color["b" /* Rgb */])) o = Object(src_color["h" /* rgbConvert */])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(define["a" /* default */])(Lab, lab, Object(define["b" /* extend */])(src_color["a" /* Color */], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new src_color["b" /* Rgb */](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * math["b" /* rad2deg */];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * math["a" /* deg2rad */];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(define["a" /* default */])(Hcl, hcl, Object(define["b" /* extend */])(src_color["a" /* Color */], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/lab.js



function lab_lab(start, end) {
  var l = Object(color["a" /* default */])((start = lab(start)).l, (end = lab(end)).l),
      a = Object(color["a" /* default */])(start.a, end.a),
      b = Object(color["a" /* default */])(start.b, end.b),
      opacity = Object(color["a" /* default */])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/hcl.js



function hcl_hcl(hue) {
  return function(start, end) {
    var h = hue((start = hcl(start)).h, (end = hcl(end)).h),
        c = Object(color["a" /* default */])(start.c, end.c),
        l = Object(color["a" /* default */])(start.l, end.l),
        opacity = Object(color["a" /* default */])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ var src_hcl = (hcl_hcl(color["c" /* hue */]));
var hclLong = hcl_hcl(color["a" /* default */]);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/cubehelix.js
var cubehelix = __webpack_require__(119);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/piecewise.js
var piecewise = __webpack_require__(170);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/quantize.js
/* harmony default export */ var quantize = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/index.js























/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return extend; });
/* harmony default export */ __webpack_exports__["a"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mark = undefined;

var _Mark = __webpack_require__(269);

var _Mark2 = _interopRequireDefault(_Mark);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Mark: _Mark2.default
};
exports.Mark = _Mark2.default;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(439),
    createAssigner = __webpack_require__(443);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "arc", function() { return /* reexport */ src_arc; });
__webpack_require__.d(__webpack_exports__, "area", function() { return /* reexport */ src_area; });
__webpack_require__.d(__webpack_exports__, "line", function() { return /* reexport */ src_line; });
__webpack_require__.d(__webpack_exports__, "pie", function() { return /* reexport */ src_pie; });
__webpack_require__.d(__webpack_exports__, "areaRadial", function() { return /* reexport */ areaRadial; });
__webpack_require__.d(__webpack_exports__, "radialArea", function() { return /* reexport */ areaRadial; });
__webpack_require__.d(__webpack_exports__, "lineRadial", function() { return /* reexport */ src_lineRadial; });
__webpack_require__.d(__webpack_exports__, "radialLine", function() { return /* reexport */ src_lineRadial; });
__webpack_require__.d(__webpack_exports__, "pointRadial", function() { return /* reexport */ pointRadial; });
__webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return /* reexport */ linkHorizontal; });
__webpack_require__.d(__webpack_exports__, "linkVertical", function() { return /* reexport */ linkVertical; });
__webpack_require__.d(__webpack_exports__, "linkRadial", function() { return /* reexport */ linkRadial; });
__webpack_require__.d(__webpack_exports__, "symbol", function() { return /* reexport */ src_symbol; });
__webpack_require__.d(__webpack_exports__, "symbols", function() { return /* reexport */ symbols; });
__webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return /* reexport */ circle; });
__webpack_require__.d(__webpack_exports__, "symbolCross", function() { return /* reexport */ cross; });
__webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return /* reexport */ diamond; });
__webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return /* reexport */ square; });
__webpack_require__.d(__webpack_exports__, "symbolStar", function() { return /* reexport */ star; });
__webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return /* reexport */ triangle; });
__webpack_require__.d(__webpack_exports__, "symbolWye", function() { return /* reexport */ wye; });
__webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return /* reexport */ basisClosed; });
__webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return /* reexport */ basisOpen; });
__webpack_require__.d(__webpack_exports__, "curveBasis", function() { return /* reexport */ basis; });
__webpack_require__.d(__webpack_exports__, "curveBundle", function() { return /* reexport */ curve_bundle; });
__webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return /* reexport */ cardinalClosed; });
__webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return /* reexport */ cardinalOpen; });
__webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return /* reexport */ cardinal; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return /* reexport */ catmullRomClosed; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return /* reexport */ catmullRomOpen; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return /* reexport */ curve_catmullRom; });
__webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return /* reexport */ linearClosed; });
__webpack_require__.d(__webpack_exports__, "curveLinear", function() { return /* reexport */ linear; });
__webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return /* reexport */ monotoneX; });
__webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return /* reexport */ monotoneY; });
__webpack_require__.d(__webpack_exports__, "curveNatural", function() { return /* reexport */ natural; });
__webpack_require__.d(__webpack_exports__, "curveStep", function() { return /* reexport */ step; });
__webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return /* reexport */ stepAfter; });
__webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return /* reexport */ stepBefore; });
__webpack_require__.d(__webpack_exports__, "stack", function() { return /* reexport */ src_stack; });
__webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return /* reexport */ expand; });
__webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return /* reexport */ diverging; });
__webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return /* reexport */ none; });
__webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return /* reexport */ silhouette; });
__webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return /* reexport */ wiggle; });
__webpack_require__.d(__webpack_exports__, "stackOrderAppearance", function() { return /* reexport */ appearance; });
__webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return /* reexport */ ascending; });
__webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return /* reexport */ order_descending; });
__webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return /* reexport */ insideOut; });
__webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return /* reexport */ order_none; });
__webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return /* reexport */ reverse; });

// EXTERNAL MODULE: ./node_modules/d3-path/src/path.js
var path = __webpack_require__(520);

// CONCATENATED MODULE: ./node_modules/d3-shape/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function constant() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/arc.js




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ var src_arc = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = Object(path["a" /* default */])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ var linear = (function(context) {
  return new Linear(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/point.js
function point_x(p) {
  return p[0];
}

function point_y(p) {
  return p[1];
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/line.js





/* harmony default export */ var src_line = (function() {
  var x = point_x,
      y = point_y,
      defined = constant(true),
      context = null,
      curve = linear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = Object(path["a" /* default */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/area.js






/* harmony default export */ var src_area = (function() {
  var x0 = point_x,
      x1 = null,
      y0 = constant(0),
      y1 = point_y,
      defined = constant(true),
      context = null,
      curve = linear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = Object(path["a" /* default */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return src_line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/identity.js
/* harmony default export */ var identity = (function(d) {
  return d;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/pie.js





/* harmony default export */ var src_pie = (function() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/radial.js


var curveRadialLinear = curveRadial(linear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/lineRadial.js



function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ var src_lineRadial = (function() {
  return lineRadial(src_line().curve(curveRadialLinear));
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/areaRadial.js




/* harmony default export */ var areaRadial = (function() {
  var a = src_area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/pointRadial.js
/* harmony default export */ var pointRadial = (function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// CONCATENATED MODULE: ./node_modules/d3-shape/src/link/index.js






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link_link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = point_x,
      y = point_y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = Object(path["a" /* default */])();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function link_curveRadial(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link_link(curveHorizontal);
}

function linkVertical() {
  return link_link(curveVertical);
}

function linkRadial() {
  var l = link_link(link_curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/circle.js


/* harmony default export */ var circle = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/cross.js
/* harmony default export */ var cross = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ var diamond = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/star.js


var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

/* harmony default export */ var star = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/square.js
/* harmony default export */ var square = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

/* harmony default export */ var triangle = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol/wye.js
var wye_c = -0.5,
    wye_s = Math.sqrt(3) / 2,
    wye_k = 1 / Math.sqrt(12),
    wye_a = (wye_k / 2 + 1) * 3;

/* harmony default export */ var wye = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / wye_a),
        x0 = r / 2,
        y0 = r * wye_k,
        x1 = x0,
        y1 = r * wye_k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(wye_c * x0 - wye_s * y0, wye_s * x0 + wye_c * y0);
    context.lineTo(wye_c * x1 - wye_s * y1, wye_s * x1 + wye_c * y1);
    context.lineTo(wye_c * x2 - wye_s * y2, wye_s * x2 + wye_c * y2);
    context.lineTo(wye_c * x0 + wye_s * y0, wye_c * y0 - wye_s * x0);
    context.lineTo(wye_c * x1 + wye_s * y1, wye_c * y1 - wye_s * x1);
    context.lineTo(wye_c * x2 + wye_s * y2, wye_c * y2 - wye_s * x2);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/symbol.js










var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

/* harmony default export */ var src_symbol = (function() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = Object(path["a" /* default */])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/noop.js
/* harmony default export */ var noop = (function() {});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basis.js
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basis = (function(context) {
  return new Basis(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basisClosed.js



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basisClosed = (function(context) {
  return new BasisClosed(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/basisOpen.js


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basisOpen = (function(context) {
  return new BasisOpen(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/bundle.js


function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ var curve_bundle = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinal.js
function cardinal_point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: cardinal_point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinal = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinalClosed.js



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinalClosed = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/cardinalOpen.js


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinalOpen = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRom.js



function catmullRom_point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var curve_catmullRom = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRomClosed.js




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var catmullRomClosed = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/catmullRomOpen.js



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var catmullRomOpen = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linearClosed.js


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ var linearClosed = (function(context) {
  return new LinearClosed(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/monotone.js
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function monotone_point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: monotone_point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; monotone_point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: monotone_point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ var natural = (function(context) {
  return new Natural(context);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ var step = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/none.js
/* harmony default export */ var none = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/none.js
/* harmony default export */ var order_none = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/stack.js





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ var src_stack = (function() {
  var keys = constant([]),
      order = order_none,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? order_none : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/expand.js


/* harmony default export */ var expand = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/diverging.js
/* harmony default export */ var diverging = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/silhouette.js


/* harmony default export */ var silhouette = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/offset/wiggle.js


/* harmony default export */ var wiggle = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/appearance.js


/* harmony default export */ var appearance = (function(series) {
  var peaks = series.map(peak);
  return order_none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
});

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/ascending.js


/* harmony default export */ var ascending = (function(series) {
  var sums = series.map(ascending_sum);
  return order_none(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function ascending_sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/descending.js


/* harmony default export */ var order_descending = (function(series) {
  return ascending(series).reverse();
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/insideOut.js



/* harmony default export */ var insideOut = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(ascending_sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/order/reverse.js


/* harmony default export */ var reverse = (function(series) {
  return order_none(series).reverse();
});

// CONCATENATED MODULE: ./node_modules/d3-shape/src/index.js




 // Note: radialArea is deprecated!
 // Note: radialLine is deprecated!










































/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGlobalStyle", function() { return createGlobalStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "css", function() { return css; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStyledComponent", function() { return isStyledComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyframes", function() { return keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServerStyleSheet", function() { return ServerStyleSheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleSheetConsumer", function() { return StyleSheetConsumer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleSheetContext", function() { return StyleSheetContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleSheetManager", function() { return StyleSheetManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeConsumer", function() { return ThemeConsumer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeContext", function() { return ThemeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeProvider", function() { return ThemeProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withTheme", function() { return withTheme; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS", function() { return __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS; });
/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(151);
/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(227);
/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(228);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(111);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(230);
/* harmony import */ var merge_anything__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(231);










// 

var interleave = (function (strings, interpolations) {
  var result = [strings[0]];

  for (var i = 0, len = interpolations.length; i < len; i += 1) {
    result.push(interpolations[i], strings[i + 1]);
  }

  return result;
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

// 
var isPlainObject = (function (x) {
  return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x.constructor === Object;
});

// 
var EMPTY_ARRAY = Object.freeze([]);
var EMPTY_OBJECT = Object.freeze({});

// 
function isFunction(test) {
  return typeof test === 'function';
}

// 

function getComponentName(target) {
  return ( false) || target.displayName || target.name || 'Component';
}

// 
function isStatelessFunction(test) {
  return typeof test === 'function' && !(test.prototype && test.prototype.isReactComponent);
}

// 
function isStyledComponent(target) {
  return target && typeof target.styledComponentId === 'string';
}

// 

var SC_ATTR = typeof process !== 'undefined' && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || 'data-styled';

var SC_VERSION_ATTR = 'data-styled-version';

var SC_STREAM_ATTR = 'data-styled-streamed';

var IS_BROWSER = typeof window !== 'undefined' && 'HTMLElement' in window;

var DISABLE_SPEEDY = typeof SC_DISABLE_SPEEDY === 'boolean' && SC_DISABLE_SPEEDY || typeof process !== 'undefined' && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || "production" !== 'production';

// Shared empty execution context when generating static styles
var STATIC_EXECUTION_CONTEXT = {};

// 


/**
 * Parse errors.md and turn it into a simple hash of code: message
 */
var ERRORS =  false ? undefined : {};

/**
 * super basic version of sprintf
 */
function format() {
  var a = arguments.length <= 0 ? undefined : arguments[0];
  var b = [];

  for (var c = 1, len = arguments.length; c < len; c += 1) {
    b.push(arguments.length <= c ? undefined : arguments[c]);
  }

  b.forEach(function (d) {
    a = a.replace(/%[a-z]/, d);
  });

  return a;
}

/**
 * Create an error file out of errors.md for development and a simple web link to the full errors
 * in production mode.
 */

var StyledComponentsError = function (_Error) {
  inherits(StyledComponentsError, _Error);

  function StyledComponentsError(code) {
    classCallCheck(this, StyledComponentsError);

    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      interpolations[_key - 1] = arguments[_key];
    }

    if (true) {
      var _this = possibleConstructorReturn(this, _Error.call(this, 'An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#' + code + ' for more information.' + (interpolations.length > 0 ? ' Additional arguments: ' + interpolations.join(', ') : '')));
    } else { var _this; }
    return possibleConstructorReturn(_this);
  }

  return StyledComponentsError;
}(Error);

// 
var SC_COMPONENT_ID = /^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm;

var extractComps = (function (maybeCSS) {
  var css = '' + (maybeCSS || ''); // Definitely a string, and a clone
  var existingComponents = [];
  css.replace(SC_COMPONENT_ID, function (match, componentId, matchIndex) {
    existingComponents.push({ componentId: componentId, matchIndex: matchIndex });
    return match;
  });
  return existingComponents.map(function (_ref, i) {
    var componentId = _ref.componentId,
        matchIndex = _ref.matchIndex;

    var nextComp = existingComponents[i + 1];
    var cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);
    return { componentId: componentId, cssFromDOM: cssFromDOM };
  });
});

// 

var COMMENT_REGEX = /^\s*\/\/.*$/gm;

// NOTE: This stylis instance is only used to split rules from SSR'd style tags
var stylisSplitter = new stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default.a({
  global: false,
  cascade: true,
  keyframe: false,
  prefix: false,
  compress: false,
  semicolon: true
});

var stylis = new stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default.a({
  global: false,
  cascade: true,
  keyframe: false,
  prefix: true,
  compress: false,
  semicolon: false // NOTE: This means "autocomplete missing semicolons"
});

// Wrap `insertRulePlugin to build a list of rules,
// and then make our own plugin to return the rules. This
// makes it easier to hook into the existing SSR architecture

var parsingRules = [];

// eslint-disable-next-line consistent-return
var returnRulesPlugin = function returnRulesPlugin(context) {
  if (context === -2) {
    var parsedRules = parsingRules;
    parsingRules = [];
    return parsedRules;
  }
};

var parseRulesPlugin = stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default()(function (rule) {
  parsingRules.push(rule);
});

var _componentId = void 0;
var _selector = void 0;
var _selectorRegexp = void 0;

var selfReferenceReplacer = function selfReferenceReplacer(match, offset, string) {
  if (
  // the first self-ref is always untouched
  offset > 0 &&
  // there should be at least two self-refs to do a replacement (.b > .b)
  string.slice(0, offset).indexOf(_selector) !== -1 &&
  // no consecutive self refs (.b.b); that is a precedence boost and treated differently
  string.slice(offset - _selector.length, offset) !== _selector) {
    return '.' + _componentId;
  }

  return match;
};

/**
 * When writing a style like
 *
 * & + & {
 *   color: red;
 * }
 *
 * The second ampersand should be a reference to the static component class. stylis
 * has no knowledge of static class so we have to intelligently replace the base selector.
 */
var selfReferenceReplacementPlugin = function selfReferenceReplacementPlugin(context, _, selectors) {
  if (context === 2 && selectors.length && selectors[0].lastIndexOf(_selector) > 0) {
    // eslint-disable-next-line no-param-reassign
    selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer);
  }
};

stylis.use([selfReferenceReplacementPlugin, parseRulesPlugin, returnRulesPlugin]);
stylisSplitter.use([parseRulesPlugin, returnRulesPlugin]);

var splitByRules = function splitByRules(css) {
  return stylisSplitter('', css);
};

function stringifyRules(rules, selector, prefix) {
  var componentId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '&';

  var flatCSS = rules.join('').replace(COMMENT_REGEX, ''); // replace JS comments

  var cssStr = selector && prefix ? prefix + ' ' + selector + ' { ' + flatCSS + ' }' : flatCSS;

  // stylis has no concept of state to be passed to plugins
  // but since JS is single=threaded, we can rely on that to ensure
  // these properties stay in sync with the current stylis run
  _componentId = componentId;
  _selector = selector;
  _selectorRegexp = new RegExp('\\' + _selector + '\\b', 'g');

  return stylis(prefix || !selector ? '' : selector, cssStr);
}

// 
/* eslint-disable camelcase, no-undef */

var getNonce = (function () {
  return  true ? __webpack_require__.nc : undefined;
});

// 
/* These are helpers for the StyleTags to keep track of the injected
 * rule names for each (component) ID that they're keeping track of.
 * They're crucial for detecting whether a name has already been
 * injected.
 * (This excludes rehydrated names) */

/* adds a new ID:name pairing to a names dictionary */
var addNameForId = function addNameForId(names, id, name) {
  if (name) {
    // eslint-disable-next-line no-param-reassign
    var namesForId = names[id] || (names[id] = Object.create(null));
    namesForId[name] = true;
  }
};

/* resets an ID entirely by overwriting it in the dictionary */
var resetIdNames = function resetIdNames(names, id) {
  // eslint-disable-next-line no-param-reassign
  names[id] = Object.create(null);
};

/* factory for a names dictionary checking the existance of an ID:name pairing */
var hasNameForId = function hasNameForId(names) {
  return function (id, name) {
    return names[id] !== undefined && names[id][name];
  };
};

/* stringifies names for the html/element output */
var stringifyNames = function stringifyNames(names) {
  var str = '';
  // eslint-disable-next-line guard-for-in
  for (var id in names) {
    str += Object.keys(names[id]).join(' ') + ' ';
  }
  return str.trim();
};

/* clones the nested names dictionary */
var cloneNames = function cloneNames(names) {
  var clone = Object.create(null);
  // eslint-disable-next-line guard-for-in
  for (var id in names) {
    clone[id] = _extends({}, names[id]);
  }
  return clone;
};

// 

/* These are helpers that deal with the insertRule (aka speedy) API
 * They are used in the StyleTags and specifically the speedy tag
 */

/* retrieve a sheet for a given style tag */
var sheetForTag = function sheetForTag(tag) {
  // $FlowFixMe
  if (tag.sheet) return tag.sheet;

  /* Firefox quirk requires us to step through all stylesheets to find one owned by the given tag */
  var size = tag.ownerDocument.styleSheets.length;
  for (var i = 0; i < size; i += 1) {
    var sheet = tag.ownerDocument.styleSheets[i];
    // $FlowFixMe
    if (sheet.ownerNode === tag) return sheet;
  }

  /* we should always be able to find a tag */
  throw new StyledComponentsError(10);
};

/* insert a rule safely and return whether it was actually injected */
var safeInsertRule = function safeInsertRule(sheet, cssRule, index) {
  /* abort early if cssRule string is falsy */
  if (!cssRule) return false;

  var maxIndex = sheet.cssRules.length;

  try {
    /* use insertRule and cap passed index with maxIndex (no of cssRules) */
    sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);
  } catch (err) {
    /* any error indicates an invalid rule */
    return false;
  }

  return true;
};

/* deletes `size` rules starting from `removalIndex` */
var deleteRules = function deleteRules(sheet, removalIndex, size) {
  var lowerBound = removalIndex - size;
  for (var i = removalIndex; i > lowerBound; i -= 1) {
    sheet.deleteRule(i);
  }
};

// 

/* this marker separates component styles and is important for rehydration */
var makeTextMarker = function makeTextMarker(id) {
  return '\n/* sc-component-id: ' + id + ' */\n';
};

/* add up all numbers in array up until and including the index */
var addUpUntilIndex = function addUpUntilIndex(sizes, index) {
  var totalUpToIndex = 0;
  for (var i = 0; i <= index; i += 1) {
    totalUpToIndex += sizes[i];
  }

  return totalUpToIndex;
};

/* create a new style tag after lastEl */
var makeStyleTag = function makeStyleTag(target, tagEl, insertBefore) {
  var targetDocument = document;
  if (target) targetDocument = target.ownerDocument;else if (tagEl) targetDocument = tagEl.ownerDocument;

  var el = targetDocument.createElement('style');
  el.setAttribute(SC_ATTR, '');
  el.setAttribute(SC_VERSION_ATTR, "4.4.1");

  var nonce = getNonce();
  if (nonce) {
    el.setAttribute('nonce', nonce);
  }

  /* Work around insertRule quirk in EdgeHTML */
  el.appendChild(targetDocument.createTextNode(''));

  if (target && !tagEl) {
    /* Append to target when no previous element was passed */
    target.appendChild(el);
  } else {
    if (!tagEl || !target || !tagEl.parentNode) {
      throw new StyledComponentsError(6);
    }

    /* Insert new style tag after the previous one */
    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);
  }

  return el;
};

/* takes a css factory function and outputs an html styled tag factory */
var wrapAsHtmlTag = function wrapAsHtmlTag(css, names) {
  return function (additionalAttrs) {
    var nonce = getNonce();
    var attrs = [nonce && 'nonce="' + nonce + '"', SC_ATTR + '="' + stringifyNames(names) + '"', SC_VERSION_ATTR + '="' + "4.4.1" + '"', additionalAttrs];

    var htmlAttr = attrs.filter(Boolean).join(' ');
    return '<style ' + htmlAttr + '>' + css() + '</style>';
  };
};

/* takes a css factory function and outputs an element factory */
var wrapAsElement = function wrapAsElement(css, names) {
  return function () {
    var _props;

    var props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = "4.4.1", _props);

    var nonce = getNonce();
    if (nonce) {
      // $FlowFixMe
      props.nonce = nonce;
    }

    // eslint-disable-next-line react/no-danger
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement('style', _extends({}, props, { dangerouslySetInnerHTML: { __html: css() } }));
  };
};

var getIdsFromMarkersFactory = function getIdsFromMarkersFactory(markers) {
  return function () {
    return Object.keys(markers);
  };
};

/* speedy tags utilise insertRule */
var makeSpeedyTag = function makeSpeedyTag(el, getImportRuleTag) {
  var names = Object.create(null);
  var markers = Object.create(null);
  var sizes = [];

  var extractImport = getImportRuleTag !== undefined;
  /* indicates whether getImportRuleTag was called */
  var usedImportRuleTag = false;

  var insertMarker = function insertMarker(id) {
    var prev = markers[id];
    if (prev !== undefined) {
      return prev;
    }

    markers[id] = sizes.length;
    sizes.push(0);
    resetIdNames(names, id);

    return markers[id];
  };

  var insertRules = function insertRules(id, cssRules, name) {
    var marker = insertMarker(id);
    var sheet = sheetForTag(el);
    var insertIndex = addUpUntilIndex(sizes, marker);

    var injectedRules = 0;
    var importRules = [];
    var cssRulesSize = cssRules.length;

    for (var i = 0; i < cssRulesSize; i += 1) {
      var cssRule = cssRules[i];
      var mayHaveImport = extractImport; /* @import rules are reordered to appear first */
      if (mayHaveImport && cssRule.indexOf('@import') !== -1) {
        importRules.push(cssRule);
      } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {
        mayHaveImport = false;
        injectedRules += 1;
      }
    }

    if (extractImport && importRules.length > 0) {
      usedImportRuleTag = true;
      // $FlowFixMe
      getImportRuleTag().insertRules(id + '-import', importRules);
    }

    sizes[marker] += injectedRules; /* add up no of injected rules */
    addNameForId(names, id, name);
  };

  var removeRules = function removeRules(id) {
    var marker = markers[id];
    if (marker === undefined) return;
    // $FlowFixMe
    if (el.isConnected === false) return;

    var size = sizes[marker];
    var sheet = sheetForTag(el);
    var removalIndex = addUpUntilIndex(sizes, marker) - 1;
    deleteRules(sheet, removalIndex, size);
    sizes[marker] = 0;
    resetIdNames(names, id);

    if (extractImport && usedImportRuleTag) {
      // $FlowFixMe
      getImportRuleTag().removeRules(id + '-import');
    }
  };

  var css = function css() {
    var _sheetForTag = sheetForTag(el),
        cssRules = _sheetForTag.cssRules;

    var str = '';

    // eslint-disable-next-line guard-for-in
    for (var id in markers) {
      str += makeTextMarker(id);
      var marker = markers[id];
      var end = addUpUntilIndex(sizes, marker);
      var size = sizes[marker];
      for (var i = end - size; i < end; i += 1) {
        var rule = cssRules[i];
        if (rule !== undefined) {
          str += rule.cssText;
        }
      }
    }

    return str;
  };

  return {
    clone: function clone() {
      throw new StyledComponentsError(5);
    },

    css: css,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker: insertMarker,
    insertRules: insertRules,
    removeRules: removeRules,
    sealed: false,
    styleTag: el,
    toElement: wrapAsElement(css, names),
    toHTML: wrapAsHtmlTag(css, names)
  };
};

var makeTextNode = function makeTextNode(targetDocument, id) {
  return targetDocument.createTextNode(makeTextMarker(id));
};

var makeBrowserTag = function makeBrowserTag(el, getImportRuleTag) {
  var names = Object.create(null);
  var markers = Object.create(null);

  var extractImport = getImportRuleTag !== undefined;

  /* indicates whether getImportRuleTag was called */
  var usedImportRuleTag = false;

  var insertMarker = function insertMarker(id) {
    var prev = markers[id];
    if (prev !== undefined) {
      return prev;
    }

    markers[id] = makeTextNode(el.ownerDocument, id);
    el.appendChild(markers[id]);
    names[id] = Object.create(null);

    return markers[id];
  };

  var insertRules = function insertRules(id, cssRules, name) {
    var marker = insertMarker(id);
    var importRules = [];
    var cssRulesSize = cssRules.length;

    for (var i = 0; i < cssRulesSize; i += 1) {
      var rule = cssRules[i];
      var mayHaveImport = extractImport;
      if (mayHaveImport && rule.indexOf('@import') !== -1) {
        importRules.push(rule);
      } else {
        mayHaveImport = false;
        var separator = i === cssRulesSize - 1 ? '' : ' ';
        marker.appendData('' + rule + separator);
      }
    }

    addNameForId(names, id, name);

    if (extractImport && importRules.length > 0) {
      usedImportRuleTag = true;
      // $FlowFixMe
      getImportRuleTag().insertRules(id + '-import', importRules);
    }
  };

  var removeRules = function removeRules(id) {
    var marker = markers[id];
    if (marker === undefined) return;

    /* create new empty text node and replace the current one */
    var newMarker = makeTextNode(el.ownerDocument, id);
    el.replaceChild(newMarker, marker);
    markers[id] = newMarker;
    resetIdNames(names, id);

    if (extractImport && usedImportRuleTag) {
      // $FlowFixMe
      getImportRuleTag().removeRules(id + '-import');
    }
  };

  var css = function css() {
    var str = '';

    // eslint-disable-next-line guard-for-in
    for (var id in markers) {
      str += markers[id].data;
    }

    return str;
  };

  return {
    clone: function clone() {
      throw new StyledComponentsError(5);
    },

    css: css,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker: insertMarker,
    insertRules: insertRules,
    removeRules: removeRules,
    sealed: false,
    styleTag: el,
    toElement: wrapAsElement(css, names),
    toHTML: wrapAsHtmlTag(css, names)
  };
};

var makeServerTag = function makeServerTag(namesArg, markersArg) {
  var names = namesArg === undefined ? Object.create(null) : namesArg;
  var markers = markersArg === undefined ? Object.create(null) : markersArg;

  var insertMarker = function insertMarker(id) {
    var prev = markers[id];
    if (prev !== undefined) {
      return prev;
    }

    return markers[id] = [''];
  };

  var insertRules = function insertRules(id, cssRules, name) {
    var marker = insertMarker(id);
    marker[0] += cssRules.join(' ');
    addNameForId(names, id, name);
  };

  var removeRules = function removeRules(id) {
    var marker = markers[id];
    if (marker === undefined) return;
    marker[0] = '';
    resetIdNames(names, id);
  };

  var css = function css() {
    var str = '';
    // eslint-disable-next-line guard-for-in
    for (var id in markers) {
      var cssForId = markers[id][0];
      if (cssForId) {
        str += makeTextMarker(id) + cssForId;
      }
    }
    return str;
  };

  var clone = function clone() {
    var namesClone = cloneNames(names);
    var markersClone = Object.create(null);

    // eslint-disable-next-line guard-for-in
    for (var id in markers) {
      markersClone[id] = [markers[id][0]];
    }

    return makeServerTag(namesClone, markersClone);
  };

  var tag = {
    clone: clone,
    css: css,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker: insertMarker,
    insertRules: insertRules,
    removeRules: removeRules,
    sealed: false,
    styleTag: null,
    toElement: wrapAsElement(css, names),
    toHTML: wrapAsHtmlTag(css, names)
  };

  return tag;
};

var makeTag = function makeTag(target, tagEl, forceServer, insertBefore, getImportRuleTag) {
  if (IS_BROWSER && !forceServer) {
    var el = makeStyleTag(target, tagEl, insertBefore);

    if (DISABLE_SPEEDY) {
      return makeBrowserTag(el, getImportRuleTag);
    } else {
      return makeSpeedyTag(el, getImportRuleTag);
    }
  }

  return makeServerTag();
};

var rehydrate = function rehydrate(tag, els, extracted) {
  /* add all extracted components to the new tag */
  for (var i = 0, len = extracted.length; i < len; i += 1) {
    var _extracted$i = extracted[i],
        componentId = _extracted$i.componentId,
        cssFromDOM = _extracted$i.cssFromDOM;

    var cssRules = splitByRules(cssFromDOM);
    tag.insertRules(componentId, cssRules);
  }

  /* remove old HTMLStyleElements, since they have been rehydrated */
  for (var _i = 0, _len = els.length; _i < _len; _i += 1) {
    var el = els[_i];
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
};

// 

var SPLIT_REGEX = /\s+/;

/* determine the maximum number of components before tags are sharded */
var MAX_SIZE = void 0;
if (IS_BROWSER) {
  /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */
  MAX_SIZE = DISABLE_SPEEDY ? 40 : 1000;
} else {
  /* for servers we do not need to shard at all */
  MAX_SIZE = -1;
}

var sheetRunningId = 0;
var master = void 0;

var StyleSheet = function () {

  /* a map from ids to tags */

  /* deferred rules for a given id */

  /* this is used for not reinjecting rules via hasNameForId() */

  /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */

  /* a list of tags belonging to this StyleSheet */

  /* a tag for import rules */

  /* current capacity until a new tag must be created */

  /* children (aka clones) of this StyleSheet inheriting all and future injections */

  function StyleSheet() {
    var _this = this;

    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IS_BROWSER ? document.head : null;
    var forceServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    classCallCheck(this, StyleSheet);

    this.getImportRuleTag = function () {
      var importRuleTag = _this.importRuleTag;

      if (importRuleTag !== undefined) {
        return importRuleTag;
      }

      var firstTag = _this.tags[0];
      var insertBefore = true;

      return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);
    };

    sheetRunningId += 1;
    this.id = sheetRunningId;
    this.forceServer = forceServer;
    this.target = forceServer ? null : target;
    this.tagMap = {};
    this.deferred = {};
    this.rehydratedNames = {};
    this.ignoreRehydratedNames = {};
    this.tags = [];
    this.capacity = 1;
    this.clones = [];
  }

  /* rehydrate all SSR'd style tags */


  StyleSheet.prototype.rehydrate = function rehydrate$$1() {
    if (!IS_BROWSER || this.forceServer) return this;

    var els = [];
    var extracted = [];
    var isStreamed = false;

    /* retrieve all of our SSR style elements from the DOM */
    var nodes = document.querySelectorAll('style[' + SC_ATTR + '][' + SC_VERSION_ATTR + '="' + "4.4.1" + '"]');

    var nodesSize = nodes.length;

    /* abort rehydration if no previous style tags were found */
    if (!nodesSize) return this;

    for (var i = 0; i < nodesSize; i += 1) {
      var el = nodes[i];

      /* check if style tag is a streamed tag */
      if (!isStreamed) isStreamed = !!el.getAttribute(SC_STREAM_ATTR);

      /* retrieve all component names */
      var elNames = (el.getAttribute(SC_ATTR) || '').trim().split(SPLIT_REGEX);
      var elNamesSize = elNames.length;
      for (var j = 0, name; j < elNamesSize; j += 1) {
        name = elNames[j];
        /* add rehydrated name to sheet to avoid re-adding styles */
        this.rehydratedNames[name] = true;
      }

      /* extract all components and their CSS */
      extracted.push.apply(extracted, extractComps(el.textContent));

      /* store original HTMLStyleElement */
      els.push(el);
    }

    /* abort rehydration if nothing was extracted */
    var extractedSize = extracted.length;
    if (!extractedSize) return this;

    /* create a tag to be used for rehydration */
    var tag = this.makeTag(null);

    rehydrate(tag, els, extracted);

    /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */
    this.capacity = Math.max(1, MAX_SIZE - extractedSize);
    this.tags.push(tag);

    /* retrieve all component ids */
    for (var _j = 0; _j < extractedSize; _j += 1) {
      this.tagMap[extracted[_j].componentId] = tag;
    }

    return this;
  };

  /* retrieve a "master" instance of StyleSheet which is typically used when no other is available
   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any
    * StyleSheetManager's context */


  /* reset the internal "master" instance */
  StyleSheet.reset = function reset() {
    var forceServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    master = new StyleSheet(undefined, forceServer).rehydrate();
  };

  /* adds "children" to the StyleSheet that inherit all of the parents' rules
   * while their own rules do not affect the parent */


  StyleSheet.prototype.clone = function clone() {
    var sheet = new StyleSheet(this.target, this.forceServer);

    /* add to clone array */
    this.clones.push(sheet);

    /* clone all tags */
    sheet.tags = this.tags.map(function (tag) {
      var ids = tag.getIds();
      var newTag = tag.clone();

      /* reconstruct tagMap */
      for (var i = 0; i < ids.length; i += 1) {
        sheet.tagMap[ids[i]] = newTag;
      }

      return newTag;
    });

    /* clone other maps */
    sheet.rehydratedNames = _extends({}, this.rehydratedNames);
    sheet.deferred = _extends({}, this.deferred);

    return sheet;
  };

  /* force StyleSheet to create a new tag on the next injection */


  StyleSheet.prototype.sealAllTags = function sealAllTags() {
    this.capacity = 1;

    this.tags.forEach(function (tag) {
      // eslint-disable-next-line no-param-reassign
      tag.sealed = true;
    });
  };

  StyleSheet.prototype.makeTag = function makeTag$$1(tag) {
    var lastEl = tag ? tag.styleTag : null;
    var insertBefore = false;

    return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);
  };

  /* get a tag for a given componentId, assign the componentId to one, or shard */
  StyleSheet.prototype.getTagForId = function getTagForId(id) {
    /* simply return a tag, when the componentId was already assigned one */
    var prev = this.tagMap[id];
    if (prev !== undefined && !prev.sealed) {
      return prev;
    }

    var tag = this.tags[this.tags.length - 1];

    /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */
    this.capacity -= 1;

    if (this.capacity === 0) {
      this.capacity = MAX_SIZE;
      tag = this.makeTag(tag);
      this.tags.push(tag);
    }

    return this.tagMap[id] = tag;
  };

  /* mainly for createGlobalStyle to check for its id */


  StyleSheet.prototype.hasId = function hasId(id) {
    return this.tagMap[id] !== undefined;
  };

  /* caching layer checking id+name to already have a corresponding tag and injected rules */


  StyleSheet.prototype.hasNameForId = function hasNameForId(id, name) {
    /* exception for rehydrated names which are checked separately */
    if (this.ignoreRehydratedNames[id] === undefined && this.rehydratedNames[name]) {
      return true;
    }

    var tag = this.tagMap[id];
    return tag !== undefined && tag.hasNameForId(id, name);
  };

  /* registers a componentId and registers it on its tag */


  StyleSheet.prototype.deferredInject = function deferredInject(id, cssRules) {
    /* don't inject when the id is already registered */
    if (this.tagMap[id] !== undefined) return;

    var clones = this.clones;

    for (var i = 0; i < clones.length; i += 1) {
      clones[i].deferredInject(id, cssRules);
    }

    this.getTagForId(id).insertMarker(id);
    this.deferred[id] = cssRules;
  };

  /* injects rules for a given id with a name that will need to be cached */


  StyleSheet.prototype.inject = function inject(id, cssRules, name) {
    var clones = this.clones;


    for (var i = 0; i < clones.length; i += 1) {
      clones[i].inject(id, cssRules, name);
    }

    var tag = this.getTagForId(id);

    /* add deferred rules for component */
    if (this.deferred[id] !== undefined) {
      // Combine passed cssRules with previously deferred CSS rules
      // NOTE: We cannot mutate the deferred array itself as all clones
      // do the same (see clones[i].inject)
      var rules = this.deferred[id].concat(cssRules);
      tag.insertRules(id, rules, name);

      this.deferred[id] = undefined;
    } else {
      tag.insertRules(id, cssRules, name);
    }
  };

  /* removes all rules for a given id, which doesn't remove its marker but resets it */


  StyleSheet.prototype.remove = function remove(id) {
    var tag = this.tagMap[id];
    if (tag === undefined) return;

    var clones = this.clones;

    for (var i = 0; i < clones.length; i += 1) {
      clones[i].remove(id);
    }

    /* remove all rules from the tag */
    tag.removeRules(id);

    /* ignore possible rehydrated names */
    this.ignoreRehydratedNames[id] = true;

    /* delete possible deferred rules */
    this.deferred[id] = undefined;
  };

  StyleSheet.prototype.toHTML = function toHTML() {
    return this.tags.map(function (tag) {
      return tag.toHTML();
    }).join('');
  };

  StyleSheet.prototype.toReactElements = function toReactElements() {
    var id = this.id;


    return this.tags.map(function (tag, i) {
      var key = 'sc-' + id + '-' + i;
      return Object(react__WEBPACK_IMPORTED_MODULE_2__["cloneElement"])(tag.toElement(), { key: key });
    });
  };

  createClass(StyleSheet, null, [{
    key: 'master',
    get: function get$$1() {
      return master || (master = new StyleSheet().rehydrate());
    }

    /* NOTE: This is just for backwards-compatibility with jest-styled-components */

  }, {
    key: 'instance',
    get: function get$$1() {
      return StyleSheet.master;
    }
  }]);
  return StyleSheet;
}();

// 

var Keyframes = function () {
  function Keyframes(name, rules) {
    var _this = this;

    classCallCheck(this, Keyframes);

    this.inject = function (styleSheet) {
      if (!styleSheet.hasNameForId(_this.id, _this.name)) {
        styleSheet.inject(_this.id, _this.rules, _this.name);
      }
    };

    this.toString = function () {
      throw new StyledComponentsError(12, String(_this.name));
    };

    this.name = name;
    this.rules = rules;

    this.id = 'sc-keyframes-' + name;
  }

  Keyframes.prototype.getName = function getName() {
    return this.name;
  };

  return Keyframes;
}();

// 

/**
 * inlined version of
 * https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/hyphenateStyleName.js
 */

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return string.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

// 

// Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js
function addUnitIfNeeded(name, value) {
  // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133
  // $FlowFixMe
  if (value == null || typeof value === 'boolean' || value === '') {
    return '';
  }

  if (typeof value === 'number' && value !== 0 && !(name in _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return String(value).trim();
}

// 

/**
 * It's falsish not falsy because 0 is allowed.
 */
var isFalsish = function isFalsish(chunk) {
  return chunk === undefined || chunk === null || chunk === false || chunk === '';
};

var objToCssArray = function objToCssArray(obj, prevKey) {
  var rules = [];
  var keys = Object.keys(obj);

  keys.forEach(function (key) {
    if (!isFalsish(obj[key])) {
      if (isPlainObject(obj[key])) {
        rules.push.apply(rules, objToCssArray(obj[key], key));

        return rules;
      } else if (isFunction(obj[key])) {
        rules.push(hyphenateStyleName(key) + ':', obj[key], ';');

        return rules;
      }
      rules.push(hyphenateStyleName(key) + ': ' + addUnitIfNeeded(key, obj[key]) + ';');
    }
    return rules;
  });

  return prevKey ? [prevKey + ' {'].concat(rules, ['}']) : rules;
};

function flatten(chunk, executionContext, styleSheet) {
  if (Array.isArray(chunk)) {
    var ruleSet = [];

    for (var i = 0, len = chunk.length, result; i < len; i += 1) {
      result = flatten(chunk[i], executionContext, styleSheet);

      if (result === null) continue;else if (Array.isArray(result)) ruleSet.push.apply(ruleSet, result);else ruleSet.push(result);
    }

    return ruleSet;
  }

  if (isFalsish(chunk)) {
    return null;
  }

  /* Handle other components */
  if (isStyledComponent(chunk)) {
    return '.' + chunk.styledComponentId;
  }

  /* Either execute or defer the function */
  if (isFunction(chunk)) {
    if (isStatelessFunction(chunk) && executionContext) {
      var _result = chunk(executionContext);

      if (false) {}

      return flatten(_result, executionContext, styleSheet);
    } else return chunk;
  }

  if (chunk instanceof Keyframes) {
    if (styleSheet) {
      chunk.inject(styleSheet);
      return chunk.getName();
    } else return chunk;
  }

  /* Handle objects */
  return isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();
}

// 

function css(styles) {
  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    interpolations[_key - 1] = arguments[_key];
  }

  if (isFunction(styles) || isPlainObject(styles)) {
    // $FlowFixMe
    return flatten(interleave(EMPTY_ARRAY, [styles].concat(interpolations)));
  }

  // $FlowFixMe
  return flatten(interleave(styles, interpolations));
}

// 

function constructWithOptions(componentConstructor, tag) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;

  if (!Object(react_is__WEBPACK_IMPORTED_MODULE_4__["isValidElementType"])(tag)) {
    throw new StyledComponentsError(1, String(tag));
  }

  /* This is callable directly as a template function */
  // $FlowFixMe: Not typed to avoid destructuring arguments
  var templateFunction = function templateFunction() {
    return componentConstructor(tag, options, css.apply(undefined, arguments));
  };

  /* If config methods are called, wrap up a new template function and merge options */
  templateFunction.withConfig = function (config) {
    return constructWithOptions(componentConstructor, tag, _extends({}, options, config));
  };

  /* Modify/inject new props at runtime */
  templateFunction.attrs = function (attrs) {
    return constructWithOptions(componentConstructor, tag, _extends({}, options, {
      attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)
    }));
  };

  return templateFunction;
}

// 
// Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
function murmurhash(c) {
  for (var e = c.length | 0, a = e | 0, d = 0, b; e >= 4;) {
    b = c.charCodeAt(d) & 255 | (c.charCodeAt(++d) & 255) << 8 | (c.charCodeAt(++d) & 255) << 16 | (c.charCodeAt(++d) & 255) << 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, e -= 4, ++d;
  }
  switch (e) {
    case 3:
      a ^= (c.charCodeAt(d + 2) & 255) << 16;
    case 2:
      a ^= (c.charCodeAt(d + 1) & 255) << 8;
    case 1:
      a ^= c.charCodeAt(d) & 255, a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);
  }
  a ^= a >>> 13;
  a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);
  return (a ^ a >>> 15) >>> 0;
}

// 
/* eslint-disable no-bitwise */

/* This is the "capacity" of our alphabet i.e. 2x26 for all letters plus their capitalised
 * counterparts */
var charsLength = 52;

/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */
var getAlphabeticChar = function getAlphabeticChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
};

/* input a number, usually a hash and convert it to base-52 */
function generateAlphabeticName(code) {
  var name = '';
  var x = void 0;

  /* get a char and divide by alphabet-length */
  for (x = code; x > charsLength; x = Math.floor(x / charsLength)) {
    name = getAlphabeticChar(x % charsLength) + name;
  }

  return getAlphabeticChar(x % charsLength) + name;
}

// 

function hasFunctionObjectKey(obj) {
  // eslint-disable-next-line guard-for-in, no-restricted-syntax
  for (var key in obj) {
    if (isFunction(obj[key])) {
      return true;
    }
  }

  return false;
}

function isStaticRules(rules, attrs) {
  for (var i = 0; i < rules.length; i += 1) {
    var rule = rules[i];

    // recursive case
    if (Array.isArray(rule) && !isStaticRules(rule, attrs)) {
      return false;
    } else if (isFunction(rule) && !isStyledComponent(rule)) {
      // functions are allowed to be static if they're just being
      // used to get the classname of a nested styled component
      return false;
    }
  }

  if (attrs.some(function (x) {
    return isFunction(x) || hasFunctionObjectKey(x);
  })) return false;

  return true;
}

// 

/* combines hashStr (murmurhash) and nameGenerator for convenience */
var hasher = function hasher(str) {
  return generateAlphabeticName(murmurhash(str));
};

/*
 ComponentStyle is all the CSS-specific stuff, not
 the React-specific stuff.
 */

var ComponentStyle = function () {
  function ComponentStyle(rules, attrs, componentId) {
    classCallCheck(this, ComponentStyle);

    this.rules = rules;
    this.isStatic =  true && isStaticRules(rules, attrs);
    this.componentId = componentId;

    if (!StyleSheet.master.hasId(componentId)) {
      StyleSheet.master.deferredInject(componentId, []);
    }
  }

  /*
   * Flattens a rule set into valid CSS
   * Hashes it, wraps the whole chunk in a .hash1234 {}
   * Returns the hash to be injected on render()
   * */


  ComponentStyle.prototype.generateAndInjectStyles = function generateAndInjectStyles(executionContext, styleSheet) {
    var isStatic = this.isStatic,
        componentId = this.componentId,
        lastClassName = this.lastClassName;

    if (IS_BROWSER && isStatic && typeof lastClassName === 'string' && styleSheet.hasNameForId(componentId, lastClassName)) {
      return lastClassName;
    }

    var flatCSS = flatten(this.rules, executionContext, styleSheet);
    var name = hasher(this.componentId + flatCSS.join(''));
    if (!styleSheet.hasNameForId(componentId, name)) {
      styleSheet.inject(this.componentId, stringifyRules(flatCSS, '.' + name, undefined, componentId), name);
    }

    this.lastClassName = name;
    return name;
  };

  ComponentStyle.generateName = function generateName(str) {
    return hasher(str);
  };

  return ComponentStyle;
}();

// 

var LIMIT = 200;

var createWarnTooManyClasses = (function (displayName) {
  var generatedClasses = {};
  var warningSeen = false;

  return function (className) {
    if (!warningSeen) {
      generatedClasses[className] = true;
      if (Object.keys(generatedClasses).length >= LIMIT) {
        // Unable to find latestRule in test environment.
        /* eslint-disable no-console, prefer-template */
        console.warn('Over ' + LIMIT + ' classes were generated for component ' + displayName + '. \n' + 'Consider using the attrs method, together with a style object for frequently changed styles.\n' + 'Example:\n' + '  const Component = styled.div.attrs(props => ({\n' + '    style: {\n' + '      background: props.background,\n' + '    },\n' + '  }))`width: 100%;`\n\n' + '  <Component />');
        warningSeen = true;
        generatedClasses = {};
      }
    }
  };
});

// 

var determineTheme = (function (props, fallbackTheme) {
  var defaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;

  // Props should take precedence over ThemeProvider, which should take precedence over
  // defaultProps, but React automatically puts defaultProps on props.

  /* eslint-disable react/prop-types, flowtype-errors/show-errors */
  var isDefaultTheme = defaultProps ? props.theme === defaultProps.theme : false;
  var theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;
  /* eslint-enable */

  return theme;
});

// 
var escapeRegex = /[[\].#*$><+~=|^:(),"'`-]+/g;
var dashesAtEnds = /(^-|-$)/g;

/**
 * TODO: Explore using CSS.escape when it becomes more available
 * in evergreen browsers.
 */
function escape(str) {
  return str
  // Replace all possible CSS selectors
  .replace(escapeRegex, '-')

  // Remove extraneous hyphens at the start and end
  .replace(dashesAtEnds, '');
}

// 

function isTag(target) {
  return typeof target === 'string' && ( false ? undefined : true);
}

// 

function generateDisplayName(target) {
  // $FlowFixMe
  return isTag(target) ? 'styled.' + target : 'Styled(' + getComponentName(target) + ')';
}

var _TYPE_STATICS;

var REACT_STATICS = {
  childContextTypes: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDerivedStateFromProps: true,
  propTypes: true,
  type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[react_is__WEBPACK_IMPORTED_MODULE_4__["ForwardRef"]] = {
  $$typeof: true,
  render: true
}, _TYPE_STATICS);

var defineProperty$1 = Object.defineProperty,
    getOwnPropertyNames = Object.getOwnPropertyNames,
    _Object$getOwnPropert = Object.getOwnPropertySymbols,
    getOwnPropertySymbols = _Object$getOwnPropert === undefined ? function () {
  return [];
} : _Object$getOwnPropert,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
    getPrototypeOf = Object.getPrototypeOf,
    objectPrototype = Object.prototype;
var arrayPrototype = Array.prototype;


function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components

    var inheritedComponent = getPrototypeOf(sourceComponent);

    if (inheritedComponent && inheritedComponent !== objectPrototype) {
      hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
    }

    var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent),
    // $FlowFixMe
    getOwnPropertySymbols(sourceComponent));

    var targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS;

    var sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS;

    var i = keys.length;
    var descriptor = void 0;
    var key = void 0;

    // eslint-disable-next-line no-plusplus
    while (i--) {
      key = keys[i];

      if (
      // $FlowFixMe
      !KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) &&
      // $FlowFixMe
      !(targetStatics && targetStatics[key])) {
        descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        if (descriptor) {
          try {
            // Avoid failures from read-only properties
            defineProperty$1(targetComponent, key, descriptor);
          } catch (e) {
            /* fail silently */
          }
        }
      }
    }

    return targetComponent;
  }

  return targetComponent;
}

// 
function isDerivedReactComponent(fn) {
  return !!(fn && fn.prototype && fn.prototype.isReactComponent);
}

// 
// Helper to call a given function, only once
var once = (function (cb) {
  var called = false;

  return function () {
    if (!called) {
      called = true;
      cb.apply(undefined, arguments);
    }
  };
});

// 

var ThemeContext = Object(react__WEBPACK_IMPORTED_MODULE_2__["createContext"])();

var ThemeConsumer = ThemeContext.Consumer;

/**
 * Provide a theme to an entire react component tree via context
 */

var ThemeProvider = function (_Component) {
  inherits(ThemeProvider, _Component);

  function ThemeProvider(props) {
    classCallCheck(this, ThemeProvider);

    var _this = possibleConstructorReturn(this, _Component.call(this, props));

    _this.getContext = Object(memoize_one__WEBPACK_IMPORTED_MODULE_5__["default"])(_this.getContext.bind(_this));
    _this.renderInner = _this.renderInner.bind(_this);
    return _this;
  }

  ThemeProvider.prototype.render = function render() {
    if (!this.props.children) return null;

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      ThemeContext.Consumer,
      null,
      this.renderInner
    );
  };

  ThemeProvider.prototype.renderInner = function renderInner(outerTheme) {
    var context = this.getContext(this.props.theme, outerTheme);

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      ThemeContext.Provider,
      { value: context },
      this.props.children
    );
  };

  /**
   * Get the theme from the props, supporting both (outerTheme) => {}
   * as well as object notation
   */


  ThemeProvider.prototype.getTheme = function getTheme(theme, outerTheme) {
    if (isFunction(theme)) {
      var mergedTheme = theme(outerTheme);

      if (false) {}

      return mergedTheme;
    }

    if (theme === null || Array.isArray(theme) || (typeof theme === 'undefined' ? 'undefined' : _typeof(theme)) !== 'object') {
      throw new StyledComponentsError(8);
    }

    return _extends({}, outerTheme, theme);
  };

  ThemeProvider.prototype.getContext = function getContext(theme, outerTheme) {
    return this.getTheme(theme, outerTheme);
  };

  return ThemeProvider;
}(react__WEBPACK_IMPORTED_MODULE_2__["Component"]);

// 

var CLOSING_TAG_R = /^\s*<\/[a-z]/i;

var ServerStyleSheet = function () {
  function ServerStyleSheet() {
    classCallCheck(this, ServerStyleSheet);

    /* The master sheet might be reset, so keep a reference here */
    this.masterSheet = StyleSheet.master;
    this.instance = this.masterSheet.clone();
    this.sealed = false;
  }

  /**
   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the
   * StyleSheet singleton.
   */


  ServerStyleSheet.prototype.seal = function seal() {
    if (!this.sealed) {
      /* Remove sealed StyleSheets from the master sheet */
      var index = this.masterSheet.clones.indexOf(this.instance);
      this.masterSheet.clones.splice(index, 1);
      this.sealed = true;
    }
  };

  ServerStyleSheet.prototype.collectStyles = function collectStyles(children) {
    if (this.sealed) {
      throw new StyledComponentsError(2);
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      StyleSheetManager,
      { sheet: this.instance },
      children
    );
  };

  ServerStyleSheet.prototype.getStyleTags = function getStyleTags() {
    this.seal();
    return this.instance.toHTML();
  };

  ServerStyleSheet.prototype.getStyleElement = function getStyleElement() {
    this.seal();
    return this.instance.toReactElements();
  };

  ServerStyleSheet.prototype.interleaveWithNodeStream = function interleaveWithNodeStream(readableStream) {
    var _this = this;

    {
      throw new StyledComponentsError(3);
    }

    /* the tag index keeps track of which tags have already been emitted */
    var instance = this.instance;

    var instanceTagIndex = 0;

    var streamAttr = SC_STREAM_ATTR + '="true"';

    var transformer = new stream.Transform({
      transform: function appendStyleChunks(chunk, /* encoding */_, callback) {
        var tags = instance.tags;

        var html = '';

        /* retrieve html for each new style tag */
        for (; instanceTagIndex < tags.length; instanceTagIndex += 1) {
          var tag = tags[instanceTagIndex];
          html += tag.toHTML(streamAttr);
        }

        /* force our StyleSheets to emit entirely new tags */
        instance.sealAllTags();

        var renderedHtml = chunk.toString();

        /* prepend style html to chunk, unless the start of the chunk is a closing tag in which case append right after that */
        if (CLOSING_TAG_R.test(renderedHtml)) {
          var endOfClosingTag = renderedHtml.indexOf('>');

          this.push(renderedHtml.slice(0, endOfClosingTag + 1) + html + renderedHtml.slice(endOfClosingTag + 1));
        } else this.push(html + renderedHtml);

        callback();
      }
    });

    readableStream.on('end', function () {
      return _this.seal();
    });

    readableStream.on('error', function (err) {
      _this.seal();

      // forward the error to the transform stream
      transformer.emit('error', err);
    });

    return readableStream.pipe(transformer);
  };

  return ServerStyleSheet;
}();

// 

var StyleSheetContext = Object(react__WEBPACK_IMPORTED_MODULE_2__["createContext"])();
var StyleSheetConsumer = StyleSheetContext.Consumer;

var StyleSheetManager = function (_Component) {
  inherits(StyleSheetManager, _Component);

  function StyleSheetManager(props) {
    classCallCheck(this, StyleSheetManager);

    var _this = possibleConstructorReturn(this, _Component.call(this, props));

    _this.getContext = Object(memoize_one__WEBPACK_IMPORTED_MODULE_5__["default"])(_this.getContext);
    return _this;
  }

  StyleSheetManager.prototype.getContext = function getContext(sheet, target) {
    if (sheet) {
      return sheet;
    } else if (target) {
      return new StyleSheet(target);
    } else {
      throw new StyledComponentsError(4);
    }
  };

  StyleSheetManager.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        sheet = _props.sheet,
        target = _props.target;


    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      StyleSheetContext.Provider,
      { value: this.getContext(sheet, target) },
       false ? undefined : children
    );
  };

  return StyleSheetManager;
}(react__WEBPACK_IMPORTED_MODULE_2__["Component"]);
 false ? undefined : void 0;

// 

var identifiers = {};

/* We depend on components having unique IDs */
function generateId(_ComponentStyle, _displayName, parentComponentId) {
  var displayName = typeof _displayName !== 'string' ? 'sc' : escape(_displayName);

  /**
   * This ensures uniqueness if two components happen to share
   * the same displayName.
   */
  var nr = (identifiers[displayName] || 0) + 1;
  identifiers[displayName] = nr;

  var componentId = displayName + '-' + _ComponentStyle.generateName(displayName + nr);

  return parentComponentId ? parentComponentId + '-' + componentId : componentId;
}

// $FlowFixMe

var StyledComponent = function (_Component) {
  inherits(StyledComponent, _Component);

  function StyledComponent() {
    classCallCheck(this, StyledComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this));

    _this.attrs = {};

    _this.renderOuter = _this.renderOuter.bind(_this);
    _this.renderInner = _this.renderInner.bind(_this);

    if (false) {}
    return _this;
  }

  StyledComponent.prototype.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      StyleSheetConsumer,
      null,
      this.renderOuter
    );
  };

  StyledComponent.prototype.renderOuter = function renderOuter() {
    var styleSheet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StyleSheet.master;

    this.styleSheet = styleSheet;

    // No need to subscribe a static component to theme changes, it won't change anything
    if (this.props.forwardedComponent.componentStyle.isStatic) return this.renderInner();

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      ThemeConsumer,
      null,
      this.renderInner
    );
  };

  StyledComponent.prototype.renderInner = function renderInner(theme) {
    var _props$forwardedCompo = this.props.forwardedComponent,
        componentStyle = _props$forwardedCompo.componentStyle,
        defaultProps = _props$forwardedCompo.defaultProps,
        displayName = _props$forwardedCompo.displayName,
        foldedComponentIds = _props$forwardedCompo.foldedComponentIds,
        styledComponentId = _props$forwardedCompo.styledComponentId,
        target = _props$forwardedCompo.target;


    var generatedClassName = void 0;
    if (componentStyle.isStatic) {
      generatedClassName = this.generateAndInjectStyles(EMPTY_OBJECT, this.props);
    } else {
      generatedClassName = this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps) || EMPTY_OBJECT, this.props);
    }

    var elementToBeCreated = this.props.as || this.attrs.as || target;
    var isTargetTag = isTag(elementToBeCreated);

    var propsForElement = {};
    var computedProps = _extends({}, this.props, this.attrs);

    var key = void 0;
    // eslint-disable-next-line guard-for-in
    for (key in computedProps) {
      if (false) {}

      if (key === 'forwardedComponent' || key === 'as') {
        continue;
      } else if (key === 'forwardedRef') propsForElement.ref = computedProps[key];else if (key === 'forwardedAs') propsForElement.as = computedProps[key];else if (!isTargetTag || Object(_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(key)) {
        // Don't pass through non HTML tags through to HTML elements
        propsForElement[key] = computedProps[key];
      }
    }

    if (this.props.style && this.attrs.style) {
      propsForElement.style = _extends({}, this.attrs.style, this.props.style);
    }

    propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(' ');

    return Object(react__WEBPACK_IMPORTED_MODULE_2__["createElement"])(elementToBeCreated, propsForElement);
  };

  StyledComponent.prototype.buildExecutionContext = function buildExecutionContext(theme, props, attrs) {
    var _this2 = this;

    var context = _extends({}, props, { theme: theme });

    if (!attrs.length) return context;

    this.attrs = {};

    attrs.forEach(function (attrDef) {
      var resolvedAttrDef = attrDef;
      var attrDefWasFn = false;
      var attr = void 0;
      var key = void 0;

      if (isFunction(resolvedAttrDef)) {
        // $FlowFixMe
        resolvedAttrDef = resolvedAttrDef(context);
        attrDefWasFn = true;
      }

      /* eslint-disable guard-for-in */
      // $FlowFixMe
      for (key in resolvedAttrDef) {
        attr = resolvedAttrDef[key];

        if (!attrDefWasFn) {
          if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {
            if (false) {}

            attr = attr(context);

            if (false) {}
          }
        }

        _this2.attrs[key] = attr;
        context[key] = attr;
      }
      /* eslint-enable */
    });

    return context;
  };

  StyledComponent.prototype.generateAndInjectStyles = function generateAndInjectStyles(theme, props) {
    var _props$forwardedCompo2 = props.forwardedComponent,
        attrs = _props$forwardedCompo2.attrs,
        componentStyle = _props$forwardedCompo2.componentStyle,
        warnTooManyClasses = _props$forwardedCompo2.warnTooManyClasses;

    // statically styled-components don't need to build an execution context object,
    // and shouldn't be increasing the number of class names

    if (componentStyle.isStatic && !attrs.length) {
      return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);
    }

    var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);

    if (false) {}

    return className;
  };

  return StyledComponent;
}(react__WEBPACK_IMPORTED_MODULE_2__["Component"]);

function createStyledComponent(target, options, rules) {
  var isTargetStyledComp = isStyledComponent(target);
  var isClass = !isTag(target);

  var _options$displayName = options.displayName,
      displayName = _options$displayName === undefined ? generateDisplayName(target) : _options$displayName,
      _options$componentId = options.componentId,
      componentId = _options$componentId === undefined ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId,
      _options$ParentCompon = options.ParentComponent,
      ParentComponent = _options$ParentCompon === undefined ? StyledComponent : _options$ParentCompon,
      _options$attrs = options.attrs,
      attrs = _options$attrs === undefined ? EMPTY_ARRAY : _options$attrs;


  var styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + '-' + options.componentId : options.componentId || componentId;

  // fold the underlying StyledComponent attrs up (implicit extend)
  var finalAttrs =
  // $FlowFixMe
  isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs;

  var componentStyle = new ComponentStyle(isTargetStyledComp ? // fold the underlying StyledComponent rules up (implicit extend)
  // $FlowFixMe
  target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId);

  /**
   * forwardRef creates a new interim component, which we'll take advantage of
   * instead of extending ParentComponent to create _another_ interim class
   */
  var WrappedStyledComponent = void 0;
  var forwardRef = function forwardRef(props, ref) {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(ParentComponent, _extends({}, props, { forwardedComponent: WrappedStyledComponent, forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  WrappedStyledComponent = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(forwardRef);
  WrappedStyledComponent.displayName = displayName;

  // $FlowFixMe
  WrappedStyledComponent.attrs = finalAttrs;
  // $FlowFixMe
  WrappedStyledComponent.componentStyle = componentStyle;

  // $FlowFixMe
  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? // $FlowFixMe
  Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY;

  // $FlowFixMe
  WrappedStyledComponent.styledComponentId = styledComponentId;

  // fold the underlying StyledComponent target up since we folded the styles
  // $FlowFixMe
  WrappedStyledComponent.target = isTargetStyledComp ? target.target : target;

  // $FlowFixMe
  WrappedStyledComponent.withComponent = function withComponent(tag) {
    var previousComponentId = options.componentId,
        optionsToCopy = objectWithoutProperties(options, ['componentId']);


    var newComponentId = previousComponentId && previousComponentId + '-' + (isTag(tag) ? tag : escape(getComponentName(tag)));

    var newOptions = _extends({}, optionsToCopy, {
      attrs: finalAttrs,
      componentId: newComponentId,
      ParentComponent: ParentComponent
    });

    return createStyledComponent(tag, newOptions, rules);
  };

  // $FlowFixMe
  Object.defineProperty(WrappedStyledComponent, 'defaultProps', {
    get: function get$$1() {
      return this._foldedDefaultProps;
    },
    set: function set$$1(obj) {
      // $FlowFixMe
      this._foldedDefaultProps = isTargetStyledComp ? Object(merge_anything__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(target.defaultProps, obj) : obj;
    }
  });

  if (false) {}

  // $FlowFixMe
  WrappedStyledComponent.toString = function () {
    return '.' + WrappedStyledComponent.styledComponentId;
  };

  if (isClass) {
    hoistNonReactStatics(WrappedStyledComponent, target, {
      // all SC-specific things should not be hoisted
      attrs: true,
      componentStyle: true,
      displayName: true,
      foldedComponentIds: true,
      styledComponentId: true,
      target: true,
      withComponent: true
    });
  }

  return WrappedStyledComponent;
}

// 
// Thanks to ReactDOMFactories for this handy list!

var domElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr',

// SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'marker', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

// 

var styled = function styled(tag) {
  return constructWithOptions(createStyledComponent, tag);
};

// Shorthands for all valid HTML Elements
domElements.forEach(function (domElement) {
  styled[domElement] = styled(domElement);
});

// 

var GlobalStyle = function () {
  function GlobalStyle(rules, componentId) {
    classCallCheck(this, GlobalStyle);

    this.rules = rules;
    this.componentId = componentId;
    this.isStatic = isStaticRules(rules, EMPTY_ARRAY);

    if (!StyleSheet.master.hasId(componentId)) {
      StyleSheet.master.deferredInject(componentId, []);
    }
  }

  GlobalStyle.prototype.createStyles = function createStyles(executionContext, styleSheet) {
    var flatCSS = flatten(this.rules, executionContext, styleSheet);
    var css = stringifyRules(flatCSS, '');

    styleSheet.inject(this.componentId, css);
  };

  GlobalStyle.prototype.removeStyles = function removeStyles(styleSheet) {
    var componentId = this.componentId;

    if (styleSheet.hasId(componentId)) {
      styleSheet.remove(componentId);
    }
  };

  // TODO: overwrite in-place instead of remove+create?


  GlobalStyle.prototype.renderStyles = function renderStyles(executionContext, styleSheet) {
    this.removeStyles(styleSheet);
    this.createStyles(executionContext, styleSheet);
  };

  return GlobalStyle;
}();

// 

// place our cache into shared context so it'll persist between HMRs
if (IS_BROWSER) {
  window.scCGSHMRCache = {};
}

function createGlobalStyle(strings) {
  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    interpolations[_key - 1] = arguments[_key];
  }

  var rules = css.apply(undefined, [strings].concat(interpolations));
  var id = 'sc-global-' + murmurhash(JSON.stringify(rules));
  var style = new GlobalStyle(rules, id);

  var GlobalStyleComponent = function (_React$Component) {
    inherits(GlobalStyleComponent, _React$Component);

    function GlobalStyleComponent(props) {
      classCallCheck(this, GlobalStyleComponent);

      var _this = possibleConstructorReturn(this, _React$Component.call(this, props));

      var _this$constructor = _this.constructor,
          globalStyle = _this$constructor.globalStyle,
          styledComponentId = _this$constructor.styledComponentId;


      if (IS_BROWSER) {
        window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1;
      }

      /**
       * This fixes HMR compatibility. Don't ask me why, but this combination of
       * caching the closure variables via statics and then persisting the statics in
       * state works across HMR where no other combination did. ¯\_(ツ)_/¯
       */
      _this.state = {
        globalStyle: globalStyle,
        styledComponentId: styledComponentId
      };
      return _this;
    }

    GlobalStyleComponent.prototype.componentWillUnmount = function componentWillUnmount() {
      if (window.scCGSHMRCache[this.state.styledComponentId]) {
        window.scCGSHMRCache[this.state.styledComponentId] -= 1;
      }
      /**
       * Depending on the order "render" is called this can cause the styles to be lost
       * until the next render pass of the remaining instance, which may
       * not be immediate.
       */
      if (window.scCGSHMRCache[this.state.styledComponentId] === 0) {
        this.state.globalStyle.removeStyles(this.styleSheet);
      }
    };

    GlobalStyleComponent.prototype.render = function render() {
      var _this2 = this;

      if (false) {}

      return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
        StyleSheetConsumer,
        null,
        function (styleSheet) {
          _this2.styleSheet = styleSheet || StyleSheet.master;

          var globalStyle = _this2.state.globalStyle;


          if (globalStyle.isStatic) {
            globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet);

            return null;
          } else {
            return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
              ThemeConsumer,
              null,
              function (theme) {
                // $FlowFixMe
                var defaultProps = _this2.constructor.defaultProps;


                var context = _extends({}, _this2.props);

                if (typeof theme !== 'undefined') {
                  context.theme = determineTheme(_this2.props, theme, defaultProps);
                }

                globalStyle.renderStyles(context, _this2.styleSheet);

                return null;
              }
            );
          }
        }
      );
    };

    return GlobalStyleComponent;
  }(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

  GlobalStyleComponent.globalStyle = style;
  GlobalStyleComponent.styledComponentId = id;


  return GlobalStyleComponent;
}

// 

var replaceWhitespace = function replaceWhitespace(str) {
  return str.replace(/\s|\\n/g, '');
};

function keyframes(strings) {
  /* Warning if you've used keyframes on React Native */
  if (false) {}

  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    interpolations[_key - 1] = arguments[_key];
  }

  var rules = css.apply(undefined, [strings].concat(interpolations));

  var name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));

  return new Keyframes(name, stringifyRules(rules, name, '@keyframes'));
}

// 

var withTheme = (function (Component$$1) {
  var WithTheme = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(function (props, ref) {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
      ThemeConsumer,
      null,
      function (theme) {
        // $FlowFixMe
        var defaultProps = Component$$1.defaultProps;

        var themeProp = determineTheme(props, theme, defaultProps);

        if (false) {}

        return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component$$1, _extends({}, props, { theme: themeProp, ref: ref }));
      }
    );
  });

  hoistNonReactStatics(WithTheme, Component$$1);

  WithTheme.displayName = 'WithTheme(' + getComponentName(Component$$1) + ')';

  return WithTheme;
});

// 

/* eslint-disable */
var __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {
  StyleSheet: StyleSheet
};

// 

/* Warning if you've imported this file on React Native */
if (false) {}

/* Warning if there are several instances of styled-components */
if (false) {}

//

/* harmony default export */ __webpack_exports__["default"] = (styled);


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(157)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arcBuilder = exports.pathBuilder = exports.lineBuilder = undefined;

var _d3Shape = __webpack_require__(224);

var lineBuilder = exports.lineBuilder = function lineBuilder(_ref) {
  var data = _ref.data,
      _ref$curve = _ref.curve,
      curve = _ref$curve === undefined ? _d3Shape.curveLinear : _ref$curve,
      canvasContext = _ref.canvasContext,
      className = _ref.className,
      classID = _ref.classID;

  var lineGen = (0, _d3Shape.line)().curve(curve);

  var builder = {
    type: "path",
    className: className,
    classID: classID,
    data: data
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
    builder.pathMethods = lineGen;
  } else {
    builder.attrs = {
      d: lineGen(data)
    };
  }

  return builder;
};

var pathBuilder = exports.pathBuilder = function pathBuilder(_ref2) {
  var d = _ref2.d,
      _ref2$curve = _ref2.curve,
      curve = _ref2$curve === undefined ? _d3Shape.curveLinear : _ref2$curve,
      canvasContext = _ref2.canvasContext,
      className = _ref2.className,
      classID = _ref2.classID;

  var lineGen = (0, _d3Shape.line)().curve(curve);

  var builder = {
    type: "path",
    className: className,
    classID: classID
  };

  if (canvasContext) {
    lineGen.context(canvasContext);
  } else {
    builder.attrs = {
      d: d
    };
  }

  return builder;
};

var arcBuilder = exports.arcBuilder = function arcBuilder(_ref3) {
  var data = _ref3.data,
      canvasContext = _ref3.canvasContext,
      className = _ref3.className,
      classID = _ref3.classID;

  var builder = {
    type: "path",
    className: className,
    classID: classID,
    data: data
  };

  var arcShape = (0, _d3Shape.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

  if (canvasContext) {
    arcShape.context(canvasContext);
  } else {
    builder.attrs = {
      d: arcShape()
    };
  }

  return builder;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(185);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bisect", function() { return /* reexport */ bisect["c" /* default */]; });
__webpack_require__.d(__webpack_exports__, "bisectRight", function() { return /* reexport */ bisect["b" /* bisectRight */]; });
__webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return /* reexport */ bisect["a" /* bisectLeft */]; });
__webpack_require__.d(__webpack_exports__, "ascending", function() { return /* reexport */ ascending["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "bisector", function() { return /* reexport */ bisector["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "count", function() { return /* reexport */ count; });
__webpack_require__.d(__webpack_exports__, "cross", function() { return /* reexport */ cross; });
__webpack_require__.d(__webpack_exports__, "cumsum", function() { return /* reexport */ cumsum; });
__webpack_require__.d(__webpack_exports__, "descending", function() { return /* reexport */ descending; });
__webpack_require__.d(__webpack_exports__, "deviation", function() { return /* reexport */ deviation; });
__webpack_require__.d(__webpack_exports__, "extent", function() { return /* reexport */ extent; });
__webpack_require__.d(__webpack_exports__, "fsum", function() { return /* reexport */ fsum; });
__webpack_require__.d(__webpack_exports__, "Adder", function() { return /* reexport */ Adder; });
__webpack_require__.d(__webpack_exports__, "group", function() { return /* reexport */ group; });
__webpack_require__.d(__webpack_exports__, "groups", function() { return /* reexport */ groups; });
__webpack_require__.d(__webpack_exports__, "rollup", function() { return /* reexport */ rollup; });
__webpack_require__.d(__webpack_exports__, "rollups", function() { return /* reexport */ rollups; });
__webpack_require__.d(__webpack_exports__, "bin", function() { return /* reexport */ src_bin; });
__webpack_require__.d(__webpack_exports__, "histogram", function() { return /* reexport */ src_bin; });
__webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return /* reexport */ freedmanDiaconis; });
__webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return /* reexport */ scott; });
__webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return /* reexport */ sturges; });
__webpack_require__.d(__webpack_exports__, "max", function() { return /* reexport */ src_max["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "maxIndex", function() { return /* reexport */ maxIndex; });
__webpack_require__.d(__webpack_exports__, "mean", function() { return /* reexport */ mean; });
__webpack_require__.d(__webpack_exports__, "median", function() { return /* reexport */ median; });
__webpack_require__.d(__webpack_exports__, "merge", function() { return /* reexport */ merge; });
__webpack_require__.d(__webpack_exports__, "min", function() { return /* reexport */ src_min["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "minIndex", function() { return /* reexport */ minIndex; });
__webpack_require__.d(__webpack_exports__, "pairs", function() { return /* reexport */ pairs; });
__webpack_require__.d(__webpack_exports__, "permute", function() { return /* reexport */ permute; });
__webpack_require__.d(__webpack_exports__, "quantile", function() { return /* reexport */ quantile["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "quantileSorted", function() { return /* reexport */ quantile["b" /* quantileSorted */]; });
__webpack_require__.d(__webpack_exports__, "quickselect", function() { return /* reexport */ quickselect["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ range["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "least", function() { return /* reexport */ least; });
__webpack_require__.d(__webpack_exports__, "leastIndex", function() { return /* reexport */ leastIndex; });
__webpack_require__.d(__webpack_exports__, "greatest", function() { return /* reexport */ greatest; });
__webpack_require__.d(__webpack_exports__, "greatestIndex", function() { return /* reexport */ greatestIndex; });
__webpack_require__.d(__webpack_exports__, "scan", function() { return /* reexport */ scan; });
__webpack_require__.d(__webpack_exports__, "shuffle", function() { return /* reexport */ shuffle; });
__webpack_require__.d(__webpack_exports__, "sum", function() { return /* reexport */ sum; });
__webpack_require__.d(__webpack_exports__, "ticks", function() { return /* reexport */ ticks["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return /* reexport */ ticks["b" /* tickIncrement */]; });
__webpack_require__.d(__webpack_exports__, "tickStep", function() { return /* reexport */ ticks["c" /* tickStep */]; });
__webpack_require__.d(__webpack_exports__, "transpose", function() { return /* reexport */ src_transpose; });
__webpack_require__.d(__webpack_exports__, "variance", function() { return /* reexport */ variance; });
__webpack_require__.d(__webpack_exports__, "zip", function() { return /* reexport */ zip; });

// EXTERNAL MODULE: ./node_modules/d3-array/src/bisect.js
var bisect = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/d3-array/src/ascending.js
var ascending = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/d3-array/src/bisector.js
var bisector = __webpack_require__(109);

// CONCATENATED MODULE: ./node_modules/d3-array/src/count.js
function count(values, valueof) {
  let count = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }
  return count;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/cross.js
function cross_length(array) {
  return array.length | 0;
}

function empty(length) {
  return !(length > 0);
}

function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}

function reducer(reduce) {
  return values => reduce(...values);
}

function cross(...values) {
  const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(cross_length);
  const j = values.length - 1;
  const index = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index.map((j, i) => values[i][j]));
    let i = j;
    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/cumsum.js
function cumsum(values, valueof) {
  var sum = 0, index = 0;
  return Float64Array.from(values, valueof === undefined
    ? v => (sum += +v || 0)
    : v => (sum += +valueof(v, index++, values) || 0));
}
// CONCATENATED MODULE: ./node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/variance.js
function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/deviation.js


function deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/fsum.js
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32).fill(0);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

/* harmony default export */ var fsum = (function(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/group.js


function group(values, ...keys) {
  return nest(values, identity, identity, keys);
}

function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}

function rollup(values, reduce, ...keys) {
  return nest(values, identity, reduce, keys);
}

function rollups(values, reduce, ...keys) {
  return nest(values, Array.from, reduce, keys);
}

function nest(values, map, reduce, keys) {
  return (function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new Map();
    const keyof = keys[i++];
    let index = -1;
    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);
      else groups.set(key, [value]);
    }
    for (const [key, values] of groups) {
      groups.set(key, regroup(values, i));
    }
    return map(groups);
  })(values, 0);
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/array.js
var array = Array.prototype;

var slice = array.slice;
var map = array.map;

// CONCATENATED MODULE: ./node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// EXTERNAL MODULE: ./node_modules/d3-array/src/range.js
var range = __webpack_require__(108);

// EXTERNAL MODULE: ./node_modules/d3-array/src/ticks.js
var ticks = __webpack_require__(55);

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/sturges.js


/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/bin.js









/* harmony default export */ var src_bin = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);

    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(ticks["c" /* tickStep */])(x0, x1, tz);
      tz = Object(range["a" /* default */])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(bisect["c" /* default */])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// EXTERNAL MODULE: ./node_modules/d3-array/src/quantile.js + 1 modules
var quantile = __webpack_require__(37);

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/freedmanDiaconis.js



/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  return Math.ceil((max - min) / (2 * (Object(quantile["a" /* default */])(values, 0.75) - Object(quantile["a" /* default */])(values, 0.25)) * Math.pow(count(values), -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/threshold/scott.js



/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
});

// EXTERNAL MODULE: ./node_modules/d3-array/src/max.js
var src_max = __webpack_require__(79);

// CONCATENATED MODULE: ./node_modules/d3-array/src/maxIndex.js
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/median.js


/* harmony default export */ var median = (function(values, valueof) {
  return Object(quantile["a" /* default */])(values, 0.5, valueof);
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}

// EXTERNAL MODULE: ./node_modules/d3-array/src/min.js
var src_min = __webpack_require__(47);

// CONCATENATED MODULE: ./node_modules/d3-array/src/minIndex.js
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/pairs.js
function pairs(values, pairof = pair) {
  const pairs = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(source, keys) {
  return Array.from(keys, key => source[key]);
});

// EXTERNAL MODULE: ./node_modules/d3-array/src/quickselect.js
var quickselect = __webpack_require__(110);

// CONCATENATED MODULE: ./node_modules/d3-array/src/least.js


function least(values, compare = ascending["a" /* default */]) {
  let min;
  let defined = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? Object(ascending["a" /* default */])(value, minValue) < 0
          : Object(ascending["a" /* default */])(value, value) === 0) {
        min = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, min) < 0
          : compare(value, value) === 0) {
        min = value;
        defined = true;
      }
    }
  }
  return min;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/leastIndex.js



function leastIndex(values, compare = ascending["a" /* default */]) {
  if (compare.length === 1) return minIndex(values, compare);
  let minValue;
  let min = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (min < 0
        ? compare(value, value) === 0
        : compare(value, minValue) < 0) {
      minValue = value;
      min = index;
    }
  }
  return min;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/greatest.js


function greatest(values, compare = ascending["a" /* default */]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? Object(ascending["a" /* default */])(value, maxValue) > 0
          : Object(ascending["a" /* default */])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/greatestIndex.js



function greatestIndex(values, compare = ascending["a" /* default */]) {
  if (compare.length === 1) return maxIndex(values, compare);
  let maxValue;
  let max = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (max < 0
        ? compare(value, value) === 0
        : compare(value, maxValue) > 0) {
      maxValue = value;
      max = index;
    }
  }
  return max;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/scan.js


function scan(values, compare) {
  const index = leastIndex(values, compare);
  return index < 0 ? undefined : index;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/shuffle.js
function shuffle(array, i0 = 0, i1 = array.length) {
  var m = i1 - (i0 = +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(src_min["a" /* default */])(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-array/src/index.js











 // Deprecated; use bin.



















 // Deprecated; use leastIndex.








/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "scaleBand", function() { return /* reexport */ band; });
__webpack_require__.d(__webpack_exports__, "scalePoint", function() { return /* reexport */ point; });
__webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return /* reexport */ identity; });
__webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return /* reexport */ linear; });
__webpack_require__.d(__webpack_exports__, "scaleLog", function() { return /* reexport */ log; });
__webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return /* reexport */ ordinal; });
__webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return /* reexport */ implicit; });
__webpack_require__.d(__webpack_exports__, "scalePow", function() { return /* reexport */ pow; });
__webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return /* reexport */ sqrt; });
__webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return /* reexport */ quantile; });
__webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return /* reexport */ quantize; });
__webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return /* reexport */ threshold; });
__webpack_require__.d(__webpack_exports__, "scaleTime", function() { return /* reexport */ time; });
__webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return /* reexport */ utcTime; });
__webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return /* reexport */ category10; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return /* reexport */ category20b; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20c", function() { return /* reexport */ category20c; });
__webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return /* reexport */ category20; });
__webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return /* reexport */ d3_scale_src_cubehelix; });
__webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return /* reexport */ src_rainbow; });
__webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return /* reexport */ warm; });
__webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return /* reexport */ cool; });
__webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return /* reexport */ viridis; });
__webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return /* reexport */ magma; });
__webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return /* reexport */ inferno; });
__webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return /* reexport */ plasma; });
__webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return /* reexport */ sequential; });

// EXTERNAL MODULE: ./node_modules/semiotic/node_modules/d3-array/src/index.js + 31 modules
var src = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/d3-collection/src/index.js + 6 modules
var d3_collection_src = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/array.js
var array = Array.prototype;

var map = array.map;
var slice = array.slice;

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/ordinal.js



var implicit = {name: "implicit"};

function ordinal(range) {
  var index = Object(d3_collection_src["map"])(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(d3_collection_src["map"])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/band.js



function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(src["range"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/value.js
var src_value = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/round.js
var src_round = __webpack_require__(167);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/number.js
/* harmony default export */ var src_number = (function(x) {
  return +x;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/continuous.js






var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(src["bisect"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = src_value["a" /* default */],
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, src_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice.call(_), interpolate = src_round["a" /* default */], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}

// EXTERNAL MODULE: ./node_modules/d3-format/src/formatSpecifier.js
var formatSpecifier = __webpack_require__(152);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionPrefix.js
var precisionPrefix = __webpack_require__(522);

// EXTERNAL MODULE: ./node_modules/d3-format/src/defaultLocale.js + 8 modules
var defaultLocale = __webpack_require__(539);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionRound.js
var precisionRound = __webpack_require__(523);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionFixed.js
var precisionFixed = __webpack_require__(524);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/tickFormat.js



/* harmony default export */ var src_tickFormat = (function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = Object(src["tickStep"])(start, stop, count == null ? 10 : count),
      precision;
  specifier = Object(formatSpecifier["a" /* default */])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;
      return Object(defaultLocale["b" /* formatPrefix */])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(defaultLocale["a" /* format */])(specifier);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/linear.js





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(src["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return src_tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(src["tickIncrement"])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(src["tickIncrement"])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(src["tickIncrement"])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, number["a" /* default */]);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/identity.js




function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map.call(_, src_number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/nice.js
/* harmony default export */ var nice = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/log.js






function log_deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function log_reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(log_deinterpolate, log_reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(src["ticks"])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(defaultLocale["a" /* format */])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/pow.js




function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/quantile.js



function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(src["quantile"])(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[Object(src["bisect"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(src["ascending"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/quantize.js




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[Object(src["bisect"])(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/threshold.js



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[Object(src["bisect"])(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}

// EXTERNAL MODULE: ./node_modules/d3-time/src/year.js
var src_year = __webpack_require__(525);

// EXTERNAL MODULE: ./node_modules/d3-time/src/month.js
var src_month = __webpack_require__(526);

// EXTERNAL MODULE: ./node_modules/d3-time/src/week.js
var src_week = __webpack_require__(527);

// EXTERNAL MODULE: ./node_modules/d3-time/src/day.js
var src_day = __webpack_require__(528);

// EXTERNAL MODULE: ./node_modules/d3-time/src/hour.js
var src_hour = __webpack_require__(529);

// EXTERNAL MODULE: ./node_modules/d3-time/src/minute.js
var src_minute = __webpack_require__(530);

// EXTERNAL MODULE: ./node_modules/d3-time/src/second.js
var src_second = __webpack_require__(531);

// EXTERNAL MODULE: ./node_modules/d3-time/src/millisecond.js
var src_millisecond = __webpack_require__(532);

// EXTERNAL MODULE: ./node_modules/d3-time-format/src/defaultLocale.js + 1 modules
var src_defaultLocale = __webpack_require__(540);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/time.js








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(deinterpolateLinear, number["a" /* default */]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(src["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(src["tickStep"])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(src["tickStep"])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map.call(_, time_number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ var time = (function() {
  return calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["b" /* sunday */], src_day["a" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcYear.js
var utcYear = __webpack_require__(535);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcMonth.js
var utcMonth = __webpack_require__(536);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcWeek.js
var utcWeek = __webpack_require__(533);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcDay.js
var utcDay = __webpack_require__(534);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcHour.js
var utcHour = __webpack_require__(537);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcMinute.js
var utcMinute = __webpack_require__(538);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/utcTime.js




/* harmony default export */ var utcTime = (function() {
  return calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["b" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/colors.js
/* harmony default export */ var colors = (function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/category10.js


/* harmony default export */ var category10 = (colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/category20b.js


/* harmony default export */ var category20b = (colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/category20c.js


/* harmony default export */ var category20c = (colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/category20.js


/* harmony default export */ var category20 = (colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));

// EXTERNAL MODULE: ./node_modules/d3-color/src/cubehelix.js
var cubehelix = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/cubehelix.js
var src_cubehelix = __webpack_require__(119);

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/cubehelix.js



/* harmony default export */ var d3_scale_src_cubehelix = (Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(300, 0.5, 0.0), Object(cubehelix["a" /* default */])(-240, 0.5, 1.0)));

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/rainbow.js



var warm = Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(-100, 0.75, 0.35), Object(cubehelix["a" /* default */])(80, 1.50, 0.8));

var cool = Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(260, 0.75, 0.35), Object(cubehelix["a" /* default */])(80, 1.50, 0.8));

var rainbow = Object(cubehelix["a" /* default */])();

/* harmony default export */ var src_rainbow = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
});

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/viridis.js


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ var viridis = (ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/src/sequential.js


function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/semiotic/node_modules/d3-scale/index.js







































/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.red = exports.getContrastingColor = exports.isValidHex = exports.toState = exports.simpleCheckForValidColor = undefined;

var _each = __webpack_require__(457);

var _each2 = _interopRequireDefault(_each);

var _tinycolor = __webpack_require__(459);

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var simpleCheckForValidColor = exports.simpleCheckForValidColor = function simpleCheckForValidColor(data) {
  var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
  var checked = 0;
  var passed = 0;
  (0, _each2.default)(keysToCheck, function (letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === 's' || letter === 'l') {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};

var toState = exports.toState = function toState(data, oldHue) {
  var color = data.hex ? (0, _tinycolor2.default)(data.hex) : (0, _tinycolor2.default)(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === '000000' && rgb.a === 0;

  return {
    hsl: hsl,
    hex: transparent ? 'transparent' : '#' + hex,
    rgb: rgb,
    hsv: hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};

var isValidHex = exports.isValidHex = function isValidHex(hex) {
  // disable hex4 and hex8
  var lh = String(hex).charAt(0) === '#' ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && (0, _tinycolor2.default)(hex).isValid();
};

var getContrastingColor = exports.getContrastingColor = function getContrastingColor(data) {
  if (!data) {
    return '#fff';
  }
  var col = toState(data);
  if (col.hex === 'transparent') {
    return 'rgba(0,0,0,0.4)';
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
  return yiq >= 128 ? '#000' : '#fff';
};

var red = exports.red = {
  hsl: { a: 1, h: 0, l: 0.5, s: 1 },
  hex: '#ff0000',
  rgb: { r: 255, g: 0, b: 0, a: 1 },
  hsv: { h: 0, s: 1, v: 1, a: 1 }
};

exports.default = exports;

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "nest", function() { return /* reexport */ src_nest; });
__webpack_require__.d(__webpack_exports__, "set", function() { return /* reexport */ src_set; });
__webpack_require__.d(__webpack_exports__, "map", function() { return /* reexport */ src_map; });
__webpack_require__.d(__webpack_exports__, "keys", function() { return /* reexport */ src_keys; });
__webpack_require__.d(__webpack_exports__, "values", function() { return /* reexport */ src_values; });
__webpack_require__.d(__webpack_exports__, "entries", function() { return /* reexport */ src_entries; });

// CONCATENATED MODULE: ./node_modules/d3-collection/src/map.js
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ var src_map = (map);

// CONCATENATED MODULE: ./node_modules/d3-collection/src/nest.js


/* harmony default export */ var src_nest = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = src_map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return src_map();
}

function setMap(map, key, value) {
  map.set(key, value);
}

// CONCATENATED MODULE: ./node_modules/d3-collection/src/set.js


function Set() {}

var proto = src_map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ var src_set = (set);

// CONCATENATED MODULE: ./node_modules/d3-collection/src/keys.js
/* harmony default export */ var src_keys = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/src/values.js
/* harmony default export */ var src_values = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/src/entries.js
/* harmony default export */ var src_entries = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});

// CONCATENATED MODULE: ./node_modules/d3-collection/src/index.js








/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);


/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x = Object(_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ root; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Selection; });

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(57);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/select.js



/* harmony default export */ var selection_select = (function(select) {
  if (typeof select !== "function") select = Object(selector["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(100);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectAll.js



/* harmony default export */ var selectAll = (function(select) {
  if (typeof select !== "function") select = Object(selectorAll["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(101);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/filter.js



/* harmony default export */ var filter = (function(match) {
  if (typeof match !== "function") match = Object(matcher["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ var sparse = (function(update) {
  return new Array(update.length);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/enter.js



/* harmony default export */ var selection_enter = (function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

// CONCATENATED MODULE: ./node_modules/d3-selection/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/data.js




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ var selection_data = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/exit.js



/* harmony default export */ var selection_exit = (function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/join.js
/* harmony default export */ var join = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/merge.js


/* harmony default export */ var selection_merge = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/order.js
/* harmony default export */ var order = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sort.js


/* harmony default export */ var sort = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/call.js
/* harmony default export */ var call = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ var nodes = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/node.js
/* harmony default export */ var selection_node = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/size.js
/* harmony default export */ var size = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ var empty = (function() {
  return !this.node();
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/each.js
/* harmony default export */ var each = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/attr.js


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ var attr = (function(name, value) {
  var fullname = Object(namespace["a" /* default */])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(102);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ var property = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ var classed = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ var selection_text = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ var html = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ var selection_raise = (function() {
  return this.each(raise);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ var selection_lower = (function() {
  return this.each(lower);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/creator.js
var creator = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/append.js


/* harmony default export */ var append = (function(name) {
  var create = typeof name === "function" ? name : Object(creator["a" /* default */])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/insert.js



function constantNull() {
  return null;
}

/* harmony default export */ var insert = (function(name, before) {
  var create = typeof name === "function" ? name : Object(creator["a" /* default */])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(selector["a" /* default */])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ var selection_remove = (function() {
  return this.each(remove);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ var clone = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ var datum = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(45);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/window.js
var src_window = __webpack_require__(59);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/dispatch.js


function dispatchEvent(node, type, params) {
  var window = Object(src_window["a" /* default */])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ var dispatch = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/index.js
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection_selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection_selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selectAll,
  filter: filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: join,
  merge: selection_merge,
  order: order,
  sort: sort,
  call: call,
  nodes: nodes,
  node: selection_node,
  size: size,
  empty: empty,
  each: each,
  attr: attr,
  style: style["a" /* default */],
  property: property,
  classed: classed,
  text: selection_text,
  html: html,
  raise: selection_raise,
  lower: selection_lower,
  append: append,
  insert: insert,
  remove: selection_remove,
  clone: clone,
  datum: datum,
  on: on["b" /* default */],
  dispatch: dispatch
};

/* harmony default export */ var src_selection = __webpack_exports__["b"] = (selection_selection);


/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return params.filter(function (d) {
    return d;
  }).join(" ").trim();
};

exports.default = _default;

/***/ }),
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var SvgHelper_1 = __webpack_require__(71);
var semiotic_mark_1 = __webpack_require__(15);
var Axis_1 = __importDefault(__webpack_require__(82));
var summaryLayouts_1 = __webpack_require__(123);
var axis_1 = __webpack_require__(122);
var d3_scale_1 = __webpack_require__(24);
var extent = function (inputArray) {
    return inputArray.reduce(function (p, c) {
        //      return [Math.min(c, p[0]), Math.max(c, p[1])]
        return [0, Math.max(c, p[1])];
    }, [Infinity, -Infinity]);
};
var findActualTitle = function (rawTitle) {
    var title = null;
    var orient = "top";
    if (typeof rawTitle === "string") {
        title = rawTitle;
    }
    else if ("title" in rawTitle) {
        title = rawTitle.title;
        orient = rawTitle.orient || "top";
    }
    else {
        title = rawTitle;
    }
    return { orient: orient, title: title };
};
function roundToTenth(number) {
    return Math.round(number * 10) / 10;
}
exports.circlePath = function (cx, cy, r) {
    return [
        "M",
        roundToTenth(cx - r),
        roundToTenth(cy),
        "a",
        r,
        r,
        0,
        1,
        0,
        r * 2,
        0,
        "a",
        r,
        r,
        0,
        1,
        0,
        -(r * 2),
        0
    ].join(" ") + "Z";
};
exports.drawMarginPath = function (_a) {
    var margin = _a.margin, size = _a.size, _b = _a.inset, inset = _b === void 0 ? 0 : _b;
    var iSize = [size[0] - inset, size[1] - inset];
    return "M0,0 h" + size[0] + " v" + size[1] + " h-" + size[0] + "Z M" + (margin.left -
        inset) + "," + (margin.top - inset) + " v" + (size[1] +
        inset * 2 -
        margin.top -
        margin.bottom) + " h" + (iSize[0] +
        inset * 3 -
        margin.left -
        margin.right) + " v-" + (iSize[1] + inset * 3 - margin.top - margin.bottom) + "Z";
};
exports.calculateMargin = function (_a) {
    var margin = _a.margin, axes = _a.axes, rawTitle = _a.title, oLabel = _a.oLabel, projection = _a.projection, size = _a.size;
    if (margin !== undefined) {
        if (typeof margin === "function") {
            margin = margin({ size: size });
        }
        if (typeof margin !== "object") {
            return { top: margin, bottom: margin, left: margin, right: margin };
        }
        else if (typeof margin === "object") {
            return Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, margin);
        }
    }
    var finalMargin = { top: 0, bottom: 0, left: 0, right: 0 };
    var orient = "left";
    if (axes && projection !== "radial") {
        axes.forEach(function (axisObj) {
            var axisObjAdditionMargin = axisObj.label ? 60 : 50;
            orient = axisObj.orient;
            finalMargin[orient] = axisObjAdditionMargin;
        });
    }
    var _b = findActualTitle(rawTitle), title = _b.title, titleOrient = _b.orient;
    if (title && !(typeof title === "string" && title.length === 0)) {
        finalMargin[titleOrient] += 40;
    }
    if (oLabel && projection !== "radial") {
        if (orient === "bottom" || orient === "top") {
            finalMargin.left += 50;
        }
        else {
            finalMargin.bottom += 50;
        }
    }
    return finalMargin;
};
function objectifyType(type) {
    if (type instanceof Function || typeof type === "string") {
        return { type: type };
    }
    else if (type === undefined) {
        return {};
    }
    return type;
}
exports.objectifyType = objectifyType;
function generateOrdinalFrameEventListeners(customHoverBehavior, customClickBehavior) {
    var eventListenersGenerator = function () { return ({}); };
    if (customHoverBehavior || customClickBehavior) {
        eventListenersGenerator = function (d, i) { return ({
            onMouseEnter: customHoverBehavior
                ? function () { return customHoverBehavior(d, i); }
                : undefined,
            onMouseLeave: customHoverBehavior
                ? function () { return customHoverBehavior(undefined); }
                : undefined,
            onClick: customClickBehavior
                ? function () { return customClickBehavior(d, i); }
                : undefined
        }); };
    }
    return eventListenersGenerator;
}
exports.generateOrdinalFrameEventListeners = generateOrdinalFrameEventListeners;
function keyAndObjectifyBarData(_a) {
    var data = _a.data, _b = _a.renderKey, renderKey = _b === void 0 ? function (d, i) { return i; } : _b, oAccessor = _a.oAccessor, baseRAccessor = _a.rAccessor, originalRAccessor = _a.originalRAccessor, originalOAccessor = _a.originalOAccessor, _c = _a.multiAxis, multiAxis = _c === void 0 ? false : _c;
    var rAccessor;
    var multiExtents;
    if (multiAxis && baseRAccessor.length > 1) {
        multiExtents = baseRAccessor.map(function (accessor) { return extent(data.map(accessor)); });
        var rScales = multiExtents.map(function (ext) {
            return d3_scale_1.scaleLinear()
                .domain(ext)
                .range([0, 1]);
        });
        rAccessor = rScales.map(function (scale, i) { return function (d) {
            return scale(baseRAccessor[i](d));
        }; });
    }
    else {
        rAccessor = baseRAccessor;
    }
    var decoratedData = [];
    oAccessor.forEach(function (actualOAccessor, oIndex) {
        rAccessor.forEach(function (actualRAccessor, rIndex) {
            ;
            (data || []).forEach(function (d) {
                var appliedKey = renderKey(d, decoratedData.length);
                var originalR = originalRAccessor[rIndex];
                var originalO = originalOAccessor[oIndex];
                var rName = typeof originalR === "string" ? originalR : "function-" + rIndex;
                var oName = typeof originalO === "string" ? originalO : "function-" + oIndex;
                if (typeof d !== "object") {
                    var expandedData = { value: d, renderKey: appliedKey };
                    var value = actualRAccessor(expandedData);
                    decoratedData.push({
                        data: expandedData,
                        value: value,
                        rIndex: rIndex,
                        rName: rName,
                        oIndex: oIndex,
                        oName: oName,
                        column: (appliedKey !== undefined &&
                            appliedKey.toString &&
                            appliedKey.toString()) ||
                            appliedKey,
                        renderKey: appliedKey
                    });
                }
                else {
                    var value = actualRAccessor(d);
                    decoratedData.push({
                        renderKey: appliedKey,
                        data: d,
                        rIndex: rIndex,
                        rName: rName,
                        oIndex: oIndex,
                        oName: oName,
                        value: value,
                        column: actualOAccessor(d)
                    });
                }
            });
        });
    });
    return { allData: decoratedData, multiExtents: multiExtents };
}
exports.keyAndObjectifyBarData = keyAndObjectifyBarData;
function adjustedPositionSize(_a) {
    var _b = _a.size, size = _b === void 0 ? [500, 500] : _b, _c = _a.position, position = _c === void 0 ? [0, 0] : _c, margin = _a.margin, projection = _a.projection;
    var heightAdjust = margin.top + margin.bottom;
    var widthAdjust = margin.left + margin.right;
    var adjustedPosition = [position[0], position[1]];
    var adjustedSize = [size[0] - widthAdjust, size[1] - heightAdjust];
    if (projection === "radial") {
        var minSize = Math.min(adjustedSize[0], adjustedSize[1]);
        adjustedSize = [minSize, minSize];
    }
    return { adjustedPosition: adjustedPosition, adjustedSize: adjustedSize };
}
exports.adjustedPositionSize = adjustedPositionSize;
function generateFrameTitle(_a) {
    var _b = _a.title, rawTitle = _b === void 0 ? { title: "", orient: "top" } : _b, size = _a.size;
    var finalTitle = null;
    var _c = findActualTitle(rawTitle), title = _c.title, orient = _c.orient;
    var x = 0, y = 0, transform;
    switch (orient) {
        case "top":
            x = size[0] / 2;
            y = 25;
            break;
        case "bottom":
            x = size[0] / 2;
            y = size[1] - 25;
            break;
        case "left":
            x = 25;
            y = size[1] / 2;
            transform = "rotate(-90)";
            break;
        case "right":
            x = size[0] - 25;
            y = size[1] / 2;
            transform = "rotate(90)";
            break;
    }
    var gTransform = "translate(" + x + "," + y + ")";
    if (typeof title === "string" && title.length > 0) {
        finalTitle = (React.createElement("g", { transform: gTransform },
            React.createElement("text", { className: "frame-title", transform: transform, style: { textAnchor: "middle", pointerEvents: "none" } }, title)));
    }
    else if (title) {
        //assume if defined then its an svg mark of some sort
        finalTitle = React.createElement("g", { transform: gTransform }, title);
    }
    return finalTitle;
}
exports.generateFrameTitle = generateFrameTitle;
function orFrameConnectionRenderer(_a) {
    var e_1, _b;
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, projection = _a.projection, canvasRender = _a.canvasRender, canvasDrawing = _a.canvasDrawing, baseMarkProps = _a.baseMarkProps, pieceType = _a.pieceType;
    if (!type.type) {
        return null;
    }
    var renderedConnectorMarks = [];
    var radarHash = new Map();
    if (typeof type.type === "function") {
        var connectionRule_1 = type.type;
        var keys_1 = Object.keys(data);
        keys_1.forEach(function (key, pieceArrayI) {
            var pieceArray = data[key];
            var nextColumn = data[keys_1[pieceArrayI + 1]];
            if (nextColumn) {
                var matchArray_1 = nextColumn.map(function (d, i) {
                    return connectionRule_1(__assign(__assign({}, d.piece), d.piece.data), i);
                });
                pieceArray.forEach(function (piece, pieceI) {
                    var thisConnectionPiece = connectionRule_1(__assign(__assign({}, piece.piece), piece.piece.data), pieceI);
                    var targetMatch = connectionRule_1(__assign(__assign({}, piece.piece), piece.piece.data), pieceI);
                    var matchingPieceIndex = targetMatch !== undefined &&
                        targetMatch !== false &&
                        matchArray_1.indexOf(targetMatch);
                    if (thisConnectionPiece !== undefined &&
                        thisConnectionPiece !== null &&
                        matchingPieceIndex !== false &&
                        matchingPieceIndex !== -1) {
                        var matchingPiece = nextColumn[matchingPieceIndex];
                        var markD = void 0;
                        if (projection === "radial" && pieceType.type === "point") {
                            if (!radarHash.get(piece)) {
                                radarHash.set(piece, [piece]);
                            }
                            var thisRadar = radarHash.get(piece);
                            if (thisRadar) {
                                thisRadar.push(matchingPiece);
                                radarHash.set(matchingPiece, thisRadar);
                                radarHash.delete(piece);
                            }
                        }
                        else {
                            var xy = piece.xy;
                            var mxy = matchingPiece.xy;
                            var x = xy.x, y = xy.y, _a = xy.height, height = _a === void 0 ? 1 : _a, _b = xy.width, width = _b === void 0 ? 1 : _b;
                            var mx = mxy.x, my = mxy.y, _c = mxy.height, mheight = _c === void 0 ? 1 : _c, _d = mxy.width, mwidth = _d === void 0 ? 1 : _d;
                            if (projection === "vertical") {
                                markD = SvgHelper_1.drawAreaConnector({
                                    x1: x + width,
                                    x2: mx,
                                    y1: y,
                                    y2: my,
                                    sizeX1: 0,
                                    sizeX2: 0,
                                    sizeY1: height,
                                    sizeY2: mheight
                                });
                            }
                            else if (projection === "horizontal") {
                                markD = SvgHelper_1.drawAreaConnector({
                                    x1: x,
                                    x2: mx,
                                    y1: y + height,
                                    y2: my,
                                    sizeX1: width,
                                    sizeX2: mwidth,
                                    sizeY1: 0,
                                    sizeY2: 0
                                });
                            }
                            else if (projection === "radial") {
                                markD = SvgHelper_1.drawAreaConnector({
                                    x1: x,
                                    x2: mx,
                                    y1: y + height,
                                    y2: my,
                                    sizeX1: width,
                                    sizeX2: mwidth,
                                    sizeY1: 0,
                                    sizeY2: 0
                                });
                            }
                            var renderValue = renderMode && renderMode(piece.piece, pieceI);
                            var source = __assign(__assign({}, piece.piece.data), piece.piece.data);
                            var target = __assign(__assign({}, matchingPiece.piece), matchingPiece.piece.data);
                            var calculatedStyle = styleFn({
                                source: source,
                                target: target
                            });
                            var eventListeners = eventListenersGenerator({ source: source, target: target }, pieceI);
                            if (canvasRender && canvasRender(piece.piece) === true) {
                                var canvasConnector = {
                                    baseClass: "xyframe-line",
                                    tx: 0,
                                    ty: 0,
                                    d: {
                                        source: source,
                                        target: target
                                    },
                                    markProps: { d: markD, markType: "path" },
                                    styleFn: styleFn,
                                    renderFn: renderMode,
                                    classFn: classFn
                                };
                                canvasDrawing.push(canvasConnector);
                            }
                            else {
                                renderedConnectorMarks.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, eventListeners, { renderMode: renderValue, markType: "path", d: markD, className: classFn ? classFn(piece.piece.data, pieceI) : "", key: "connector" + piece.piece.renderKey, style: calculatedStyle })));
                            }
                        }
                    }
                });
            }
        });
        if (radarHash.size > 0) {
            try {
                for (var _c = __values(radarHash.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var ring = _d.value;
                    var ringPiece = __assign(__assign({}, ring[0].piece), ring[0].piece.data);
                    var markD = "M" + ring.map(function (d) { return d.xy.x + "," + d.xy.y; }).join("L") + "Z";
                    if (canvasRender && canvasRender(ringPiece)) {
                        var canvasRadar = {
                            baseClass: "ordinal-radar",
                            tx: 0,
                            ty: 0,
                            d: {
                                source: ringPiece
                            },
                            markProps: { d: markD, markType: "path" },
                            styleFn: styleFn,
                            renderFn: renderMode,
                            classFn: classFn
                        };
                        canvasDrawing.push(canvasRadar);
                    }
                    else {
                        renderedConnectorMarks.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode && renderMode(ringPiece), markType: "path", d: markD, className: classFn ? classFn(ringPiece) : "", key: "ordinal-ring-" + ringPiece.renderKey, style: styleFn({
                                source: ringPiece
                            }) })));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    else if (type.type) {
        console.error("Invalid connectorType - Must be a function that takes a data point and determines if it is connected to a data point in the next column");
    }
    return renderedConnectorMarks;
}
exports.orFrameConnectionRenderer = orFrameConnectionRenderer;
var summaryRenderHash = {
    contour: summaryLayouts_1.contourRenderFn,
    boxplot: summaryLayouts_1.boxplotRenderFn,
    violin: summaryLayouts_1.bucketizedRenderingFn,
    heatmap: summaryLayouts_1.bucketizedRenderingFn,
    ridgeline: summaryLayouts_1.bucketizedRenderingFn,
    histogram: summaryLayouts_1.bucketizedRenderingFn,
    horizon: summaryLayouts_1.bucketizedRenderingFn
};
function orFrameSummaryRenderer(_a) {
    var data = _a.data, type = _a.type, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, projection = _a.projection, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, baseMarkProps = _a.baseMarkProps, margin = _a.margin;
    var summaryRenderFn;
    if (typeof type.type === "function") {
        summaryRenderFn = type.type;
    }
    else if (summaryRenderHash[type.type]) {
        summaryRenderFn = summaryRenderHash[type.type];
    }
    else {
        console.error("Invalid summary type: " + type.type + " - Must be a function or one of the following strings: " + Object.keys(summaryRenderHash).join(", "));
        return {};
    }
    return summaryRenderFn({
        data: data,
        type: type,
        renderMode: renderMode,
        eventListenersGenerator: eventListenersGenerator,
        styleFn: styleFn,
        classFn: classFn,
        projection: projection,
        adjustedSize: adjustedSize,
        chartSize: chartSize,
        baseMarkProps: baseMarkProps,
        margin: margin
    });
}
exports.orFrameSummaryRenderer = orFrameSummaryRenderer;
exports.orFrameAxisGenerator = function (_a) {
    var projection = _a.projection, axis = _a.axis, adjustedSize = _a.adjustedSize, size = _a.size, rScale = _a.rScale, rScaleType = _a.rScaleType, pieceType = _a.pieceType, rExtent = _a.rExtent, data = _a.data, _b = _a.maxColumnValues, maxColumnValues = _b === void 0 ? 1 : _b, xyData = _a.xyData, margin = _a.margin;
    if (!axis)
        return { axis: undefined, axesTickLines: undefined };
    var generatedAxis, axesTickLines;
    if (projection !== "radial" && axis) {
        axesTickLines = [];
        var axisPosition_1 = [0, 0];
        generatedAxis = axis.map(function (d, i) {
            var axisClassname = d.className || "";
            var tickValues;
            var axisDomain = d.extentOverride ? d.extentOverride : rScale.domain();
            var leftRight = ["left", "right"];
            var axisScale = (leftRight.indexOf(d.orient) === -1 && projection !== "vertical") ||
                (leftRight.indexOf(d.orient) !== -1 && projection !== "horizontal")
                ? rScaleType.domain(axisDomain)
                : rScaleType.domain([0, maxColumnValues]);
            var orient = d.orient;
            var axisRange = (leftRight.indexOf(d.orient) === -1 && projection !== "vertical") ||
                (leftRight.indexOf(d.orient) !== -1 && projection !== "horizontal")
                ? rScale.range()
                : [0, projection === "vertical" ? adjustedSize[0] : adjustedSize[1]];
            if (orient === "right") {
                axisScale.range(axisRange.reverse());
                axisClassname += " right y";
            }
            else if (orient === "left") {
                axisClassname += " left y";
                axisScale.range(axisRange.reverse());
            }
            else if (orient === "top") {
                axisClassname += " top x";
                axisScale.range(axisRange);
            }
            else if (orient === "bottom") {
                axisClassname += " bottom x";
                axisScale.range(axisRange);
            }
            if (d.tickValues && Array.isArray(d.tickValues)) {
                tickValues = d.tickValues;
            }
            else if (d.tickValues instanceof Function) {
                //otherwise assume a function
                tickValues = d.tickValues(data, size, rScale);
            }
            var axisParts = axis_1.axisPieces({
                padding: d.padding,
                tickValues: tickValues,
                scale: axisScale,
                ticks: d.ticks,
                orient: orient,
                size: adjustedSize,
                footer: d.footer,
                tickSize: d.tickSize,
                jaggedBase: d.jaggedBase
            });
            var axisTickLines = axis_1.axisLines({
                className: d.className,
                axisParts: axisParts,
                orient: orient,
                baseMarkProps: {},
                tickLineGenerator: d.tickLineGenerator,
                jaggedBase: d.jaggedBase,
                scale: axisScale
            });
            axesTickLines.push(axisTickLines);
            if (d.baseline === "under") {
                axesTickLines.push(axis_1.baselineGenerator(d.orient, adjustedSize, d.className));
            }
            var marginalSummaryType = typeof d.marginalSummaryType === "string"
                ? { type: d.marginalSummaryType }
                : d.marginalSummaryType;
            return (React.createElement(Axis_1.default, __assign({}, d, { key: d.key || "orframe-axis-" + i, axisParts: axisParts, orient: orient, size: adjustedSize, position: axisPosition_1, tickValues: tickValues, scale: axisScale, className: axisClassname, marginalSummaryType: marginalSummaryType, margin: margin, xyPoints: xyData.map(function (d) { return ({
                    x: projection === "vertical" ? 0 : d.value,
                    y: projection === "vertical" ? d.value : 0,
                    data: d.data
                }); }) })));
        });
    }
    else if (projection === "radial" && axis) {
        var _c = pieceType.innerRadius, innerRadius_1 = _c === void 0 ? 0 : _c;
        var ticks_1 = [];
        axis.forEach(function (axisObj) {
            var _a = axisObj.tickValues, baseTickValues = _a === void 0 ? rScale.ticks(Math.max(2, (adjustedSize[0] / 2 - innerRadius_1) / 50)) : _a, label = axisObj.label, _b = axisObj.tickFormat, tickFormat = _b === void 0 ? function (d) { return d; } : _b;
            var tickScale = rScaleType
                .domain(rExtent)
                .range([innerRadius_1, adjustedSize[0] / 2]);
            var tickValues = baseTickValues instanceof Function
                ? baseTickValues({
                    orient: axisObj.orient
                })
                : baseTickValues;
            tickValues.forEach(function (t, i) {
                var tickSize = tickScale(t);
                if (!(innerRadius_1 === 0 && t === 0)) {
                    var axisLabel = void 0;
                    var ref = "";
                    if (label && i === tickValues.length - 1) {
                        var labelSettings = typeof label === "string"
                            ? { name: label, locationDistance: 15 }
                            : label;
                        var _a = labelSettings.locationDistance, locationDistance = _a === void 0 ? 15 : _a;
                        ref = Math.random().toString() + " ";
                        axisLabel = (React.createElement("g", { className: "axis-label radial", transform: "translate(0," + locationDistance + ")" },
                            React.createElement("text", { textAnchor: "middle" },
                                React.createElement("textPath", { startOffset: tickSize * Math.PI * 0.5, xlinkHref: "#" + ref }, label.name))));
                    }
                    ticks_1.push(React.createElement("g", { key: "orframe-radial-axis-element-" + t, className: "axis axis-label axis-tick radial", transform: "translate(0,0)" },
                        React.createElement("path", { id: ref, d: exports.circlePath(0, 0, tickSize), r: tickSize, stroke: "gray", fill: "none" }),
                        React.createElement("text", { y: -tickSize + 5, textAnchor: "middle" }, tickFormat(t)),
                        axisLabel));
                }
                return undefined;
            });
        });
        generatedAxis = [
            React.createElement("g", { key: axis[0].key || "orframe-radial-axis-container", className: "axis-labels", transform: "translate(" + adjustedSize[0] / 2 + "," + adjustedSize[1] / 2 + ")" }, ticks_1)
        ];
    }
    return { axis: generatedAxis, axesTickLines: axesTickLines };
};
exports.canvasEvent = function (canvasContext, overlayRegions, canvasMap, e) {
    var interactionContext = canvasContext.getContext("2d");
    var hoverPoint = interactionContext.getImageData(e.offsetX, e.offsetY, 1, 1);
    var mostCommonRGB = "rgba(" + hoverPoint.data[0] + "," + hoverPoint.data[1] + "," + hoverPoint.data[2] + ",255)";
    var overlay = overlayRegions[canvasMap.get(mostCommonRGB)];
    if (!overlay) {
        var hoverArea = interactionContext.getImageData(e.offsetX - 2, e.offsetY - 2, 5, 5);
        var x = 0;
        while (!overlay && x < 100) {
            overlay =
                overlayRegions[canvasMap.get("rgba(" + hoverArea.data[x] + "," + hoverArea.data[x + 1] + "," + hoverArea.data[x + 2] + ",255)")];
            x += 4;
        }
    }
    return overlay;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(192),
    baseIteratee = __webpack_require__(348),
    baseMap = __webpack_require__(406),
    isArray = __webpack_require__(16);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__[/* xhtml */ "b"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__[/* xhtml */ "b"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ quantile; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ quantileSorted; });

// EXTERNAL MODULE: ./node_modules/d3-array/src/max.js
var max = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/d3-array/src/min.js
var min = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/d3-array/src/quickselect.js
var quickselect = __webpack_require__(110);

// CONCATENATED MODULE: ./node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// CONCATENATED MODULE: ./node_modules/d3-array/src/quantile.js





function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return Object(min["a" /* default */])(values);
  if (p >= 1) return Object(max["a" /* default */])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = Object(max["a" /* default */])(Object(quickselect["a" /* default */])(values, i0).subarray(0, i0 + 1)),
      value1 = Object(min["a" /* default */])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["a"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isNumberArray; });
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
});

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Annotation = _interopRequireDefault(__webpack_require__(161));

var _EditableAnnotation = _interopRequireDefault(__webpack_require__(256));

var _ConnectorLine = _interopRequireDefault(__webpack_require__(116));

var _ConnectorElbow = _interopRequireDefault(__webpack_require__(67));

var _ConnectorCurve = _interopRequireDefault(__webpack_require__(258));

var _ConnectorEndDot = _interopRequireDefault(__webpack_require__(260));

var _ConnectorEndArrow = _interopRequireDefault(__webpack_require__(262));

var _Subject = _interopRequireDefault(__webpack_require__(50));

var _Note = _interopRequireDefault(__webpack_require__(164));

var _JSXNote = _interopRequireDefault(__webpack_require__(266));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getAnnotationType = function getAnnotationType(editMode) {
  return editMode ? _EditableAnnotation.default : _Annotation.default;
};

function _default(props, Connector) {
  var NoteDefaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var Subject = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _Subject.default;
  var SubjectDefaultProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var NoteType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _Note.default;
  var _props$disable = props.disable,
      disable = _props$disable === void 0 ? [] : _props$disable,
      connector = props.connector,
      note = props.note,
      subject = props.subject,
      x = props.x,
      y = props.y,
      dx = props.dx,
      dy = props.dy,
      nx = props.nx,
      ny = props.ny,
      color = props.color,
      className = props.className,
      onDrag = props.onDrag,
      onDragStart = props.onDragStart,
      onDragEnd = props.onDragEnd,
      editMode = props.editMode,
      events = props.events;
  var CONNECTORS = {
    type: {
      curve: _ConnectorCurve.default,
      line: _ConnectorLine.default,
      elbow: _ConnectorElbow.default
    },
    end: {
      dot: _ConnectorEndDot.default,
      arrow: _ConnectorEndArrow.default
    }
  };
  var ConnectorType, ConnectorEndType;

  if (disable.indexOf("connector") === -1) {
    ConnectorType = connector && CONNECTORS.type[connector.type] || Connector;
    ConnectorEndType = connector && CONNECTORS.end[connector.end];
  }

  var AnnotationType = getAnnotationType(props.editMode);
  return _react.default.createElement(AnnotationType, _extends({
    x: x,
    y: y,
    dx: dx,
    dy: dy,
    nx: nx,
    ny: ny,
    color: color,
    className: className,
    onDrag: onDrag,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd,
    editMode: editMode
  }, SubjectDefaultProps, subject, {
    events: events
  }), ConnectorType && _react.default.createElement(ConnectorType, connector, ConnectorEndType && _react.default.createElement(ConnectorEndType, null)), Subject && disable.indexOf("subject") === -1 && _react.default.createElement(Subject, null), note && disable.indexOf("note") === -1 && (_react.default.isValidElement(note) || typeof note === "function") ? _react.default.createElement(_JSXNote.default, {
    noteDefaultProps: NoteDefaultProps,
    note: note
  }) : _react.default.createElement(NoteType, _extends({}, NoteDefaultProps, note)));
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var SpanOrDiv = /** @class */ (function (_super) {
    __extends(SpanOrDiv, _super);
    function SpanOrDiv() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpanOrDiv.prototype.render = function () {
        var _a = this.props, style = _a.style, className = _a.className, span = _a.span, children = _a.children;
        if (span)
            return (React.createElement("span", { className: className, style: __assign({ display: "block" }, style) }, children));
        return (React.createElement("div", { className: className, style: style }, children));
    };
    return SpanOrDiv;
}(React.PureComponent));
exports.HOCSpanOrDiv = function (span) {
    if (span) {
        return function (props) {
            var className = props.className, style = props.style, children = props.children;
            return (React.createElement("span", { className: className, style: __assign({ display: "block" }, style) }, children));
        };
    }
    return function (props) {
        var className = props.className, style = props.style, children = props.children;
        return (React.createElement("div", { className: className, style: style }, children));
    };
};
exports.default = SpanOrDiv;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(73),
    getRawTag = __webpack_require__(339),
    objectToString = __webpack_require__(340);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(361),
    getValue = __webpack_require__(364);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeDisplayValue = void 0;
const styled_components_1 = __importDefault(__webpack_require__(19));
exports.safeDisplayValue = (value) => value && value.toString ? value.toString() : value;
// A little "mixin" for picking the :before on a tooltip
const beforeContent = (props) => {
    if (props.x < 200 || props.x > 600) {
        return null;
    }
    if (props.y < 200) {
        return `
      border-left: inherit;
      border-top: inherit;
      top: -8px;
      left: calc(50% - 15px);
      background: inherit;
      content: "";
      padding: 0px;
      transform: rotate(45deg);
      width: 15px;
      height: 15px;
      position: absolute;
      z-index: 99;
    `;
    }
    return `
    border-right: inherit;
    border-bottom: inherit;
    bottom: -8px;
    left: calc(50% - 15px);
    background: inherit;
    content: "";
    padding: 0px;
    transform: rotate(45deg);
    width: 15px;
    height: 15px;
    position: absolute;
    z-index: 99;
  `;
};
const TooltipContent = styled_components_1.default.div.attrs((props) => ({
    style: {
        transform: `translate(
      ${props.x < 200 ? "0px" : props.x > 600 ? "-100%" : "calc(-50% + 7px)"},
      ${props.y < 200 ? "10px" : "calc(-100% - 10px)"}
    )`
    }
})) `
  color: black;
  padding: 10px;
  z-index: 999999;
  width: 500px;
  background: white;
  border: 1px solid #888;
  border-radius: 5px;
  position: relative;

  & p {
    font-size: 14px;
  }

  & h3 {
    margin: 0 0 10px;
  }

  &:before {
    ${beforeContent}
  }
`;
exports.default = TooltipContent;


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return customEvent; });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(103);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);





/* harmony default export */ __webpack_exports__["a"] = ((function rgbGamma(y) {
  var color = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__[/* gamma */ "b"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* rgb */ "g"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* rgb */ "g"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* rgb */ "g"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return min; });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["a"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var AnnotationLabel_1 = __importDefault(__webpack_require__(160));
var interactivityFns = ["onDragEnd", "onDragStart", "onDrag"];
var SemioticAnnotation = /** @class */ (function (_super) {
    __extends(SemioticAnnotation, _super);
    function SemioticAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SemioticAnnotation.prototype.render = function () {
        var baseNoteData = this.props.noteData;
        var screenCoordinates = baseNoteData.screenCoordinates;
        var noteData = __assign({}, baseNoteData);
        interactivityFns.forEach(function (d) {
            if (baseNoteData[d]) {
                delete noteData[d];
                var originalFn_1 = baseNoteData[d];
                noteData[d] = function (updatedSettingsFromRA) {
                    originalFn_1({
                        originalSettings: baseNoteData,
                        updatedSettings: updatedSettingsFromRA,
                        noteIndex: baseNoteData.i
                    });
                };
            }
        });
        var AnnotationType = typeof noteData.type === "function" ? noteData.type : AnnotationLabel_1.default;
        var eventListeners = noteData.eventListeners || noteData.events || {};
        var finalStyle = {};
        if (noteData.events || noteData.eventListeners || noteData.editMode) {
            finalStyle.pointerEvents = "all";
        }
        if (noteData.coordinates && screenCoordinates) {
            //Multisubject annotation
            var setNX_1 = noteData.nx || screenCoordinates[0][0] + noteData.dx;
            var setNY_1 = noteData.ny || screenCoordinates[0][1] + noteData.dy;
            var notes = screenCoordinates.map(function (d, i) {
                var subjectNote = Object.assign({}, noteData, {
                    note: i === 0 ? noteData.note : { label: "" },
                    x: d[0],
                    y: d[1],
                    nx: setNX_1,
                    ny: setNY_1
                });
                return React.createElement(AnnotationType, __assign({ key: "multi-annotation-" + i }, subjectNote));
            });
            return (React.createElement("g", __assign({}, eventListeners, { style: finalStyle }), notes));
        }
        console.log("noteData", noteData);
        var keyData = noteData.note || { title: "none", label: noteData.label };
        var annotationKey = keyData.label + "-" + keyData.title + "-" + noteData.i;
        var finalAnnotation = (React.createElement(AnnotationType, __assign({ key: annotationKey, events: eventListeners }, noteData)));
        if (finalStyle.pointerEvents) {
            return React.createElement("g", { style: finalStyle }, finalAnnotation);
        }
        return finalAnnotation;
    };
    return SemioticAnnotation;
}(React.Component));
exports.default = SemioticAnnotation;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Handle = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var FILLABLE = ["SubjectCircle", "SubjectRect"];

var Subject =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Subject, _React$Component);

  function Subject() {
    _classCallCheck(this, Subject);

    return _possibleConstructorReturn(this, _getPrototypeOf(Subject).apply(this, arguments));
  }

  _createClass(Subject, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          editMode = _this$props.editMode,
          color = _this$props.color,
          _this$props$fill = _this$props.fill,
          fill = _this$props$fill === void 0 ? "none" : _this$props$fill,
          _this$props$fillOpaci = _this$props.fillOpacity,
          fillOpacity = _this$props$fillOpaci === void 0 ? 1 : _this$props$fillOpaci;
      var d = this.getComponents(this.props) || {};
      var handles;

      if (editMode) {
        handles = [_react.default.createElement(_Handle.default, {
          key: "subject-handle",
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragSubject
        })];

        if (d.handles) {
          handles = handles.concat(d.handles.map(function (h, i) {
            return _react.default.createElement(_Handle.default, {
              key: "subjecthandle-".concat(i),
              handleStart: _this.props.dragStart,
              handleStop: _this.props.dragEnd,
              x: h.x,
              y: h.y,
              offsetParent: h.offsetParent && _this.subject,
              handleDrag: function handleDrag(e, data) {
                _this.props.dragSubjectSettings(e, d.handleFunction(h, data));
              }
            });
          }));
        }
      }

      var honorFill = FILLABLE.indexOf(this.name) !== -1;
      return _react.default.createElement("g", _extends({
        className: "annotation-subject"
      }, this.props.gAttrs, {
        ref: d.handles ? function (subject) {
          _this.subject = subject;
        } : undefined
      }), d.components && d.components.map(function (c, i) {
        var attrs = {};
        if (!c) return null;
        Object.keys(c.attrs).forEach(function (k) {
          if (c.attrs[k] && k !== "text") {
            attrs[k.replace(/-([a-z])/g, function (g) {
              return g[1].toUpperCase();
            })] = c.attrs[k];
          }
        });
        return _react.default.createElement(c.type, _extends({
          key: i,
          className: c.className,
          fill: honorFill && fill || "none",
          fillOpacity: honorFill && fillOpacity !== undefined ? fillOpacity : undefined,
          stroke: color
        }, attrs), c.attrs.text);
      }), handles);
    }
  }]);

  return Subject;
}(_react.default.Component);

exports.default = Subject;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var AnnotationCalloutCircle_1 = __importDefault(__webpack_require__(125));
var AnnotationCalloutRect_1 = __importDefault(__webpack_require__(172));
var AnnotationCalloutCustom_1 = __importDefault(__webpack_require__(283));
var Annotation_1 = __importDefault(__webpack_require__(49));
var d3_polygon_1 = __webpack_require__(516);
var polygon_offset_1 = __importDefault(__webpack_require__(285));
exports.circleEnclosure = function (_a) {
    var d = _a.d, i = _a.i, circle = _a.circle;
    var _b = d.padding, padding = _b === void 0 ? 2 : _b, _c = d.radiusPadding, radiusPadding = _c === void 0 ? padding : _c, label = d.label;
    var noteData = Object.assign({
        dx: 0,
        dy: 0,
        note: { label: label },
        connector: { end: "arrow" }
    }, d, {
        coordinates: undefined,
        x: circle.x,
        y: circle.y,
        type: AnnotationCalloutCircle_1.default,
        subject: {
            radius: circle.r,
            radiusPadding: radiusPadding
        },
        i: i
    });
    if (noteData.rp) {
        switch (noteData.rp) {
            case "top":
                noteData.dx = 0;
                noteData.dy = -circle.r - noteData.rd;
                break;
            case "bottom":
                noteData.dx = 0;
                noteData.dy = circle.r + noteData.rd;
                break;
            case "left":
                noteData.dx = -circle.r - noteData.rd;
                noteData.dy = 0;
                break;
            default:
                noteData.dx = circle.r + noteData.rd;
                noteData.dy = 0;
        }
    }
    //TODO: Support .ra (setting angle)
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.rectangleEnclosure = function (_a) {
    var bboxNodes = _a.bboxNodes, d = _a.d, i = _a.i;
    var _b = d.padding, padding = _b === void 0 ? 0 : _b, _c = d.dx, dx = _c === void 0 ? -25 : _c, _d = d.dy, dy = _d === void 0 ? -25 : _d, label = d.label;
    var bbox = [
        [
            Math.min.apply(Math, __spread(bboxNodes.map(function (p) { return p.x0; }))) - padding,
            Math.min.apply(Math, __spread(bboxNodes.map(function (p) { return p.y0; }))) - padding
        ],
        [
            Math.max.apply(Math, __spread(bboxNodes.map(function (p) { return p.x1; }))) + padding,
            Math.max.apply(Math, __spread(bboxNodes.map(function (p) { return p.y1; }))) + padding
        ]
    ];
    var noteData = Object.assign({
        dx: dx,
        dy: dy,
        note: { label: label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationCalloutRect_1.default,
        x: bbox[0][0],
        y: bbox[0][1],
        subject: {
            width: bbox[1][0] - bbox[0][0],
            height: bbox[1][1] - bbox[0][1]
        }
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.hullEnclosure = function (_a) {
    var points = _a.points, d = _a.d, i = _a.i;
    var _b = d.color, color = _b === void 0 ? "black" : _b, _c = d.dx, dx = _c === void 0 ? -25 : _c, _d = d.dy, dy = _d === void 0 ? -25 : _d, label = d.label, _e = d.padding, padding = _e === void 0 ? 10 : _e, _f = d.buffer, buffer = _f === void 0 ? padding : _f, _g = d.strokeWidth, strokeWidth = _g === void 0 ? 10 : _g;
    var hullPoints = d3_polygon_1.polygonHull(points);
    var offset = new polygon_offset_1.default();
    var bufferedHull = offset
        .data(__spread(hullPoints, [hullPoints[0]]))
        .margin(buffer)[0];
    var hullD = "M" + bufferedHull.map(function (d) { return d.join(","); }).join("L") + "Z";
    var firstCoord = bufferedHull[0];
    var _h = d.nx, nx = _h === void 0 ? firstCoord[0] + dx : _h, _j = d.ny, ny = _j === void 0 ? firstCoord[1] + dy : _j;
    var closestCoordinates = bufferedHull.reduce(function (p, c) {
        if (Math.hypot(nx - p[0], ny - p[1]) > Math.hypot(nx - c[0], ny - c[1])) {
            p = c;
        }
        return p;
    }, firstCoord);
    var noteData = Object.assign({
        dx: dx,
        dy: dy,
        note: { label: label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationCalloutCustom_1.default,
        x: closestCoordinates[0],
        y: closestCoordinates[1],
        subject: {
            custom: [
                React.createElement("path", { key: "hull-drawing", d: hullD, strokeWidth: strokeWidth, strokeMiterlimit: "10", strokeLinejoin: "miter", strokeLinecap: "butt", fill: "none", stroke: color, transform: "translate(" + -closestCoordinates[0] + "," + -closestCoordinates[1] + ")" })
            ],
            customID: "hull-annotation"
        }
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.desaturationLayer = function (_a) {
    var _b = _a.style, style = _b === void 0 ? { fill: "white", fillOpacity: 0.5 } : _b, size = _a.size, i = _a.i, key = _a.key;
    return (React.createElement("rect", { key: key || "desaturation-" + i, x: -5, y: -5, width: size[0] + 10, height: size[1] + 10, style: style }));
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var lineDrawing_1 = __webpack_require__(68);
var coordinateNames_1 = __webpack_require__(121);
var lineDrawing_2 = __webpack_require__(68);
var areaDrawing_1 = __webpack_require__(83);
var d3_array_1 = __webpack_require__(3);
var unflowedFunctions_1 = __webpack_require__(178);
var baseDefinedFunction = function () { return true; };
var whichPointsHashY = {
    top: coordinateNames_1.projectedYTop,
    bottom: coordinateNames_1.projectedYBottom,
    orphan: coordinateNames_1.projectedY
};
var whichPointsHashX = {
    top: coordinateNames_1.projectedXTop,
    bottom: coordinateNames_1.projectedXBottom,
    orphan: coordinateNames_1.projectedX
};
var builtInTransformations = {
    stackedarea: lineDrawing_2.stackedArea,
    "stackedarea-invert": lineDrawing_2.stackedArea,
    stackedpercent: lineDrawing_2.stackedArea,
    "stackedpercent-invert": lineDrawing_2.stackedArea,
    linepercent: lineDrawing_2.stackedArea,
    difference: lineDrawing_2.differenceLine,
    bumparea: lineDrawing_2.bumpChart,
    bumpline: lineDrawing_2.bumpChart,
    "bumparea-invert": lineDrawing_2.bumpChart,
    line: lineDrawing_2.lineChart,
    area: lineDrawing_2.lineChart,
    cumulative: lineDrawing_2.cumulativeLine,
    "cumulative-reverse": lineDrawing_2.cumulativeLine
};
function stringToFn(accessor, defaultAccessor, raw) {
    if (!accessor && defaultAccessor) {
        return defaultAccessor;
    }
    else if (typeof accessor === "object") {
        return function () { return accessor; };
    }
    else if (accessor instanceof Function) {
        return accessor;
    }
    else if (raw === true) {
        var castAccessor_1 = accessor;
        return function () { return castAccessor_1; };
    }
    else if (typeof accessor === "string") {
        return function (d) { return d[accessor]; };
    }
    return function () { return undefined; };
}
exports.stringToFn = stringToFn;
function stringToArrayFn(accessor, defaultAccessor, raw) {
    if (accessor === undefined) {
        return [stringToFn(undefined, defaultAccessor, raw)];
    }
    var arrayOfAccessors = [];
    if (Array.isArray(accessor)) {
        arrayOfAccessors = accessor;
    }
    else {
        arrayOfAccessors = [accessor];
    }
    return arrayOfAccessors.map(function (a) {
        return stringToFn(a, defaultAccessor, raw);
    });
}
exports.stringToArrayFn = stringToArrayFn;
exports.calculateDataExtent = function (_a) {
    var lineDataAccessor = _a.lineDataAccessor, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor, summaries = _a.summaries, points = _a.points, lines = _a.lines, lineType = _a.lineType, showLinePoints = _a.showLinePoints, showSummaryPoints = _a.showSummaryPoints, xExtent = _a.xExtent, yExtent = _a.yExtent, invertX = _a.invertX, invertY = _a.invertY, summaryDataAccessor = _a.summaryDataAccessor, summaryType = _a.summaryType, size = _a.adjustedSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, summaryStyleFn = _a.summaryStyleFn, summaryClassFn = _a.summaryClassFn, summaryRenderModeFn = _a.summaryRenderModeFn, chartSize = _a.chartSize, filterRenderedLines = _a.filterRenderedLines, filterRenderedSummaries = _a.filterRenderedSummaries, filterRenderedPoints = _a.filterRenderedPoints, _b = _a.defined, defined = _b === void 0 ? baseDefinedFunction : _b, _c = _a.annotations, annotations = _c === void 0 ? [] : _c;
    var fullDataset = [];
    var initialProjectedLines = [];
    var projectedPoints = [], projectedLines = [], projectedSummaries = [];
    if (points) {
        xAccessor.forEach(function (actualXAccessor, xIndex) {
            yAccessor.forEach(function (actualYAccessor, yIndex) {
                points.forEach(function (d, i) {
                    var x = actualXAccessor(d, i);
                    var y = actualYAccessor(d, i);
                    var projectedPoint = { x: x, y: y, data: d, xIndex: xIndex, yIndex: yIndex };
                    if (Array.isArray(y)) {
                        projectedPoint[coordinateNames_1.projectedYBottom] = Math.min.apply(Math, __spread(y));
                        projectedPoint[coordinateNames_1.projectedYTop] = Math.max.apply(Math, __spread(y));
                        projectedPoint[coordinateNames_1.projectedYMiddle] =
                            (projectedPoint[coordinateNames_1.projectedYBottom] +
                                projectedPoint[coordinateNames_1.projectedYTop]) /
                                2;
                    }
                    if (Array.isArray(x)) {
                        projectedPoint[coordinateNames_1.projectedXBottom] = Math.min.apply(Math, __spread(x));
                        projectedPoint[coordinateNames_1.projectedXTop] = Math.max.apply(Math, __spread(x));
                        projectedPoint[coordinateNames_1.projectedXMiddle] =
                            (projectedPoint[coordinateNames_1.projectedXBottom] +
                                projectedPoint[coordinateNames_1.projectedXTop]) /
                                2;
                    }
                    projectedPoints.push(projectedPoint);
                });
            });
        });
        fullDataset = __spread(projectedPoints.map(function (d) {
            var _a;
            return (__assign(__assign({}, d), (_a = {}, _a[coordinateNames_1.projectedX] = d[coordinateNames_1.projectedXTop] || d[coordinateNames_1.projectedXBottom] || d.x, _a[coordinateNames_1.projectedY] = d[coordinateNames_1.projectedYTop] || d[coordinateNames_1.projectedYBottom] || d.y, _a)));
        }));
    }
    if (lines) {
        initialProjectedLines = lineDrawing_1.projectLineData({
            data: lines,
            lineDataAccessor: lineDataAccessor,
            xProp: coordinateNames_1.projectedX,
            xPropTop: coordinateNames_1.projectedXTop,
            xPropBottom: coordinateNames_1.projectedXBottom,
            yProp: coordinateNames_1.projectedY,
            yPropTop: coordinateNames_1.projectedYTop,
            yPropBottom: coordinateNames_1.projectedYBottom,
            xAccessor: xAccessor,
            yAccessor: yAccessor
        });
        var optionsObject = {
            xProp: coordinateNames_1.projectedX,
            yProp: coordinateNames_1.projectedY,
            yPropMiddle: coordinateNames_1.projectedYMiddle,
            yPropTop: coordinateNames_1.projectedYTop,
            yPropBottom: coordinateNames_1.projectedYBottom,
            xPropMiddle: coordinateNames_1.projectedXMiddle,
            xPropTop: coordinateNames_1.projectedXTop,
            xPropBottom: coordinateNames_1.projectedXBottom
        };
        projectedLines = lineTransformation(lineType, optionsObject)(initialProjectedLines);
        projectedLines.forEach(function (d) {
            fullDataset = __spread(fullDataset, d.data
                .filter(function (p, q) { return defined(Object.assign({}, p.data, p), q); })
                .map(function (p) {
                var mappedP = {
                    parentLine: d,
                    y: p.y,
                    x: p.x,
                    xTop: p.xTop,
                    xMiddle: p.xMiddle,
                    xBottom: p.xBottom,
                    yTop: p.yTop,
                    yMiddle: p.yMiddle,
                    yBottom: p.yBottom,
                    data: p.data
                };
                if (p.percent) {
                    mappedP.percent = p.percent;
                }
                return mappedP;
            }));
        });
        if (showLinePoints) {
            var whichPointsX_1 = showLinePoints === true
                ? coordinateNames_1.projectedXMiddle
                : whichPointsHashX[showLinePoints];
            var whichPointsY_1 = showLinePoints === true
                ? coordinateNames_1.projectedYMiddle
                : whichPointsHashY[showLinePoints];
            projectedLines.forEach(function (d) {
                d.data
                    .filter(function (p, q) {
                    var isDefined = defined(Object.assign({}, p.data, p));
                    if (isDefined) {
                        if (showLinePoints === "orphan") {
                            var prePoint = d.data[q - 1];
                            var postPoint = d.data[q + 1];
                            if ((!prePoint ||
                                !defined(Object.assign({}, prePoint.data, prePoint))) &&
                                (!postPoint ||
                                    !defined(Object.assign({}, postPoint.data, postPoint)))) {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                })
                    .forEach(function (p) {
                    var _a;
                    projectedPoints.push(__assign(__assign({}, p), (_a = { parentLine: d }, _a[coordinateNames_1.projectedY] = p[whichPointsY_1] !== undefined
                        ? p[whichPointsY_1]
                        : p[coordinateNames_1.projectedYMiddle] !== undefined
                            ? p[coordinateNames_1.projectedYMiddle]
                            : p[coordinateNames_1.projectedYBottom] !== undefined
                                ? p[coordinateNames_1.projectedYBottom]
                                : p.y, _a[coordinateNames_1.projectedX] = p[whichPointsX_1] !== undefined
                        ? p[whichPointsX_1]
                        : p[coordinateNames_1.projectedXMiddle] !== undefined
                            ? p[coordinateNames_1.projectedXMiddle]
                            : p[coordinateNames_1.projectedXBottom] !== undefined
                                ? p[coordinateNames_1.projectedXBottom]
                                : p.y, _a)));
                });
            });
        }
    }
    if (summaries) {
        projectedSummaries = lineDrawing_1.projectSummaryData({
            data: summaries,
            summaryDataAccessor: summaryDataAccessor,
            xAccessor: xAccessor,
            yAccessor: yAccessor
        });
        projectedSummaries.forEach(function (d) {
            var baseData = d._baseData;
            if (d._xyfCoordinates.length > 0 && d._xyfCoordinates[0][0][0]) {
                d._xyfCoordinates[0].forEach(function (multi) {
                    if (Array.isArray(multi)) {
                        multi
                            .map(function (p, q) {
                            var _a;
                            return Object.assign({ parentSummary: d }, baseData[q], (_a = {},
                                _a[coordinateNames_1.projectedX] = p[0],
                                _a[coordinateNames_1.projectedY] = p[1],
                                _a));
                        })
                            .forEach(function (e) {
                            var _a;
                            if (showSummaryPoints) {
                                projectedPoints.push(__assign(__assign({ x: 0 }, e), (_a = {}, _a[coordinateNames_1.projectedY] = e[coordinateNames_1.projectedYTop] || e[coordinateNames_1.projectedYBottom] || e[coordinateNames_1.projectedY], _a)));
                            }
                            fullDataset.push(__assign({ x: 0, y: 0 }, e));
                        });
                    }
                });
            }
            else if (d._xyfCoordinates.length > 0) {
                if (Array.isArray(d._xyfCoordinates)) {
                    var coordArray = d._xyfCoordinates;
                    coordArray
                        .map(function (p, q) {
                        var _a;
                        return (__assign(__assign({ parentSummary: d }, baseData[q]), (_a = {}, _a[coordinateNames_1.projectedX] = p[0], _a[coordinateNames_1.projectedY] = p[1], _a)));
                    })
                        .forEach(function (e) {
                        var _a;
                        if (showSummaryPoints) {
                            projectedPoints.push(__assign(__assign({ x: 0 }, e), (_a = {}, _a[coordinateNames_1.projectedY] = e[coordinateNames_1.projectedYTop] || e[coordinateNames_1.projectedYBottom] || e[coordinateNames_1.projectedY], _a)));
                        }
                        fullDataset.push(__assign({ x: 0, y: 0 }, e));
                    });
                }
            }
        });
    }
    var suitableXAnnotations = [];
    var suitableYAnnotations = [];
    if (xExtent &&
        !Array.isArray(xExtent) &&
        xExtent.includeAnnotations === true) {
        xAccessor.forEach(function (actualXAccessor) {
            annotations.forEach(function (annotation, annotationIndex) {
                var _a;
                var x = actualXAccessor(annotation, annotationIndex);
                if (isFinite(x)) {
                    suitableXAnnotations.push((_a = {},
                        _a[coordinateNames_1.projectedX] = x,
                        _a));
                }
            });
        });
    }
    if (yExtent &&
        !Array.isArray(yExtent) &&
        yExtent.includeAnnotations === true) {
        yAccessor.forEach(function (actualYAccessor) {
            annotations.forEach(function (annotation, annotationIndex) {
                var _a;
                var y = actualYAccessor(annotation, annotationIndex);
                if (isFinite(y)) {
                    suitableYAnnotations.push((_a = {},
                        _a[coordinateNames_1.projectedY] = y,
                        _a));
                }
            });
        });
    }
    var dataForXExtent = __spread(fullDataset, suitableXAnnotations);
    var dataForYExtent = __spread(fullDataset, suitableYAnnotations);
    var calculatedXExtent = [
        d3_array_1.min(dataForXExtent.map(function (d) {
            return d[coordinateNames_1.projectedXBottom] === undefined
                ? d[coordinateNames_1.projectedX]
                : Math.min(d[coordinateNames_1.projectedXTop], d[coordinateNames_1.projectedXBottom]);
        })),
        d3_array_1.max(dataForXExtent.map(function (d) {
            return d[coordinateNames_1.projectedXTop] === undefined
                ? d[coordinateNames_1.projectedX]
                : Math.max(d[coordinateNames_1.projectedXBottom], d[coordinateNames_1.projectedXTop]);
        }))
    ];
    var calculatedYExtent = [
        d3_array_1.min(dataForYExtent.map(function (d) {
            return d[coordinateNames_1.projectedYBottom] === undefined
                ? d[coordinateNames_1.projectedY]
                : Math.min(d[coordinateNames_1.projectedYTop], d[coordinateNames_1.projectedYBottom]);
        })),
        d3_array_1.max(dataForYExtent.map(function (d) {
            return d[coordinateNames_1.projectedYTop] === undefined
                ? d[coordinateNames_1.projectedY]
                : Math.max(d[coordinateNames_1.projectedYBottom], d[coordinateNames_1.projectedYTop]);
        }))
    ];
    var actualXExtent = unflowedFunctions_1.extentValue(xExtent);
    var actualYExtent = unflowedFunctions_1.extentValue(yExtent);
    var xMin = actualXExtent && actualXExtent[0] !== undefined
        ? actualXExtent[0]
        : calculatedXExtent[0];
    var xMax = actualXExtent && actualXExtent[1] !== undefined
        ? actualXExtent[1]
        : calculatedXExtent[1];
    var yMin = actualYExtent && actualYExtent[0] !== undefined
        ? actualYExtent[0]
        : calculatedYExtent[0];
    var yMax = actualYExtent && actualYExtent[1] !== undefined
        ? actualYExtent[1]
        : calculatedYExtent[1];
    var finalYExtent = [yMin, yMax];
    var finalXExtent = [xMin, xMax];
    if (invertX && !(actualXExtent && actualXExtent.length === 2)) {
        finalXExtent = [finalXExtent[1], finalXExtent[0]];
    }
    if ((lineType.type === "bumpline" || invertY) &&
        !(actualYExtent && actualYExtent.length === 2)) {
        finalYExtent = [finalYExtent[1], finalYExtent[0]];
    }
    if (summaryType.type && summaryType.type === "contour") {
        projectedSummaries = areaDrawing_1.contouring({
            summaryType: summaryType,
            data: projectedSummaries,
            finalXExtent: finalXExtent,
            finalYExtent: finalYExtent
        });
    }
    else if (summaryType.type && summaryType.type === "linebounds") {
        projectedSummaries = areaDrawing_1.lineBounding({
            summaryType: summaryType,
            data: projectedSummaries,
            defined: defined
        });
    }
    else if (summaryType.type && summaryType.type === "hexbin") {
        projectedSummaries = areaDrawing_1.hexbinning({
            summaryType: summaryType,
            data: projectedSummaries[0],
            processedData: summaries && !!summaries[0].processedData,
            preprocess: false,
            finalXExtent: finalXExtent,
            finalYExtent: finalYExtent,
            size: size,
            margin: margin,
            baseMarkProps: baseMarkProps,
            styleFn: summaryStyleFn,
            classFn: summaryClassFn,
            renderFn: summaryRenderModeFn,
            chartSize: chartSize
        });
        fullDataset = __spread(projectedSummaries.map(function (d) { return (__assign({}, d)); }), fullDataset.filter(function (d) { return !d.parentSummary; }));
    }
    else if (summaryType.type && summaryType.type === "heatmap") {
        projectedSummaries = areaDrawing_1.heatmapping({
            summaryType: summaryType,
            data: projectedSummaries[0],
            processedData: summaries && !!summaries[0].processedData,
            preprocess: false,
            finalXExtent: finalXExtent,
            finalYExtent: finalYExtent,
            size: size,
            margin: margin,
            baseMarkProps: baseMarkProps,
            styleFn: summaryStyleFn,
            classFn: summaryClassFn,
            renderFn: summaryRenderModeFn,
            chartSize: chartSize
        });
        fullDataset = __spread(projectedSummaries.map(function (d) { return (__assign({}, d)); }), fullDataset.filter(function (d) { return !d.parentSummary; }));
    }
    else if (summaryType.type && summaryType.type === "trendline") {
        projectedSummaries = areaDrawing_1.trendlining({
            summaryType: summaryType,
            data: projectedSummaries[0],
            preprocess: summaries && !!summaries[0].processedData,
            finalXExtent: finalXExtent
        });
        fullDataset = __spread(projectedSummaries.map(function (d) { return (__assign({}, d)); }), fullDataset.filter(function (d) { return !d.parentSummary; }));
    }
    if (filterRenderedLines) {
        projectedLines = projectedLines.filter(filterRenderedLines);
        fullDataset = fullDataset.filter(function (d, i) {
            return !d.parentLine || filterRenderedLines(d.parentLine, i, []);
        });
    }
    if (filterRenderedPoints) {
        fullDataset = fullDataset.filter(filterRenderedPoints);
    }
    if (filterRenderedSummaries) {
        projectedSummaries = projectedSummaries.filter(filterRenderedSummaries);
        fullDataset = fullDataset.filter(function (d, i) {
            return !d.parentSummary || filterRenderedSummaries(d.parentSummary, i, []);
        });
    }
    return {
        xExtent: finalXExtent,
        yExtent: finalYExtent,
        projectedLines: projectedLines,
        projectedPoints: projectedPoints,
        projectedSummaries: projectedSummaries,
        fullDataset: fullDataset,
        calculatedXExtent: calculatedXExtent,
        calculatedYExtent: calculatedYExtent
    };
};
var differenceCatch = function (olineType, data) {
    return olineType === "difference" && data.length !== 2 ? "line" : olineType;
};
function lineTransformation(lineType, options) {
    return function (data) {
        return builtInTransformations[differenceCatch(lineType.type, data)](__assign(__assign(__assign({}, lineType), options), { data: data }));
    };
}


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var allFrameDefaults = {
    margin: 0
};
function sparkNetworkSettings(originalSettings) {
    if (originalSettings === void 0) { originalSettings = "force"; }
    var finalSettings = {};
    if (originalSettings) {
        finalSettings = originalSettings;
        if (originalSettings === "force")
            finalSettings = { type: "force" };
        return __assign({ edgeStrength: 2, edgeDistance: 5, nodePadding: 1, nodeWidth: 5, groupWidth: 4 }, finalSettings);
    }
    return originalSettings;
}
var createSparkFrame = function (Frame, defaults, frameName) { var _a; return _a = /** @class */ (function (_super) {
        __extends(SparkFrame, _super);
        function SparkFrame(props) {
            var _this = _super.call(this, props) || this;
            _this.node = null;
            _this._onResize = function (width, height) {
                _this.setState({ containerHeight: height, containerWidth: width });
            };
            _this.state = {
                containerHeight: props.size[1],
                containerWidth: props.size[0]
            };
            return _this;
        }
        SparkFrame.prototype.componentDidMount = function () {
            var element = this.node;
            var lineHeight = +window.getComputedStyle(element).lineHeight.split("px")[0] - 5;
            this.setState({
                containerHeight: isNaN(lineHeight) ? element.offsetHeight : lineHeight,
                containerWidth: element.offsetWidth
            });
        };
        SparkFrame.prototype.render = function () {
            var _this = this;
            var _a = this.props, size = _a.size, _b = _a.sparkStyle, sparkStyle = _b === void 0 ? {} : _b;
            var _c = this.state.containerHeight, containerHeight = _c === void 0 ? 30 : _c;
            var actualSize = [];
            actualSize[0] =
                typeof size === "number" ? size : size[0] ? size[0] : containerHeight;
            actualSize[1] = containerHeight;
            return (React.createElement("span", { style: Object.assign({
                    width: actualSize[0] + "px",
                    height: actualSize[1] + "px",
                    display: "inline-block",
                    marginLeft: "5px",
                    marginRight: "5px"
                }, sparkStyle), ref: function (node) { return (_this.node = node); } },
                React.createElement(Frame, __assign({}, defaults(this.props), { size: actualSize, useSpans: true }))));
        };
        return SparkFrame;
    }(React.Component)),
    _a.displayName = frameName,
    _a.defaultProps = {
        size: []
    },
    _a; };
exports.axisDefaults = {
    tickFormat: function () { return ""; },
    baseline: false
};
exports.xyFrameDefaults = function (props) { return (__assign(__assign(__assign({}, allFrameDefaults), props), { hoverAnnotation: props.hoverAnnotation, axes: props.axes
        ? props.axes.map(function (a) { return (__assign(__assign({}, exports.axisDefaults), a)); })
        : props.axes })); };
exports.ordinalFrameDefaults = function (props) { return (__assign(__assign(__assign({}, allFrameDefaults), props), { hoverAnnotation: props.hoverAnnotation, axes: props.axes
        ? props.axes.map(function (a) { return (__assign(__assign({}, exports.axisDefaults), a)); })
        : props.axes })); };
exports.networkFrameDefaults = function (props) { return (__assign(__assign(__assign(__assign({}, allFrameDefaults), { nodeSizeAccessor: 2 }), props), { networkType: sparkNetworkSettings(props.networkType) })); };
exports.default = createSparkFrame;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(140),
    isLength = __webpack_require__(136);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    step = -step;
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bisectLeft; });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);



var ascendingBisect = Object(_bisector_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_ascending_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["c"] = (bisectRight);


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function none() {}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);


/* harmony default export */ __webpack_exports__["a"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"][prefix], local: name} : name;
});


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["b"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(105);
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(107);
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(64);
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39);










/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* default */ "e"])(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]) : _string_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__[/* default */ "e"] ? _rgb_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]
      : Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_8__[/* isNumberArray */ "b"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"]
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_2__[/* genericArray */ "b"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]
      : _number_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(a, b);
});


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);


/* harmony default export */ __webpack_exports__["a"] = (function() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__[/* event */ "c"], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(244);
} else {}


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Handle;

var _react = _interopRequireDefault(__webpack_require__(0));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchemove",
    stop: "touchend"
  }
};
var listenerOptions = {
  passive: false
};

var makeHandler = function makeHandler(type, handleStart, handleStop, handleDrag) {
  return function (e) {
    e.preventDefault();
    var xDim = "clientX";
    var yDim = "clientY";
    var oX = e.nativeEvent[xDim];
    var oY = e.nativeEvent[yDim];
    var x = oX;
    var y = oY;
    handleStart && handleStart();

    var move = function move(d) {
      d.preventDefault();
      handleDrag && handleDrag(d, {
        deltaX: d[xDim] - x,
        deltaY: d[yDim] - y,
        oDeltaX: d[xDim] - oX,
        oDeltaY: d[yDim] - oY
      });
      x = d[xDim];
      y = d[yDim];
    };

    var stop = function stop(e) {
      e.preventDefault();
      document.removeEventListener(events[type].move, move, listenerOptions);
      document.removeEventListener(events[type].stop, stop, listenerOptions);
      handleStop && handleStop();
    };

    document.addEventListener(events[type].move, move, listenerOptions);
    document.addEventListener(events[type].stop, stop, listenerOptions);
  };
};

function Handle(_ref) {
  var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 0 : _ref$y,
      _ref$r = _ref.r,
      r = _ref$r === void 0 ? 10 : _ref$r,
      handleStart = _ref.handleStart,
      handleStop = _ref.handleStop,
      handleDrag = _ref.handleDrag;
  return _react.default.createElement("circle", {
    className: "handle",
    cx: x,
    cy: y,
    r: r,
    onMouseDown: makeHandler("mouse", handleStart, handleStop, handleDrag),
    onTouchStart: makeHandler("touch", handleStart, handleStop, handleDrag),
    strokeDasharray: "5",
    stroke: "grey",
    fill: "white",
    fillOpacity: 0
  });
}

Handle.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  r: _propTypes.default.number,
  handleStart: _propTypes.default.func,
  handleStop: _propTypes.default.func,
  handleDrag: _propTypes.default.func
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _typeElbow = _interopRequireDefault(__webpack_require__(257));

var _Connector2 = _interopRequireDefault(__webpack_require__(117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorElbow =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorElbow, _Connector);

  function ConnectorElbow() {
    _classCallCheck(this, ConnectorElbow);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorElbow).apply(this, arguments));
  }

  _createClass(ConnectorElbow, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          radius = _ref.radius,
          radiusPadding = _ref.radiusPadding,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height;
      return (0, _typeElbow.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        radiusPadding: radiusPadding,
        outerRadius: outerRadius,
        width: width,
        height: height
      });
    }
  }]);

  return ConnectorElbow;
}(_Connector2.default);

exports.default = ConnectorElbow;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var d3_array_1 = __webpack_require__(3);
var multiAccessorUtils_1 = __webpack_require__(69);
var datesForUnique = function (d) { return (d instanceof Date ? d.getTime() : d); };
exports.projectSummaryData = function (_a) {
    var data = _a.data, summaryDataAccessor = _a.summaryDataAccessor, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor;
    var projectedData = [];
    summaryDataAccessor.forEach(function (actualSummaryAccessor) {
        xAccessor.forEach(function (actualXAccessor) {
            yAccessor.forEach(function (actualYAccessor) {
                var projection = function (d) {
                    return actualSummaryAccessor(d).map(function (p, q) { return [
                        actualXAccessor(p, q),
                        actualYAccessor(p, q)
                    ]; });
                };
                data.forEach(function (d) {
                    projectedData.push(__assign(__assign({}, d), { _baseData: actualSummaryAccessor(d), _xyfCoordinates: projection(d) }));
                });
            });
        });
    });
    return projectedData;
};
exports.projectLineData = function (_a) {
    var data = _a.data, lineDataAccessor = _a.lineDataAccessor, xProp = _a.xProp, xPropTop = _a.xPropTop, xPropBottom = _a.xPropBottom, yProp = _a.yProp, yPropTop = _a.yPropTop, yPropBottom = _a.yPropBottom, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor;
    if (!Array.isArray(data)) {
        data = [data];
    }
    var projectedLine = [];
    lineDataAccessor.forEach(function (actualLineAccessor, lineIndex) {
        xAccessor.forEach(function (actualXAccessor, xIndex) {
            yAccessor.forEach(function (actualYAccessor, yIndex) {
                data.forEach(function (d) {
                    var originalLineData = __assign(__assign({}, d), { xIndex: xIndex, yIndex: yIndex, lineIndex: lineIndex });
                    originalLineData.data = actualLineAccessor(d).map(function (p, q) {
                        var originalCoords = { data: p };
                        originalCoords[xProp] = actualXAccessor(p, q);
                        originalCoords[xPropTop] = originalCoords[xProp];
                        originalCoords[xPropBottom] = originalCoords[xProp];
                        originalCoords[yProp] = actualYAccessor(p, q);
                        originalCoords[yPropTop] = originalCoords[yProp];
                        originalCoords[yPropBottom] = originalCoords[yProp];
                        return originalCoords;
                    });
                    originalLineData.key = originalLineData.key || projectedLine.length;
                    projectedLine.push(originalLineData);
                });
            });
        });
    });
    return projectedLine;
};
exports.differenceLine = function (_a) {
    var data = _a.data, yProp = _a.yProp, yPropTop = _a.yPropTop, yPropBottom = _a.yPropBottom;
    data.forEach(function (l, i) {
        l.data.forEach(function (point, q) {
            var otherLine = i === 0 ? 1 : 0;
            if (point[yProp] > data[otherLine].data[q][yProp]) {
                point[yPropBottom] = data[otherLine].data[q][yProp];
                point[yPropTop] = point[yProp];
            }
            else {
                point[yPropTop] = point[yProp];
                point[yPropBottom] = point[yProp];
            }
        });
    });
    return data;
};
exports.stackedArea = function (_a) {
    var _b = _a.type, type = _b === void 0 ? "stackedarea" : _b, data = _a.data, xProp = _a.xProp, yProp = _a.yProp, yPropMiddle = _a.yPropMiddle, sort = _a.sort, yPropTop = _a.yPropTop, yPropBottom = _a.yPropBottom;
    var uniqXValues = data
        .map(function (d) { return d.data.map(function (p) { return datesForUnique(p[xProp]); }); })
        .reduce(function (a, b) { return a.concat(b); }, [])
        .reduce(function (p, c) {
        if (p.indexOf(c) === -1) {
            p.push(c);
        }
        return p;
    }, []);
    var stackSort = function (a, b) {
        return d3_array_1.sum(b.data.map(function (p) { return p[yProp]; })) - d3_array_1.sum(a.data.map(function (p) { return p[yProp]; }));
    };
    if (type === "stackedpercent-invert" || type === "stackedarea-invert") {
        stackSort = function (a, b) {
            return d3_array_1.sum(a.data.map(function (p) { return p[yProp]; })) - d3_array_1.sum(b.data.map(function (p) { return p[yProp]; }));
        };
    }
    sort = sort === undefined ? stackSort : sort;
    if (sort !== null) {
        data = data.sort(sort);
    }
    uniqXValues.forEach(function (xValue) {
        var negativeOffset = 0;
        var positiveOffset = 0;
        var stepValues = data
            .map(function (d) { return d.data.filter(function (p) { return datesForUnique(p[xProp]) === xValue; }); })
            .reduce(function (a, b) { return a.concat(b); }, []);
        var positiveStepTotal = d3_array_1.sum(stepValues.map(function (d) { return (d[yProp] > 0 ? d[yProp] : 0); }));
        var negativeStepTotal = d3_array_1.sum(stepValues.map(function (d) { return (d[yProp] < 0 ? d[yProp] : 0); }));
        stepValues.forEach(function (l) {
            if (l[yProp] < 0) {
                if (type === "linepercent" ||
                    type === "stackedpercent" ||
                    type === "stackedpercent-invert") {
                    var percent = l[yProp] / negativeStepTotal;
                    l.percent = percent;
                    if (type === "linepercent") {
                        l[yPropBottom] = l[yPropBottom] = l[yPropTop] = l[yPropMiddle] = percent;
                    }
                    else {
                        var adjustment = negativeStepTotal >= 0 ? 0 : percent;
                        l[yPropBottom] =
                            negativeStepTotal === 0
                                ? 0
                                : -(negativeOffset / negativeStepTotal);
                        l[yPropTop] = l[yPropBottom] - adjustment;
                        l[yPropMiddle] = l[yPropBottom] - adjustment / 2;
                    }
                }
                else {
                    l[yPropBottom] = negativeOffset;
                    l[yPropTop] = negativeOffset + l[yProp];
                    l[yPropMiddle] = negativeOffset + l[yProp] / 2;
                }
                negativeOffset += l[yProp];
            }
            else {
                if (type === "linepercent" ||
                    type === "stackedpercent" ||
                    type === "stackedpercent-invert") {
                    var percent = l[yProp] / positiveStepTotal;
                    l.percent = percent;
                    if (type === "linepercent") {
                        l[yPropBottom] = l[yPropTop] = l[yPropMiddle] = percent;
                    }
                    else {
                        var adjustment = positiveStepTotal <= 0 ? 0 : percent;
                        l[yPropBottom] =
                            positiveStepTotal === 0 ? 0 : positiveOffset / positiveStepTotal;
                        l[yPropTop] = l[yPropBottom] + adjustment;
                        l[yPropMiddle] = l[yPropBottom] + adjustment / 2;
                    }
                }
                else {
                    l[yPropBottom] = positiveOffset;
                    l[yPropTop] = positiveOffset + l[yProp];
                    l[yPropMiddle] = positiveOffset + l[yProp] / 2;
                }
                positiveOffset += l[yProp];
            }
        });
    });
    return data;
};
exports.lineChart = function (_a) {
    var data = _a.data, y1 = _a.y1, x1 = _a.x1, yPropTop = _a.yPropTop, yPropMiddle = _a.yPropMiddle, yPropBottom = _a.yPropBottom, xPropTop = _a.xPropTop, xPropMiddle = _a.xPropMiddle, xPropBottom = _a.xPropBottom;
    if (y1) {
        data.forEach(function (d) {
            d.data.forEach(function (p) {
                p[yPropBottom] = y1(p);
                p[yPropMiddle] = (p[yPropBottom] + p[yPropTop]) / 2;
            });
        });
    }
    if (x1) {
        data.forEach(function (d) {
            d.data.forEach(function (p) {
                p[xPropBottom] = x1(p);
                p[xPropMiddle] = (p[xPropBottom] + p[xPropTop]) / 2;
            });
        });
    }
    return data;
};
exports.cumulativeLine = function (_a) {
    var data = _a.data, y1 = _a.y1, yPropTop = _a.yPropTop, yPropMiddle = _a.yPropMiddle, yPropBottom = _a.yPropBottom, _b = _a.type, type = _b === void 0 ? "cumulative" : _b;
    data.forEach(function (d) {
        var cumulativeValue = 0;
        var dataArray = type === "cumulative-reverse" ? d.data.reverse() : d.data;
        dataArray.forEach(function (p) {
            cumulativeValue += p[yPropTop];
            p[yPropBottom] = p[yPropTop] = p[yPropMiddle] = cumulativeValue;
            if (y1) {
                p[yPropBottom] = y1(p);
                p[yPropMiddle] = p[yPropBottom] + p[yPropTop] / 2;
            }
        });
    });
    return data;
};
exports.bumpChart = function (_a) {
    var _b = _a.type, type = _b === void 0 ? "bumpline" : _b, data = _a.data, xProp = _a.xProp, yProp = _a.yProp, yPropMiddle = _a.yPropMiddle, yPropTop = _a.yPropTop, yPropBottom = _a.yPropBottom;
    var uniqXValues = data
        .map(function (d) { return d.data.map(function (p) { return datesForUnique(p[xProp]); }); })
        .reduce(function (a, b) { return a.concat(b); }, [])
        .reduce(function (p, c) {
        if (p.indexOf(c) === -1) {
            p.push(c);
        }
        return p;
    }, []);
    var bumpSort = function (a, b) {
        if (a[yProp] > b[yProp]) {
            return 1;
        }
        if (a[yProp] < b[yProp]) {
            return -1;
        }
        return -1;
    };
    if (type === "bumparea-invert" || type === "bumpline-invert") {
        bumpSort = function (a, b) {
            if (a[yProp] < b[yProp]) {
                return 1;
            }
            if (a[yProp] > b[yProp]) {
                return -1;
            }
            return -1;
        };
    }
    uniqXValues.forEach(function (xValue) {
        var negativeOffset = 0;
        var positiveOffset = 0;
        data
            .map(function (d) { return d.data.filter(function (p) { return datesForUnique(p[xProp]) === xValue; }); })
            .reduce(function (a, b) { return a.concat(b); }, [])
            .sort(bumpSort)
            .forEach(function (l, rank) {
            //determine ranking and offset by the number of less than this one at each step
            l._XYFrameRank = rank + 1;
            if (type === "bumparea" || type === "bumparea-invert") {
                if (l[yProp] < 0) {
                    l[yPropTop] = negativeOffset + l[yProp];
                    l[yPropMiddle] = negativeOffset + l[yProp] / 2;
                    l[yPropBottom] = negativeOffset;
                    negativeOffset += l[yProp];
                }
                else {
                    l[yPropTop] = positiveOffset + l[yProp];
                    l[yPropMiddle] = positiveOffset + l[yProp] / 2;
                    l[yPropBottom] = positiveOffset;
                    positiveOffset += l[yProp];
                }
            }
            else {
                l[yProp] = rank + 1;
                l[yPropTop] = rank + 1;
                l[yPropBottom] = rank + 1;
            }
        });
    });
    return data;
};
exports.dividedLine = function (parameters, points, searchIterations) {
    if (searchIterations === void 0) { searchIterations = 10; }
    var currentParameters = parameters(points[0], 0);
    var currentPointsArray = [];
    var dividedLinesData = [
        { key: currentParameters, points: currentPointsArray }
    ];
    points.forEach(function (point, pointI) {
        var newParameters = parameters(point, pointI);
        var matchingParams = newParameters === currentParameters;
        var stringNewParams = JSON.stringify(newParameters);
        var stringCurrentParams = JSON.stringify(currentParameters);
        if (typeof currentParameters === "object") {
            matchingParams = stringNewParams === stringCurrentParams;
        }
        if (matchingParams) {
            currentPointsArray.push(point);
        }
        else {
            var lastPoint = currentPointsArray[currentPointsArray.length - 1];
            var pointA = lastPoint;
            var pointB = point;
            var stringBParams = stringNewParams;
            var x = 0;
            while (x < searchIterations && stringNewParams === stringBParams) {
                var keys = Object.keys(pointA);
                var findPoints = simpleSearchFunction({
                    pointA: pointA,
                    pointB: pointB,
                    currentParameters: currentParameters,
                    parameters: parameters,
                    keys: keys
                });
                pointA = findPoints[0];
                pointB = findPoints[1];
                stringBParams = JSON.stringify(parameters(pointB));
                x++;
            }
            currentPointsArray.push(pointB);
            currentPointsArray = [pointB, point];
            dividedLinesData.push({ key: newParameters, points: currentPointsArray });
            currentParameters = newParameters;
        }
    });
    return dividedLinesData;
};
function simpleSearchFunction(_a) {
    var pointA = _a.pointA, pointB = _a.pointB, currentParameters = _a.currentParameters, parameters = _a.parameters, keys = _a.keys;
    var betweenPoint = {};
    keys.forEach(function (key) {
        betweenPoint[key] =
            typeof pointA[key] === "number"
                ? (pointA[key] + pointB[key]) / 2
                : undefined;
    });
    var stringBetween = JSON.stringify(parameters(betweenPoint));
    var stringCurrent = JSON.stringify(currentParameters);
    if (stringBetween === stringCurrent) {
        return [betweenPoint, pointB];
    }
    return [pointA, betweenPoint];
}
function funnelize(_a) {
    var data = _a.data, steps = _a.steps, key = _a.key;
    var funnelData = [];
    if (!Array.isArray(data)) {
        data = [data];
    }
    if (!steps) {
        steps = data.map(function (d) { return Object.keys(d); }).reduce(function (a, b) { return a.concat(b); }, []);
    }
    data.forEach(function (datum, i) {
        var datumKey = key ? datum[key] : i;
        steps.forEach(function (step) {
            var funnelDatum = { funnelKey: datumKey, stepName: "", stepValue: 0 };
            funnelDatum.stepName = step;
            funnelDatum.stepValue = datum[step] ? datum[step] : 0;
            funnelData.push(funnelDatum);
        });
    });
    return funnelData;
}
exports.funnelize = funnelize;
var whichPoint = {
    bottom: "yBottom",
    top: "yTop"
};
function relativeY(_a) {
    var point = _a.point, projectedY = _a.projectedY, yAccessor = _a.yAccessor, yScale = _a.yScale, showLinePoints = _a.showLinePoints;
    var baseData = point &&
        (showLinePoints &&
            showLinePoints !== true &&
            point[whichPoint[showLinePoints]] !== undefined
            ? point[whichPoint[showLinePoints]]
            : point.yMiddle !== undefined
                ? point.yMiddle
                : point[projectedY] !== undefined
                    ? point[projectedY]
                    : multiAccessorUtils_1.findFirstAccessorValue(yAccessor, point));
    if (Array.isArray(baseData)) {
        return baseData.map(function (d) { return yScale(d); });
    }
    return baseData !== undefined ? yScale(baseData) : 0;
}
exports.relativeY = relativeY;
function relativeX(_a) {
    var point = _a.point, projectedXMiddle = _a.projectedXMiddle, projectedX = _a.projectedX, xAccessor = _a.xAccessor, xScale = _a.xScale;
    var baseData = point &&
        (point[projectedXMiddle] !== undefined
            ? point[projectedXMiddle]
            : point[projectedX] !== undefined
                ? point[projectedX]
                : multiAccessorUtils_1.findFirstAccessorValue(xAccessor, point));
    if (Array.isArray(baseData)) {
        return baseData.map(function (d) { return xScale(d); });
    }
    return baseData !== undefined ? xScale(baseData) : 0;
}
exports.relativeX = relativeX;
function findPointByID(_a) {
    var point = _a.point, idAccessor = _a.idAccessor, lines = _a.lines, xScale = _a.xScale, projectedX = _a.projectedX, xAccessor = _a.xAccessor;
    var pointID = idAccessor(point.parentLine || point);
    if (pointID) {
        var thisLine = lines.data.find(function (l) { return idAccessor(l) === pointID; });
        if (!thisLine) {
            return null;
        }
        var pointX_1 = xScale(multiAccessorUtils_1.findFirstAccessorValue(xAccessor, point));
        var thisPoint = thisLine.data.find(function (p) { return xScale(p[projectedX]) === pointX_1; });
        if (!thisPoint) {
            return null;
        }
        var newPoint_1 = __assign(__assign(__assign(__assign({}, point), thisPoint), thisPoint.data), { parentLine: thisLine });
        var reactAnnotationProps = [
            "type",
            "label",
            "note",
            "connector",
            "disabled",
            "color",
            "subject"
        ];
        reactAnnotationProps.forEach(function (prop) {
            if (point[prop])
                newPoint_1[prop] = point[prop];
        });
        return newPoint_1;
    }
    return point;
}
exports.findPointByID = findPointByID;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.findFirstAccessorValue = function (accessorArray, data) {
    for (var i = 0; i < accessorArray.length; i++) {
        var valueCheck = accessorArray[i](data);
        if (valueCheck !== undefined &&
            !Number.isNaN(valueCheck) &&
            valueCheck !== null)
            return valueCheck;
    }
    return undefined;
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_scale_1 = __webpack_require__(24);
// components
var Frame_1 = __importDefault(__webpack_require__(120));
var TooltipPositioner_1 = __importDefault(__webpack_require__(124));
var xyframeRules_1 = __webpack_require__(276);
var baseRules_1 = __webpack_require__(51);
var lineDrawing_1 = __webpack_require__(68);
var frameFunctions_1 = __webpack_require__(33);
var coordinateNames_1 = __webpack_require__(121);
var unflowedFunctions_1 = __webpack_require__(178);
var diffing_1 = __webpack_require__(297);
var multiAccessorUtils_1 = __webpack_require__(69);
var xyDrawing_1 = __webpack_require__(298);
var frame_props_1 = __webpack_require__(127);
var SpanOrDiv_1 = __webpack_require__(41);
var xyframeKey = "";
var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (var i = 32; i > 0; --i)
    xyframeKey += chars[Math.floor(Math.random() * chars.length)];
var projectedCoordinateNames = {
    y: coordinateNames_1.projectedY,
    x: coordinateNames_1.projectedX,
    yMiddle: coordinateNames_1.projectedYMiddle,
    yTop: coordinateNames_1.projectedYTop,
    yBottom: coordinateNames_1.projectedYBottom,
    xMiddle: coordinateNames_1.projectedXMiddle,
    xTop: coordinateNames_1.projectedXTop,
    xBottom: coordinateNames_1.projectedXBottom
};
var XYFrame = /** @class */ (function (_super) {
    __extends(XYFrame, _super);
    function XYFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.defaultXYSVGRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer, lines = _a.lines, summaries = _a.summaries, points = _a.points;
            var _b = _this.props, showLinePoints = _b.showLinePoints, defined = _b.defined, baseMargin = _b.margin, size = _b.size, svgAnnotationRules = _b.svgAnnotationRules;
            var _c = _this.state, xyFrameRender = _c.xyFrameRender, xScale = _c.xScale, yScale = _c.yScale, xAccessor = _c.xAccessor, yAccessor = _c.yAccessor, axesData = _c.axesData, annotatedSettings = _c.annotatedSettings;
            var screenCoordinates = [];
            var idAccessor = annotatedSettings.lineIDAccessor;
            if (baseD.type === "highlight") {
                return xyframeRules_1.svgHighlight({
                    d: baseD,
                    i: i,
                    idAccessor: idAccessor,
                    lines: lines,
                    summaries: summaries,
                    points: points,
                    xScale: xScale,
                    yScale: yScale,
                    xyFrameRender: xyFrameRender,
                    defined: defined
                });
            }
            var d = baseD.coordinates
                ? baseD
                : lineDrawing_1.findPointByID({
                    point: baseD,
                    idAccessor: idAccessor,
                    lines: lines,
                    xScale: xScale,
                    projectedX: coordinateNames_1.projectedX,
                    xAccessor: xAccessor
                });
            if (!d)
                return null;
            var margin = frameFunctions_1.calculateMargin({
                margin: baseMargin,
                axes: axesData,
                title: annotatedSettings.title,
                size: size
            });
            var _d = frameFunctions_1.adjustedPositionSize({
                size: size,
                margin: margin
            }), adjustedPosition = _d.adjustedPosition, adjustedSize = _d.adjustedSize;
            if (!d.coordinates && !d.bounds) {
                screenCoordinates = [
                    lineDrawing_1.relativeX({
                        point: d,
                        projectedXMiddle: coordinateNames_1.projectedXMiddle,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor,
                        xScale: xScale
                    }) || 0,
                    lineDrawing_1.relativeY({
                        point: d,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        yAccessor: yAccessor,
                        yScale: yScale,
                        showLinePoints: showLinePoints
                    }) || 0
                ];
            }
            else if (!d.bounds) {
                screenCoordinates = d.coordinates.reduce(function (coords, p) {
                    var xCoordinate = lineDrawing_1.relativeX({
                        point: p,
                        projectedXMiddle: coordinateNames_1.projectedXMiddle,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor,
                        xScale: xScale
                    });
                    var yCoordinate = lineDrawing_1.relativeY({
                        point: p,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        yAccessor: yAccessor,
                        yScale: yScale
                    });
                    if (Array.isArray(yCoordinate)) {
                        return __spread(coords, [
                            [xCoordinate, Math.min.apply(Math, __spread(yCoordinate))],
                            [xCoordinate, Math.max.apply(Math, __spread(yCoordinate))]
                        ]);
                    }
                    else if (Array.isArray(xCoordinate)) {
                        return __spread(coords, [
                            [Math.min.apply(Math, __spread(xCoordinate)), yCoordinate],
                            [Math.max.apply(Math, __spread(xCoordinate)), yCoordinate]
                        ]);
                    }
                    else {
                        return __spread(coords, [[xCoordinate, yCoordinate]]);
                    }
                }, []);
            }
            var voronoiHover = annotationLayer.voronoiHover;
            var customSVG = svgAnnotationRules &&
                svgAnnotationRules({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    xScale: xScale,
                    yScale: yScale,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xyFrameProps: _this.props,
                    xyFrameState: _this.state,
                    summaries: summaries,
                    points: points,
                    lines: lines,
                    voronoiHover: voronoiHover,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
            if (svgAnnotationRules !== undefined && customSVG !== null) {
                return customSVG;
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "xy" || d.type === "frame-hover") {
                return xyframeRules_1.svgXYAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return xyframeRules_1.basicReactAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose") {
                return xyframeRules_1.svgEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose-rect") {
                return xyframeRules_1.svgRectEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose-hull") {
                return xyframeRules_1.svgHullEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "x") {
                return xyframeRules_1.svgXAnnotation({
                    d: d,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    adjustedSize: adjustedSize
                });
            }
            else if (d.type === "y") {
                return xyframeRules_1.svgYAnnotation({
                    d: d,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    adjustedSize: adjustedSize,
                    adjustedPosition: adjustedPosition
                });
            }
            else if (d.type === "bounds") {
                return xyframeRules_1.svgBoundsAnnotation({
                    d: d,
                    i: i,
                    adjustedSize: adjustedSize,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xScale: xScale,
                    yScale: yScale
                });
            }
            else if (d.type === "line") {
                return xyframeRules_1.svgLineAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "area") {
                return xyframeRules_1.svgAreaAnnotation({
                    d: d,
                    i: i,
                    xScale: xScale,
                    xAccessor: xAccessor,
                    yScale: yScale,
                    yAccessor: yAccessor,
                    annotationLayer: annotationLayer
                });
            }
            else if (d.type === "horizontal-points") {
                return xyframeRules_1.svgHorizontalPointsAnnotation({
                    d: d,
                    lines: lines.data,
                    points: points.data,
                    xScale: xScale,
                    yScale: yScale,
                    pointStyle: points.styleFn
                });
            }
            else if (d.type === "vertical-points") {
                return xyframeRules_1.svgVerticalPointsAnnotation({
                    d: d,
                    lines: lines.data,
                    points: points.data,
                    xScale: xScale,
                    yScale: yScale,
                    pointStyle: points.styleFn
                });
            }
            return null;
        };
        _this.defaultXYHTMLRule = function (_a) {
            var baseD = _a.d, i = _a.i, lines = _a.lines, summaries = _a.summaries, points = _a.points, annotationLayer = _a.annotationLayer;
            var _b = _this.state, xAccessor = _b.xAccessor, yAccessor = _b.yAccessor, xScale = _b.xScale, yScale = _b.yScale, SpanOrDiv = _b.SpanOrDiv, annotatedSettings = _b.annotatedSettings, axesData = _b.axesData;
            var voronoiHover = annotationLayer.voronoiHover;
            var screenCoordinates = [];
            var _c = _this.props, useSpans = _c.useSpans, tooltipContent = _c.tooltipContent, optimizeCustomTooltipPosition = _c.optimizeCustomTooltipPosition, htmlAnnotationRules = _c.htmlAnnotationRules, size = _c.size, showLinePoints = _c.showLinePoints, baseMargin = _c.margin;
            var idAccessor = annotatedSettings.lineIDAccessor;
            var d = lineDrawing_1.findPointByID({
                point: baseD,
                idAccessor: idAccessor,
                lines: lines,
                xScale: xScale,
                projectedX: coordinateNames_1.projectedX,
                xAccessor: xAccessor
            });
            if (!d) {
                return null;
            }
            var xCoord = d[coordinateNames_1.projectedXMiddle] ||
                d[coordinateNames_1.projectedX] ||
                multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d);
            var yCoord = d[coordinateNames_1.projectedYMiddle] ||
                d[coordinateNames_1.projectedY] ||
                multiAccessorUtils_1.findFirstAccessorValue(yAccessor, d);
            var xString = xCoord && xCoord.toString ? xCoord.toString() : xCoord;
            var yString = yCoord && yCoord.toString ? yCoord.toString() : yCoord;
            var margin = frameFunctions_1.calculateMargin({
                margin: baseMargin,
                axes: axesData,
                title: annotatedSettings.title,
                size: size
            });
            var _d = frameFunctions_1.adjustedPositionSize({
                size: size,
                margin: margin
            }), adjustedPosition = _d.adjustedPosition, adjustedSize = _d.adjustedSize;
            if (!d.coordinates) {
                screenCoordinates = [
                    xScale(xCoord) || 0,
                    lineDrawing_1.relativeY({
                        point: d,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        showLinePoints: showLinePoints,
                        yAccessor: yAccessor,
                        yScale: yScale
                    }) || 0
                ];
            }
            else {
                screenCoordinates = d.coordinates.map(function (p) {
                    var foundP = lineDrawing_1.findPointByID({
                        point: __assign({ x: 0, y: 0 }, p),
                        idAccessor: idAccessor,
                        lines: lines,
                        xScale: xScale,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor
                    });
                    return [
                        (xScale(multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d)) || 0) +
                            adjustedPosition[0],
                        (lineDrawing_1.relativeY({
                            point: foundP,
                            projectedYMiddle: coordinateNames_1.projectedYMiddle,
                            projectedY: coordinateNames_1.projectedY,
                            yAccessor: yAccessor,
                            yScale: yScale
                        }) || 0) + adjustedPosition[1]
                    ];
                });
            }
            var customAnnotation = htmlAnnotationRules &&
                htmlAnnotationRules({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    xScale: xScale,
                    yScale: yScale,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xyFrameProps: _this.props,
                    xyFrameState: _this.state,
                    summaries: summaries,
                    points: points,
                    lines: lines,
                    voronoiHover: voronoiHover,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
            if (htmlAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            if (d.type === "frame-hover") {
                var content = (React.createElement(SpanOrDiv, { span: useSpans, className: "tooltip-content" },
                    React.createElement("p", { key: "html-annotation-content-1" }, xString),
                    React.createElement("p", { key: "html-annotation-content-2" }, yString),
                    d.percent ? (React.createElement("p", { key: "html-annotation-content-3" },
                        Math.floor(d.percent * 1000) / 10,
                        "%")) : null));
                if (d.type === "frame-hover" && tooltipContent) {
                    content = optimizeCustomTooltipPosition ? (React.createElement(TooltipPositioner_1.default, { tooltipContent: tooltipContent, tooltipContentArgs: d })) : (tooltipContent(d));
                }
                return xyframeRules_1.htmlTooltipAnnotation({
                    content: content,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    d: d,
                    useSpans: useSpans
                });
            }
            return null;
        };
        var baseState = {
            SpanOrDiv: SpanOrDiv_1.HOCSpanOrDiv(props.useSpans),
            size: [500, 500],
            dataVersion: undefined,
            lineData: undefined,
            pointData: undefined,
            summaryData: undefined,
            projectedLines: undefined,
            projectedPoints: undefined,
            projectedSummaries: undefined,
            fullDataset: [],
            adjustedPosition: [0, 0],
            adjustedSize: [500, 500],
            backgroundGraphics: null,
            foregroundGraphics: null,
            axesData: undefined,
            axes: undefined,
            axesTickLines: undefined,
            renderNumber: 0,
            margin: { top: 0, bottom: 0, left: 0, right: 0 },
            calculatedXExtent: [0, 0],
            calculatedYExtent: [0, 0],
            xAccessor: [function (d) { return d.x; }],
            yAccessor: [function (d) { return d.y; }],
            xExtent: [0, 0],
            yExtent: [0, 0],
            areaAnnotations: [],
            xScale: d3_scale_1.scaleLinear(),
            yScale: d3_scale_1.scaleLinear(),
            title: null,
            legendSettings: undefined,
            xyFrameRender: {},
            canvasDrawing: [],
            annotatedSettings: {
                xAccessor: undefined,
                yAccessor: undefined,
                summaryDataAccessor: undefined,
                lineDataAccessor: undefined,
                renderKeyFn: undefined,
                lineType: undefined,
                summaryType: undefined,
                lineIDAccessor: undefined,
                summaries: undefined,
                lines: undefined,
                title: undefined,
                xExtent: undefined,
                yExtent: undefined
            },
            overlay: undefined,
            props: props
        };
        _this.state = __assign(__assign({}, baseState), xyDrawing_1.calculateXYFrame(props, baseState, true));
        return _this;
    }
    XYFrame.prototype.componentWillUnmount = function () {
        var onUnmount = this.props.onUnmount;
        if (onUnmount) {
            onUnmount(this.props, this.state);
        }
    };
    XYFrame.getDerivedStateFromProps = function (nextProps, prevState) {
        var props = prevState.props;
        var _a = prevState.xExtent, oldXExtent = _a === void 0 ? [] : _a, _b = prevState.yExtent, oldYExtent = _b === void 0 ? [] : _b, oldSize = prevState.size, oldDataVersion = prevState.dataVersion, lineData = prevState.lineData, summaryData = prevState.summaryData, pointData = prevState.pointData;
        var baseNewXExtent = nextProps.xExtent, baseNewYExtent = nextProps.yExtent, newSize = nextProps.size, newDataVersion = nextProps.dataVersion, newLines = nextProps.lines, newSummaries = nextProps.summaries, newPoints = nextProps.points;
        var newXExtent = unflowedFunctions_1.extentValue(baseNewXExtent);
        var newYExtent = unflowedFunctions_1.extentValue(baseNewYExtent);
        var extentChange = (oldXExtent[0] !== newXExtent[0] && newXExtent[0] !== undefined) ||
            (oldYExtent[0] !== newYExtent[0] && newYExtent[0] !== undefined) ||
            (oldXExtent[1] !== newXExtent[1] && newXExtent[1] !== undefined) ||
            (oldYExtent[1] !== newYExtent[1] && newYExtent[1] !== undefined);
        var lineChange = diffing_1.basicDataChangeCheck(lineData, newLines);
        var summaryChange = diffing_1.basicDataChangeCheck(summaryData, newSummaries);
        var pointChange = diffing_1.basicDataChangeCheck(pointData, newPoints);
        if ((oldDataVersion && oldDataVersion !== newDataVersion) ||
            !prevState.fullDataset) {
            return xyDrawing_1.calculateXYFrame(nextProps, prevState, true);
        }
        else if (lineChange ||
            summaryChange ||
            pointChange ||
            oldSize[0] !== newSize[0] ||
            oldSize[1] !== newSize[1] ||
            extentChange ||
            (!oldDataVersion &&
                frame_props_1.xyFrameChangeProps.find(function (d) { return props[d] !== nextProps[d]; }))) {
            var dataChanged = lineChange ||
                summaryChange ||
                pointChange ||
                extentChange ||
                !!frame_props_1.xyFrameDataProps.find(function (d) { return diffing_1.basicPropDiffing(props[d], nextProps[d]); });
            return xyDrawing_1.calculateXYFrame(nextProps, prevState, dataChanged);
        }
        return null;
    };
    XYFrame.prototype.render = function () {
        var _a = this.props, size = _a.size, className = _a.className, annotationSettings = _a.annotationSettings, annotations = _a.annotations, additionalDefs = _a.additionalDefs, hoverAnnotation = _a.hoverAnnotation, interaction = _a.interaction, customClickBehavior = _a.customClickBehavior, customHoverBehavior = _a.customHoverBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasSummaries = _a.canvasSummaries, canvasPoints = _a.canvasPoints, canvasLines = _a.canvasLines, afterElements = _a.afterElements, beforeElements = _a.beforeElements, renderOrder = _a.renderOrder, matte = _a.matte, frameKey = _a.frameKey, showLinePoints = _a.showLinePoints, sketchyRenderingEngine = _a.sketchyRenderingEngine, disableContext = _a.disableContext, frameRenderOrder = _a.frameRenderOrder, disableCanvasInteraction = _a.disableCanvasInteraction, interactionSettings = _a.interactionSettings;
        var _b = this.state, backgroundGraphics = _b.backgroundGraphics, foregroundGraphics = _b.foregroundGraphics, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, margin = _b.margin, axes = _b.axes, axesTickLines = _b.axesTickLines, xScale = _b.xScale, yScale = _b.yScale, fullDataset = _b.fullDataset, dataVersion = _b.dataVersion, areaAnnotations = _b.areaAnnotations, legendSettings = _b.legendSettings, xyFrameRender = _b.xyFrameRender, annotatedSettings = _b.annotatedSettings, overlay = _b.overlay;
        return (React.createElement(Frame_1.default, { name: "xyframe", renderPipeline: xyFrameRender, adjustedPosition: adjustedPosition, size: size, projectedCoordinateNames: projectedCoordinateNames, xScale: xScale, yScale: yScale, axes: axes, axesTickLines: axesTickLines, title: annotatedSettings.title, dataVersion: dataVersion, matte: matte, className: className, adjustedSize: adjustedSize, frameKey: frameKey || xyframeKey, additionalDefs: additionalDefs, hoverAnnotation: hoverAnnotation, defaultSVGRule: this.defaultXYSVGRule, defaultHTMLRule: this.defaultXYHTMLRule, annotations: areaAnnotations.length > 0
                ? __spread(annotations, areaAnnotations) : annotations, annotationSettings: annotationSettings, legendSettings: legendSettings, projectedYMiddle: coordinateNames_1.projectedYMiddle, interaction: interaction, customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: fullDataset, showLinePoints: typeof showLinePoints === "string" ? showLinePoints : undefined, margin: margin, backgroundGraphics: backgroundGraphics, foregroundGraphics: foregroundGraphics, beforeElements: beforeElements, afterElements: afterElements, disableContext: disableContext, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, useSpans: useSpans, canvasRendering: !!(canvasSummaries || canvasPoints || canvasLines), renderOrder: renderOrder, overlay: overlay, sketchyRenderingEngine: sketchyRenderingEngine, frameRenderOrder: frameRenderOrder, disableCanvasInteraction: disableCanvasInteraction, interactionSettings: interactionSettings }));
    };
    XYFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: undefined,
        size: [500, 500],
        className: "",
        lineType: "line",
        name: "xyframe",
        dataVersion: undefined
    };
    XYFrame.displayName = "XYFrame";
    return XYFrame;
}(React.Component));
exports.default = XYFrame;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_selection_1 = __webpack_require__(11);
var d3_shape_1 = __webpack_require__(18);
var semiotic_mark_1 = __webpack_require__(15);
var d3_interpolate_1 = __webpack_require__(12);
var emptyObjectReturnFn = function () { return ({}); };
var twoPI = Math.PI * 2;
var dedupeRibbonPoints = function (weight) {
    if (weight === void 0) { weight = 1; }
    return function (p, c) {
        var l = p[p.length - 1];
        if (!l ||
            Math.round(l.x / weight) !== Math.round(c.x / weight) ||
            Math.round(l.y / weight) !== Math.round(c.y / weight)) {
            p.push(c);
        }
        return p;
    };
};
exports.arcTweener = function (oldProps, newProps) {
    var innerRadiusInterpolator = d3_interpolate_1.interpolateNumber(oldProps.innerRadius, newProps.innerRadius);
    var outerRadiusInterpolator = d3_interpolate_1.interpolateNumber(oldProps.outerRadius, newProps.outerRadius);
    var startAngleInterpolator = d3_interpolate_1.interpolateNumber(oldProps.startAngle, newProps.startAngle);
    var endAngleInterpolator = d3_interpolate_1.interpolateNumber(oldProps.endAngle, newProps.endAngle);
    return function (t) {
        var sliceGenerator = d3_shape_1.arc()
            .innerRadius(innerRadiusInterpolator(t))
            .outerRadius(outerRadiusInterpolator(t));
        return sliceGenerator({
            startAngle: startAngleInterpolator(t),
            endAngle: endAngleInterpolator(t)
        });
    };
};
exports.drawAreaConnector = function (_a) {
    var x1 = _a.x1, x2 = _a.x2, y1 = _a.y1, y2 = _a.y2, sizeX1 = _a.sizeX1, sizeY1 = _a.sizeY1, sizeX2 = _a.sizeX2, sizeY2 = _a.sizeY2;
    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "L" + (x2 + sizeX2) + "," + (y2 + sizeY2) + "L" + (x1 +
        sizeX1) + "," + (y1 + sizeY1) + "Z";
};
exports.wrap = function (text, width) {
    text.each(function () {
        var textNode = d3_selection_1.select(this), words = textNode
            .text()
            .split(/\s+/)
            .reverse(), lineHeight = 1.1, // ems
        y = textNode.attr("y"), dy = parseFloat(textNode.attr("dy"));
        var word, wordline = [], lineNumber = 0, tspan = textNode
            .text(null)
            .append("tspan")
            .attr("x", 0)
            .attr("y", y)
            .attr("dy", dy + "em");
        while (words.length > 0) {
            word = words.pop();
            wordline.push(word);
            tspan.text(wordline.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                wordline.pop();
                tspan.text(wordline.join(" "));
                wordline = [word];
                tspan = text
                    .append("tspan")
                    .attr("x", 0)
                    .attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + dy + "em")
                    .text(word);
            }
        }
    });
};
exports.hexToRgb = function (hex) {
    if (hex.substr(0, 2).toLowerCase() === "rg") {
        return hex
            .split("(")[1]
            .split(")")[0]
            .split(",");
    }
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ]
        : [0, 0, 0];
};
exports.groupBarMark = function (_a) {
    var bins = _a.bins, binMax = _a.binMax, relativeBuckets = _a.relativeBuckets, columnWidth = _a.columnWidth, projection = _a.projection, adjustedSize = _a.adjustedSize, summaryI = _a.summaryI, summary = _a.summary, renderValue = _a.renderValue, summaryStyle = _a.summaryStyle, type = _a.type, baseMarkProps = _a.baseMarkProps;
    var mappedBins = [];
    var mappedPoints = [];
    var actualMax = (relativeBuckets && relativeBuckets[summary.name]) || binMax;
    var summaryElementStylingFn = type.elementStyleFn || emptyObjectReturnFn;
    var barPadding = type.padding || 0;
    bins.forEach(function (d, i) {
        var opacity = d.value / actualMax;
        var additionalStyle = summaryElementStylingFn(d.value, opacity, d.pieces);
        var finalStyle = type.type === "heatmap"
            ? __assign({ opacity: opacity, fill: summaryStyle.fill }, additionalStyle) : __assign(__assign({}, summaryStyle), additionalStyle);
        var thickness = Math.max(1, d.y1 - barPadding * 2);
        var finalColumnWidth = type.type === "heatmap" ? columnWidth : columnWidth * opacity;
        var yProp = d.y + barPadding;
        var xProp = type.type === "heatmap" || type.flip
            ? -columnWidth / 2
            : columnWidth / 2 - finalColumnWidth;
        var height = thickness;
        var width = finalColumnWidth;
        var xOffset = type.type === "heatmap" ? finalColumnWidth / 2 : finalColumnWidth;
        var yOffset = d.y1 / 2;
        if (projection === "horizontal") {
            yProp =
                type.type === "heatmap"
                    ? -columnWidth / 2
                    : type.flip
                        ? -columnWidth / 2
                        : columnWidth / 2 - finalColumnWidth;
            xProp = d.y - d.y1 + barPadding;
            height = finalColumnWidth;
            width = thickness;
            yOffset =
                type.type === "heatmap" ? finalColumnWidth / 2 : finalColumnWidth;
            xOffset = d.y1 / 2;
        }
        else if (projection === "radial") {
            var arcGenerator = d3_shape_1.arc()
                .innerRadius(d.y / 2)
                .outerRadius((d.y + d.y1) / 2);
            var angle = summary.pct - summary.pct_padding;
            var startAngle = summary.pct_middle - summary.pct_padding;
            var endAngle = type.type === "heatmap"
                ? startAngle + angle
                : startAngle + angle * opacity;
            startAngle *= twoPI;
            endAngle *= twoPI;
            var arcAdjustX = adjustedSize[0] / 2;
            var arcAdjustY = adjustedSize[1] / 2;
            var arcTranslate = "translate(" + arcAdjustX + "," + arcAdjustY + ")";
            var arcCenter = arcGenerator.centroid({ startAngle: startAngle, endAngle: endAngle });
            mappedPoints.push({
                key: summary.name,
                value: d.value,
                pieces: d.pieces.map(function (p) { return p.piece; }),
                label: "Heatmap",
                x: arcCenter[0] + arcAdjustX,
                y: arcCenter[1] + arcAdjustY
            });
            mappedBins.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { markType: "path", transform: arcTranslate, renderMode: renderValue, key: "groupIcon-" + summaryI + "-" + i, d: arcGenerator({ startAngle: startAngle, endAngle: endAngle }), style: finalStyle })));
        }
        if (projection !== "radial") {
            mappedPoints.push({
                key: summary.name,
                value: d.value,
                pieces: d.pieces.map(function (p) { return p.piece; }),
                label: "Heatmap",
                x: xProp + xOffset,
                y: yProp + yOffset
            });
            mappedBins.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { markType: "rect", renderMode: renderValue, key: "groupIcon-" + summaryI + "-" + i, x: xProp, y: yProp, height: height, width: width, style: finalStyle })));
        }
    });
    return { marks: mappedBins, points: mappedPoints };
};
// FROM d3-svg-ribbon
function linearRibbon() {
    var _lineConstructor = d3_shape_1.line();
    var _xAccessor = function (d) {
        return d.x;
    };
    var _yAccessor = function (d) {
        return d.y;
    };
    var _rAccessor = function (d) {
        return d.r;
    };
    var _interpolator = d3_shape_1.curveLinearClosed;
    function _ribbon(pathData) {
        if (pathData.multiple) {
            var original_r = _rAccessor;
            var parallelTotal_1 = pathData.multiple.reduce(function (p, c) { return p + c.weight; }, 0);
            _rAccessor = function () { return parallelTotal_1; };
            var totalPoints = buildRibbon(pathData.points);
            var currentPoints_1 = totalPoints
                .filter(function (d) { return d.direction === "forward"; })
                .reduce(dedupeRibbonPoints(), []);
            var allRibbons_1 = [];
            pathData.multiple.forEach(function (siblingPath, siblingI) {
                _rAccessor = function () { return siblingPath.weight; };
                var currentRibbon = buildRibbon(currentPoints_1);
                allRibbons_1.push(currentRibbon);
                var nextSibling = pathData.multiple[siblingI + 1];
                if (nextSibling) {
                    var currentLeftSide = currentRibbon
                        .reverse()
                        .filter(function (d) { return d.direction === "back"; })
                        .reduce(dedupeRibbonPoints(), []);
                    _rAccessor = function () { return nextSibling.weight; };
                    var leftHandInflatedRibbon = buildRibbon(currentLeftSide);
                    currentPoints_1 = leftHandInflatedRibbon
                        .reverse()
                        .filter(function (d) { return d.direction === "back"; })
                        .reduce(dedupeRibbonPoints(), []);
                }
            });
            _rAccessor = original_r;
            return allRibbons_1.map(function (d) {
                return _lineConstructor
                    .x(_xAccessor)
                    .y(_yAccessor)
                    .curve(_interpolator)(d);
            });
        }
        var bothPoints = buildRibbon(pathData).reduce(dedupeRibbonPoints(), []);
        return _lineConstructor
            .x(_xAccessor)
            .y(_yAccessor)
            .curve(_interpolator)(bothPoints);
    }
    _ribbon.x = function (_value) {
        if (!arguments.length)
            return _xAccessor;
        _xAccessor = _value;
        return _ribbon;
    };
    _ribbon.y = function (_value) {
        if (!arguments.length)
            return _yAccessor;
        _yAccessor = _value;
        return _ribbon;
    };
    _ribbon.r = function (_value) {
        if (!arguments.length)
            return _rAccessor;
        _rAccessor = _value;
        return _ribbon;
    };
    _ribbon.interpolate = function (_value) {
        if (!arguments.length)
            return _interpolator;
        _interpolator = _value;
        return _ribbon;
    };
    return _ribbon;
    function offsetEdge(d) {
        var diffX = _yAccessor(d.target) - _yAccessor(d.source);
        var diffY = _xAccessor(d.target) - _xAccessor(d.source);
        var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
        var angle1 = angle0 + Math.PI * 0.5;
        var angle2 = angle0 + Math.PI * 0.5;
        var x1 = _xAccessor(d.source) + _rAccessor(d.source) * Math.cos(angle1);
        var y1 = _yAccessor(d.source) - _rAccessor(d.source) * Math.sin(angle1);
        var x2 = _xAccessor(d.target) + _rAccessor(d.target) * Math.cos(angle2);
        var y2 = _yAccessor(d.target) - _rAccessor(d.target) * Math.sin(angle2);
        return { x1: x1, y1: y1, x2: x2, y2: y2 };
    }
    function buildRibbon(points) {
        var bothCode = [];
        var x = 0;
        var transformedPoints = { x1: 0, y1: 0, x2: 0, y2: 0 };
        while (x < points.length) {
            if (x !== points.length - 1) {
                transformedPoints = offsetEdge({
                    source: points[x],
                    target: points[x + 1]
                });
                var p1 = {
                    x: transformedPoints.x1,
                    y: transformedPoints.y1,
                    direction: "forward"
                };
                var p2 = {
                    x: transformedPoints.x2,
                    y: transformedPoints.y2,
                    direction: "forward"
                };
                bothCode.push(p1, p2);
                if (bothCode.length > 3) {
                    var l = bothCode.length - 1;
                    var lineA = { a: bothCode[l - 3], b: bothCode[l - 2] };
                    var lineB = { a: bothCode[l - 1], b: bothCode[l] };
                    var intersect = findIntersect(lineA.a.x, lineA.a.y, lineA.b.x, lineA.b.y, lineB.a.x, lineB.a.y, lineB.b.x, lineB.b.y);
                    if (intersect.found === true) {
                        lineA.b.x = intersect.x;
                        lineA.b.y = intersect.y;
                        lineB.a.x = intersect.x;
                        lineB.a.y = intersect.y;
                    }
                }
            }
            x++;
        }
        x--;
        //Back
        while (x >= 0) {
            if (x !== 0) {
                transformedPoints = offsetEdge({
                    source: points[x],
                    target: points[x - 1]
                });
                var p1 = {
                    x: transformedPoints.x1,
                    y: transformedPoints.y1,
                    direction: "back"
                };
                var p2 = {
                    x: transformedPoints.x2,
                    y: transformedPoints.y2,
                    direction: "back"
                };
                bothCode.push(p1, p2);
                if (bothCode.length > 3) {
                    var l = bothCode.length - 1;
                    var lineA = { a: bothCode[l - 3], b: bothCode[l - 2] };
                    var lineB = { a: bothCode[l - 1], b: bothCode[l] };
                    var intersect = findIntersect(lineA.a.x, lineA.a.y, lineA.b.x, lineA.b.y, lineB.a.x, lineB.a.y, lineB.b.x, lineB.b.y);
                    if (intersect.found === true) {
                        lineA.b.x = intersect.x;
                        lineA.b.y = intersect.y;
                        lineB.a.x = intersect.x;
                        lineB.a.y = intersect.y;
                    }
                }
            }
            x--;
        }
        return bothCode;
    }
    function findIntersect(l1x1, l1y1, l1x2, l1y2, l2x1, l2y1, l2x2, l2y2) {
        var a, b;
        var result = {
            x: null,
            y: null,
            found: false
        };
        var d = (l2y2 - l2y1) * (l1x2 - l1x1) - (l2x2 - l2x1) * (l1y2 - l1y1);
        if (d === 0) {
            return result;
        }
        a = l1y1 - l2y1;
        b = l1x1 - l2x1;
        var n1 = (l2x2 - l2x1) * a - (l2y2 - l2y1) * b;
        var n2 = (l1x2 - l1x1) * a - (l1y2 - l1y1) * b;
        a = n1 / d;
        b = n2 / d;
        result.x = l1x1 + a * (l1x2 - l1x1);
        result.y = l1y1 + a * (l1y2 - l1y1);
        if (a > 0 && a < 1 && (b > 0 && b < 1)) {
            result.found = true;
        }
        return result;
    }
}
exports.linearRibbon = linearRibbon;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
const styled_components_1 = __importDefault(__webpack_require__(19));
const PalettePicker_1 = __importDefault(__webpack_require__(333));
const CircleSpan = styled_components_1.default.span `
  & {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 5px;
    border-radius: 20px;
    margin-bottom: -5px;
  }
`;
const LegendItemSpan = styled_components_1.default.span `
  & {
    display: inline-block;
    min-width: 80px;
    margin: 5px;
  }
`;
const LegendWrapper = styled_components_1.default.div `
  & {
    margin-top: 20px;
  }
`;
const HTMLLegend = ({ colorHash, values = Object.keys(colorHash), valueHash, colors = Object.values(colorHash), setColor }) => {
    const updateColorFn = (newColorArray) => {
        setColor(newColorArray);
    };
    return (React.createElement(LegendWrapper, null,
        (values.length > 18
            ? // limit the displayed values to the top 18 and bin everything else into Other
                [...values.filter((d, index) => index < 18), "Other"]
            : values).map((value, index) => colorHash[value] && (React.createElement(LegendItemSpan, { key: `legend-item-${index}` },
            React.createElement(CircleSpan, { style: {
                    background: colorHash[value]
                } }),
            React.createElement("span", { className: "html-legend-item" }, value),
            (valueHash[value] &&
                valueHash[value] > 1 &&
                `(${valueHash[value]})`) ||
                ""))),
        setColor && (React.createElement(PalettePicker_1.default, { colors: colors, updateColor: updateColorFn }))));
};
exports.default = HTMLLegend;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(22);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(188),
    baseKeys = __webpack_require__(346),
    isArrayLike = __webpack_require__(54);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 75 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(207),
    baseAssignValue = __webpack_require__(146);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLabelItems = exports.numeralFormatting = void 0;
const numeral_1 = __importDefault(__webpack_require__(499));
function numeralFormatting(tickValue) {
    let format = "0.[00]a";
    if (tickValue === 0) {
        return "0";
    }
    else if (tickValue > 100000000000000 || tickValue < 0.00001) {
        format = "0.[000]e+0";
    }
    else if (tickValue < 1) {
        format = "0.[0000]a";
    }
    return numeral_1.default(tickValue).format(format);
}
exports.numeralFormatting = numeralFormatting;
function createLabelItems(uniqueValues) {
    return uniqueValues.map(value => ({ label: value }));
}
exports.createLabelItems = createLabelItems;


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "scaleBand", function() { return /* reexport */ band; });
__webpack_require__.d(__webpack_exports__, "scalePoint", function() { return /* reexport */ point; });
__webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return /* reexport */ identity_identity; });
__webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return /* reexport */ linear; });
__webpack_require__.d(__webpack_exports__, "scaleLog", function() { return /* reexport */ log; });
__webpack_require__.d(__webpack_exports__, "scaleSymlog", function() { return /* reexport */ symlog; });
__webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return /* reexport */ ordinal; });
__webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return /* reexport */ implicit; });
__webpack_require__.d(__webpack_exports__, "scalePow", function() { return /* reexport */ pow; });
__webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return /* reexport */ sqrt; });
__webpack_require__.d(__webpack_exports__, "scaleRadial", function() { return /* reexport */ radial; });
__webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return /* reexport */ quantile_quantile; });
__webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return /* reexport */ quantize; });
__webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return /* reexport */ threshold; });
__webpack_require__.d(__webpack_exports__, "scaleTime", function() { return /* reexport */ time; });
__webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return /* reexport */ utcTime; });
__webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return /* reexport */ sequential; });
__webpack_require__.d(__webpack_exports__, "scaleSequentialLog", function() { return /* reexport */ sequentialLog; });
__webpack_require__.d(__webpack_exports__, "scaleSequentialPow", function() { return /* reexport */ sequentialPow; });
__webpack_require__.d(__webpack_exports__, "scaleSequentialSqrt", function() { return /* reexport */ sequentialSqrt; });
__webpack_require__.d(__webpack_exports__, "scaleSequentialSymlog", function() { return /* reexport */ sequentialSymlog; });
__webpack_require__.d(__webpack_exports__, "scaleSequentialQuantile", function() { return /* reexport */ sequentialQuantile; });
__webpack_require__.d(__webpack_exports__, "scaleDiverging", function() { return /* reexport */ diverging; });
__webpack_require__.d(__webpack_exports__, "scaleDivergingLog", function() { return /* reexport */ divergingLog; });
__webpack_require__.d(__webpack_exports__, "scaleDivergingPow", function() { return /* reexport */ divergingPow; });
__webpack_require__.d(__webpack_exports__, "scaleDivergingSqrt", function() { return /* reexport */ divergingSqrt; });
__webpack_require__.d(__webpack_exports__, "scaleDivergingSymlog", function() { return /* reexport */ divergingSymlog; });
__webpack_require__.d(__webpack_exports__, "tickFormat", function() { return /* reexport */ src_tickFormat; });

// EXTERNAL MODULE: ./node_modules/d3-array/src/range.js
var src_range = __webpack_require__(108);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/ordinal.js


const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/band.js




function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(src_range["a" /* default */])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// EXTERNAL MODULE: ./node_modules/d3-array/src/ticks.js
var ticks = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/d3-array/src/bisect.js
var bisect = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/value.js
var src_value = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/round.js
var src_round = __webpack_require__(167);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/number.js
/* harmony default export */ var src_number = (function(x) {
  return +x;
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/continuous.js





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(bisect["c" /* default */])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = src_value["a" /* default */],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), number["a" /* default */])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, src_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = src_round["a" /* default */], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}

// EXTERNAL MODULE: ./node_modules/d3-format/src/formatSpecifier.js
var formatSpecifier = __webpack_require__(152);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionPrefix.js
var precisionPrefix = __webpack_require__(522);

// EXTERNAL MODULE: ./node_modules/d3-format/src/defaultLocale.js + 8 modules
var defaultLocale = __webpack_require__(539);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionRound.js
var precisionRound = __webpack_require__(523);

// EXTERNAL MODULE: ./node_modules/d3-format/src/precisionFixed.js
var precisionFixed = __webpack_require__(524);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/tickFormat.js



/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {
  var step = Object(ticks["c" /* tickStep */])(start, stop, count),
      precision;
  specifier = Object(formatSpecifier["a" /* default */])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;
      return Object(defaultLocale["b" /* formatPrefix */])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(defaultLocale["a" /* format */])(specifier);
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/linear.js





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(ticks["a" /* default */])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(ticks["b" /* tickIncrement */])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(ticks["b" /* tickIncrement */])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(ticks["b" /* tickIncrement */])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous();

  scale.copy = function() {
    return copy(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/identity.js



function identity_identity(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, src_number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity_identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, src_number) : [0, 1];

  return linearish(scale);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/nice.js
/* harmony default export */ var nice = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/log.js






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = Object(ticks["a" /* default */])(u, v, n);
    } else {
      z = Object(ticks["a" /* default */])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(defaultLocale["a" /* format */])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);

  return scale;
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/symlog.js




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/pow.js




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/radial.js





function square(x) {
  return Math.sign(x) * x * x;
}

function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}

function radial() {
  var squared = continuous(),
      range = [0, 1],
      round = false,
      unknown;

  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }

  scale.invert = function(y) {
    return squared.invert(square(y));
  };

  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };

  scale.range = function(_) {
    return arguments.length ? (squared.range((range = Array.from(_, src_number)).map(square)), scale) : range.slice();
  };

  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, scale) : round;
  };

  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return radial(squared.domain(), range)
        .round(round)
        .clamp(squared.clamp())
        .unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

// EXTERNAL MODULE: ./node_modules/d3-array/src/quantile.js + 1 modules
var quantile = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/d3-array/src/ascending.js
var ascending = __webpack_require__(9);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/quantile.js



function quantile_quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(quantile["a" /* default */])(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[Object(bisect["c" /* default */])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending["a" /* default */]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile_quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/quantize.js




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[Object(bisect["c" /* default */])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/threshold.js



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[Object(bisect["c" /* default */])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

// EXTERNAL MODULE: ./node_modules/d3-array/src/bisector.js
var bisector = __webpack_require__(109);

// EXTERNAL MODULE: ./node_modules/d3-time/src/year.js
var src_year = __webpack_require__(525);

// EXTERNAL MODULE: ./node_modules/d3-time/src/month.js
var src_month = __webpack_require__(526);

// EXTERNAL MODULE: ./node_modules/d3-time/src/week.js
var src_week = __webpack_require__(527);

// EXTERNAL MODULE: ./node_modules/d3-time/src/day.js
var src_day = __webpack_require__(528);

// EXTERNAL MODULE: ./node_modules/d3-time/src/hour.js
var src_hour = __webpack_require__(529);

// EXTERNAL MODULE: ./node_modules/d3-time/src/minute.js
var src_minute = __webpack_require__(530);

// EXTERNAL MODULE: ./node_modules/d3-time/src/second.js
var src_second = __webpack_require__(531);

// EXTERNAL MODULE: ./node_modules/d3-time/src/millisecond.js
var src_millisecond = __webpack_require__(532);

// EXTERNAL MODULE: ./node_modules/d3-time-format/src/defaultLocale.js + 1 modules
var src_defaultLocale = __webpack_require__(540);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/time.js







var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(bisector["a" /* default */])(function(i) { return i[2]; }).right(tickIntervals, target),
          step;
      if (i === tickIntervals.length) {
        step = Object(ticks["c" /* tickStep */])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(ticks["c" /* tickStep */])(start, stop, interval), 1);
        interval = millisecond;
      }
      return interval.every(step);
    }

    return interval;
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, time_number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1]))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ var time = (function() {
  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["b" /* sunday */], src_day["a" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
});

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcYear.js
var utcYear = __webpack_require__(535);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcMonth.js
var utcMonth = __webpack_require__(536);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcWeek.js
var utcWeek = __webpack_require__(533);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcDay.js
var utcDay = __webpack_require__(534);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcHour.js
var utcHour = __webpack_require__(537);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcMinute.js
var utcMinute = __webpack_require__(538);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/utcTime.js





/* harmony default export */ var utcTime = (function() {
  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["b" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-scale/src/sequential.js








function sequential_transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(src_value["a" /* default */]);

  scale.rangeRound = range(src_round["a" /* default */]);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function sequential_copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(sequential_transformer()(identity));

  scale.copy = function() {
    return sequential_copy(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(sequential_transformer()).domain([1, 10]);

  scale.copy = function() {
    return sequential_copy(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/sequentialQuantile.js




function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((Object(bisect["c" /* default */])(domain, x, 1) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending["a" /* default */]);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };

  scale.quantiles = function(n) {
    return Array.from({length: n + 1}, (_, i) => Object(quantile["a" /* default */])(domain, i / n));
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/piecewise.js
var src_piecewise = __webpack_require__(170);

// CONCATENATED MODULE: ./node_modules/d3-scale/src/diverging.js









function diverging_transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = Object(src_piecewise["a" /* default */])(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(src_value["a" /* default */]);

  scale.rangeRound = range(src_round["a" /* default */]);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = linearish(diverging_transformer()(identity));

  scale.copy = function() {
    return sequential_copy(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return sequential_copy(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(diverging_transformer());

  scale.copy = function() {
    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(diverging_transformer());

  scale.copy = function() {
    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// CONCATENATED MODULE: ./node_modules/d3-scale/src/index.js



































/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return max; });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),
/* 80 */,
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnnotationLayer_1 = __importDefault(__webpack_require__(158));
exports.AnnotationLayer = AnnotationLayer_1.default;
var DividedLine_1 = __importDefault(__webpack_require__(268));
exports.DividedLine = DividedLine_1.default;
var XYFrame_1 = __importDefault(__webpack_require__(70));
exports.XYFrame = XYFrame_1.default;
var OrdinalFrame_1 = __importDefault(__webpack_require__(128));
exports.OrdinalFrame = OrdinalFrame_1.default;
var MinimapXYFrame_1 = __importDefault(__webpack_require__(181));
exports.MinimapXYFrame = MinimapXYFrame_1.default;
var MiniMap_1 = __importDefault(__webpack_require__(182));
exports.MiniMap = MiniMap_1.default;
var Axis_1 = __importDefault(__webpack_require__(82));
exports.Axis = Axis_1.default;
var Legend_1 = __importDefault(__webpack_require__(159));
exports.Legend = Legend_1.default;
var Annotation_1 = __importDefault(__webpack_require__(49));
exports.Annotation = Annotation_1.default;
var Brush_1 = __importDefault(__webpack_require__(169));
exports.Brush = Brush_1.default;
var InteractionLayer_1 = __importDefault(__webpack_require__(168));
exports.InteractionLayer = InteractionLayer_1.default;
var VisualizationLayer_1 = __importDefault(__webpack_require__(171));
exports.VisualizationLayer = VisualizationLayer_1.default;
var NetworkFrame_1 = __importDefault(__webpack_require__(130));
exports.NetworkFrame = NetworkFrame_1.default;
var lineDrawing_1 = __webpack_require__(68);
exports.funnelize = lineDrawing_1.funnelize;
var dataFunctions_1 = __webpack_require__(52);
exports.calculateDataExtent = dataFunctions_1.calculateDataExtent;
var FacetController_1 = __importDefault(__webpack_require__(323));
exports.FacetController = FacetController_1.default;
var ResponsiveNetworkFrame_1 = __importDefault(__webpack_require__(324));
exports.ResponsiveNetworkFrame = ResponsiveNetworkFrame_1.default;
var ResponsiveMinimapXYFrame_1 = __importDefault(__webpack_require__(326));
exports.ResponsiveMinimapXYFrame = ResponsiveMinimapXYFrame_1.default;
var ResponsiveXYFrame_1 = __importDefault(__webpack_require__(327));
exports.ResponsiveXYFrame = ResponsiveXYFrame_1.default;
var ResponsiveOrdinalFrame_1 = __importDefault(__webpack_require__(328));
exports.ResponsiveOrdinalFrame = ResponsiveOrdinalFrame_1.default;
var SparkXYFrame_1 = __importDefault(__webpack_require__(329));
exports.SparkXYFrame = SparkXYFrame_1.default;
var SparkOrdinalFrame_1 = __importDefault(__webpack_require__(330));
exports.SparkOrdinalFrame = SparkOrdinalFrame_1.default;
var SparkNetworkFrame_1 = __importDefault(__webpack_require__(331));
exports.SparkNetworkFrame = SparkNetworkFrame_1.default;
var semiotic_mark_1 = __webpack_require__(15);
exports.Mark = semiotic_mark_1.Mark;
var areaDrawing_1 = __webpack_require__(83);
exports.hexbinning = areaDrawing_1.hexbinning;
exports.heatmapping = areaDrawing_1.heatmapping;
var network_1 = __webpack_require__(183);
exports.nodesEdgesFromHierarchy = network_1.nodesEdgesFromHierarchy;
exports.default = {
    AnnotationLayer: AnnotationLayer_1.default,
    DividedLine: DividedLine_1.default,
    XYFrame: XYFrame_1.default,
    MinimapXYFrame: MinimapXYFrame_1.default,
    MiniMap: MiniMap_1.default,
    Brush: Brush_1.default,
    Axis: Axis_1.default,
    InteractionLayer: InteractionLayer_1.default,
    VisualizationLayer: VisualizationLayer_1.default,
    OrdinalFrame: OrdinalFrame_1.default,
    Annotation: Annotation_1.default,
    NetworkFrame: NetworkFrame_1.default,
    ResponsiveMinimapXYFrame: ResponsiveMinimapXYFrame_1.default,
    ResponsiveOrdinalFrame: ResponsiveOrdinalFrame_1.default,
    ResponsiveNetworkFrame: ResponsiveNetworkFrame_1.default,
    ResponsiveXYFrame: ResponsiveXYFrame_1.default,
    SparkOrdinalFrame: SparkOrdinalFrame_1.default,
    SparkNetworkFrame: SparkNetworkFrame_1.default,
    SparkXYFrame: SparkXYFrame_1.default,
    Legend: Legend_1.default,
    Mark: semiotic_mark_1.Mark,
    FacetController: FacetController_1.default,
    funnelize: lineDrawing_1.funnelize,
    calculateDataExtent: dataFunctions_1.calculateDataExtent,
    hexbinning: areaDrawing_1.hexbinning,
    heatmapping: areaDrawing_1.heatmapping,
    nodesEdgesFromHierarchy: network_1.nodesEdgesFromHierarchy
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var axis_1 = __webpack_require__(122);
var summaryLayouts_1 = __webpack_require__(123);
// components
var marginalPointMapper = function (orient, width, data) {
    var xMod = orient === "left" || orient === "right" ? width / 2 : 0;
    var yMod = orient === "bottom" || orient === "top" ? width / 2 : 0;
    return data.map(function (p) { return [p.xy.x + xMod, p.xy.y + yMod]; });
};
function formatValue(value, props) {
    if (props.tickFormat) {
        return props.tickFormat(value);
    }
    if (value.toString) {
        return value.toString();
    }
    return value;
}
var Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    function Axis(props) {
        var _this = _super.call(this, props) || this;
        _this.axisRef = null;
        _this.boundingBoxMax = function () {
            // && this.props.dynamicLabel ???
            if (!_this.axisRef)
                return 30;
            var _a = _this.props.orient, orient = _a === void 0 ? "left" : _a;
            var positionType = orient === "left" || orient === "right" ? "width" : "height";
            var axisLabelMax = Math.max.apply(Math, __spread(__spread(_this.axisRef.querySelectorAll(".axis-label")).map(function (l) {
                return (l.getBBox && l.getBBox()) || { height: 30, width: 30 };
            })
                .map(function (d) { return d[positionType]; }))) + 25;
            return axisLabelMax;
        };
        _this.state = { hoverAnnotation: 0 };
        return _this;
    }
    Axis.prototype.componentDidUpdate = function () {
        var _a = this.props, _b = _a.label, label = _b === void 0 ? { position: false } : _b, dynamicLabelPosition = _a.dynamicLabelPosition;
        var calculatedLabelPosition = this.state.calculatedLabelPosition;
        if (!label.position && dynamicLabelPosition) {
            var newBBMax = this.boundingBoxMax();
            if (newBBMax !== calculatedLabelPosition) {
                this.setState({ calculatedLabelPosition: newBBMax });
            }
        }
    };
    Axis.prototype.componentDidMount = function () {
        var _a = this.props, _b = _a.label, label = _b === void 0 ? { position: false } : _b, dynamicLabelPosition = _a.dynamicLabelPosition;
        if (!label.position && dynamicLabelPosition) {
            var newBBMax = this.boundingBoxMax();
            this.setState({ calculatedLabelPosition: newBBMax });
        }
    };
    Axis.prototype.render = function () {
        var _this = this;
        var _a = this.props, rotate = _a.rotate, label = _a.label, _b = _a.orient, orient = _b === void 0 ? "left" : _b, marginalSummaryType = _a.marginalSummaryType, _c = _a.tickFormat, tickFormat = _c === void 0 ? marginalSummaryType ? function () { return ""; } : function (d) { return d; } : _c, size = _a.size, _d = _a.width, width = _d === void 0 ? (size && size[0]) || 0 : _d, _e = _a.height, height = _e === void 0 ? (size && size[1]) || 0 : _e, className = _a.className, padding = _a.padding, tickValues = _a.tickValues, scale = _a.scale, ticks = _a.ticks, footer = _a.footer, tickSize = _a.tickSize, tickLineGenerator = _a.tickLineGenerator, _f = _a.baseline, baseline = _f === void 0 ? true : _f, _g = _a.margin, margin = _g === void 0 ? { top: 0, bottom: 0, left: 0, right: 0 } : _g, _h = _a.center, center = _h === void 0 ? false : _h, annotationFunction = _a.annotationFunction, glyphFunction = _a.glyphFunction, xyPoints = _a.xyPoints;
        var _j = this.props, axisParts = _j.axisParts, _k = _j.position, position = _k === void 0 ? [0, 0] : _k;
        var axisTickLines;
        if (!axisParts) {
            axisParts = axis_1.axisPieces({
                padding: padding,
                tickValues: tickValues,
                scale: scale,
                ticks: ticks,
                orient: orient,
                size: [width, height],
                footer: footer,
                tickSize: tickSize
            });
            axisTickLines = (React.createElement("g", { className: "axis " + className }, axis_1.axisLines({
                axisParts: axisParts,
                orient: orient,
                tickLineGenerator: tickLineGenerator,
                className: className,
                scale: scale
            })));
        }
        if (axisParts.length === 0) {
            return null;
        }
        var hoverWidth = 50;
        var hoverHeight = height;
        var hoverX = -50;
        var hoverY = 0;
        var baselineX = 0;
        var baselineY = 0;
        var baselineX2 = 0;
        var baselineY2 = height;
        var hoverFunction = function (e) {
            _this.setState({ hoverAnnotation: e.nativeEvent.offsetY });
        };
        var circleX = 25;
        var textX = -25;
        var textY = 18;
        var lineWidth = width + 25;
        var lineHeight = 0;
        var circleY = this.state.hoverAnnotation;
        var annotationOffset = 0;
        var annotationType = "y";
        switch (orient) {
            case "right":
                position = [position[0], position[1]];
                hoverX = width;
                baselineX2 = baselineX = width;
                annotationOffset = margin.top;
                lineWidth = -width - 25;
                textX = 5;
                hoverFunction = function (e) {
                    return _this.setState({
                        hoverAnnotation: e.nativeEvent.offsetY - annotationOffset
                    });
                };
                if (center === true) {
                    baselineX2 = baselineX = width / 2;
                }
                break;
            case "top":
                position = [position[0], 0];
                hoverWidth = width;
                hoverHeight = 50;
                hoverY = -50;
                hoverX = 0;
                annotationOffset = margin.left;
                annotationType = "x";
                baselineX2 = width;
                baselineY2 = 0;
                if (center === true) {
                    baselineY2 = baselineY = height / 2;
                }
                hoverFunction = function (e) {
                    return _this.setState({
                        hoverAnnotation: e.nativeEvent.offsetX - annotationOffset
                    });
                };
                circleX = this.state.hoverAnnotation;
                circleY = 25;
                textX = 0;
                textY = -10;
                lineWidth = 0;
                lineHeight = height + 25;
                break;
            case "bottom":
                position = [position[0], 0];
                hoverWidth = width;
                hoverHeight = 50;
                baselineY = baselineY2 = hoverY = height;
                baselineX = hoverX = 0;
                baselineX2 = width;
                annotationOffset = margin.left;
                hoverFunction = function (e) {
                    return _this.setState({
                        hoverAnnotation: e.nativeEvent.offsetX - annotationOffset
                    });
                };
                circleX = this.state.hoverAnnotation;
                circleY = 25;
                textX = 0;
                textY = 15;
                lineWidth = 0;
                lineHeight = -height - 25;
                annotationType = "x";
                if (center === true) {
                    baselineY2 = baselineY = height / 2;
                }
                break;
            default:
                position = [position[0], position[1]];
                annotationOffset = margin.top;
                if (center === true) {
                    baselineX2 = baselineX = width / 2;
                }
                hoverFunction = function (e) {
                    _this.setState({
                        hoverAnnotation: e.nativeEvent.offsetY - annotationOffset
                    });
                };
        }
        var annotationBrush;
        if (annotationFunction) {
            var formattedValue = formatValue(scale.invert(this.state.hoverAnnotation), this.props);
            var hoverGlyph = glyphFunction ? (glyphFunction({
                lineHeight: lineHeight,
                lineWidth: lineWidth,
                value: scale.invert(this.state.hoverAnnotation)
            })) : (React.createElement("g", null,
                React.isValidElement(formattedValue) ? (React.createElement("g", { transform: "translate(" + textX + "," + textY + ")" }, formattedValue)) : (React.createElement("text", { x: textX, y: textY }, formattedValue)),
                React.createElement("circle", { r: 5 }),
                React.createElement("line", { x1: lineWidth, y1: lineHeight, style: { stroke: "black" } })));
            var annotationSymbol = this.state.hoverAnnotation ? (React.createElement("g", { style: { pointerEvents: "none" }, transform: "translate(" + circleX + "," + circleY + ")" }, hoverGlyph)) : null;
            annotationBrush = (React.createElement("g", { className: "annotation-brush", transform: "translate(" + hoverX + "," + hoverY + ")" },
                React.createElement("rect", { style: { fillOpacity: 0 }, height: hoverHeight, width: hoverWidth, onMouseMove: hoverFunction, onClick: function () {
                        return annotationFunction({
                            className: "dynamic-axis-annotation",
                            type: annotationType,
                            value: scale.invert(_this.state.hoverAnnotation)
                        });
                    }, onMouseOut: function () { return _this.setState({ hoverAnnotation: undefined }); } }),
                annotationSymbol));
        }
        var summaryGraphic;
        if (marginalSummaryType && xyPoints) {
            var summaryWidth = Math.max(margin[orient] - 6, 5);
            var decoratedSummaryType_1 = typeof marginalSummaryType === "string"
                ? { type: marginalSummaryType }
                : marginalSummaryType;
            if (decoratedSummaryType_1.flip === undefined &&
                (orient === "bottom" || orient === "right")) {
                decoratedSummaryType_1.flip = true;
            }
            var summaryStyle = decoratedSummaryType_1.summaryStyle
                ? function () { return decoratedSummaryType_1.summaryStyle; }
                : function () { return ({
                    fill: "black",
                    fillOpacity: 0.5,
                    stroke: "black",
                    strokeDasharray: "0"
                }); };
            var summaryRenderMode = decoratedSummaryType_1.renderMode
                ? function () { return decoratedSummaryType_1.renderMode; }
                : function () { return undefined; };
            var summaryClass = decoratedSummaryType_1.summaryClass
                ? function () { return decoratedSummaryType_1.summaryClass; }
                : function () { return ""; };
            var dataFilter_1 = decoratedSummaryType_1.filter || (function () { return true; });
            var forSummaryData = xyPoints
                .filter(function (p) {
                return p.x !== undefined && p.y !== undefined && dataFilter_1(p.data);
            })
                .map(function (d) { return (__assign(__assign({}, d), { xy: {
                    x: orient === "top" || orient === "bottom" ? scale(d.x) : 0,
                    y: orient === "left" || orient === "right" ? scale(d.y) : 0
                }, piece: {
                    scaledVerticalValue: scale(d.y),
                    scaledValue: scale(d.x)
                }, value: orient === "top" || orient === "bottom" ? scale(d.y) : scale(d.x), scaledValue: scale(d.x), scaledVerticalValue: scale(d.y) })); });
            var renderedSummary = summaryLayouts_1.drawSummaries({
                data: {
                    column: {
                        middle: summaryWidth / 2,
                        pieceData: forSummaryData,
                        width: summaryWidth,
                        xyData: forSummaryData
                    }
                },
                type: decoratedSummaryType_1,
                renderMode: summaryRenderMode,
                eventListenersGenerator: decoratedSummaryType_1.eventListenersGenerator || (function () { return ({}); }),
                styleFn: summaryStyle,
                classFn: summaryClass,
                projection: orient === "top" || orient === "bottom" ? "horizontal" : "vertical",
                adjustedSize: size,
                margin: { top: 0, bottom: 0, left: 0, right: 0 },
                baseMarkProps: {}
            });
            var points = void 0;
            if (decoratedSummaryType_1.showPoints === true) {
                var mappedPoints = marginalPointMapper(orient, summaryWidth, forSummaryData);
                points = mappedPoints.map(function (d, i) { return (React.createElement("circle", { key: "axis-summary-point-" + i, cx: d[0], cy: d[1], r: decoratedSummaryType_1.r || 3, style: decoratedSummaryType_1.pointStyle || {
                        fill: "black",
                        fillOpacity: 0.1
                    } })); });
            }
            var translation = {
                left: [-margin.left + 2, 0],
                right: [size[0] + 2, 0],
                top: [0, -margin.top + 2],
                bottom: [0, size[1] + 2]
            };
            summaryGraphic = (React.createElement("g", { transform: "translate(" + translation[orient] + ")" },
                React.createElement("g", { transform: "translate(" + ((decoratedSummaryType_1.type === "contour" ||
                        decoratedSummaryType_1.type === "boxplot") &&
                        (orient === "left" || orient === "right")
                        ? summaryWidth / 2
                        : 0) + "," + ((decoratedSummaryType_1.type === "contour" ||
                        decoratedSummaryType_1.type === "boxplot") &&
                        (orient === "top" || orient === "bottom")
                        ? summaryWidth / 2
                        : 0) + ")" }, renderedSummary.marks),
                points));
        }
        var axisTitle;
        var axisTickLabels = axis_1.axisLabels({
            tickFormat: tickFormat,
            axisParts: axisParts,
            orient: orient,
            rotate: rotate,
            center: center
        });
        if (label) {
            var labelName = label.name || label;
            var labelPosition = label.position || {};
            var locationMod = labelPosition.location || "outside";
            var anchorMod = labelPosition.anchor || "middle";
            var distance = label.locationDistance || this.state.calculatedLabelPosition;
            var rotateHash = {
                left: -90,
                right: 90,
                top: 0,
                bottom: 0
            };
            var rotation = labelPosition.rotation || rotateHash[orient];
            var positionHash = {
                left: {
                    start: [0, size[1]],
                    middle: [0, size[1] / 2],
                    end: [0, 0],
                    inside: [distance || 15, 0],
                    outside: [-(distance || 45), 0]
                },
                right: {
                    start: [size[0] + 0, size[1]],
                    middle: [size[0] + 0, size[1] / 2],
                    end: [size[0] + 0, 0],
                    inside: [-(distance || 15), 0],
                    outside: [distance || 45, 0]
                },
                top: {
                    start: [0, 0],
                    middle: [0 + size[0] / 2, 0],
                    end: [0 + size[0], 0],
                    inside: [0, distance || 15],
                    outside: [0, -(distance || 40)]
                },
                bottom: {
                    start: [0, size[1]],
                    middle: [0 + size[0] / 2, size[1]],
                    end: [0 + size[0], size[1]],
                    inside: [0, -(distance || 5)],
                    outside: [0, distance || 50]
                }
            };
            var translation = positionHash[orient][anchorMod];
            var location_1 = positionHash[orient][locationMod];
            translation[0] = translation[0] + location_1[0];
            translation[1] = translation[1] + location_1[1];
            if (anchorMod === "start" && orient === "right") {
                anchorMod = "end";
            }
            else if (anchorMod === "end" && orient === "right") {
                anchorMod = "start";
            }
            axisTitle = (React.createElement("g", { className: "axis-title " + className, transform: "translate(" + [
                    translation[0] + position[0],
                    translation[1] + position[1]
                ] + ") rotate(" + rotation + ")" }, React.isValidElement(labelName) ? (labelName) : (React.createElement("text", { textAnchor: anchorMod }, labelName))));
        }
        var axisAriaLabel = orient + " axis " + ((axisParts &&
            axisParts.length > 0 &&
            "from " + tickFormat(axisParts[0].value, 0) + " to " + tickFormat(axisParts[axisParts.length - 1].value, axisParts.length - 1)) ||
            "without ticks");
        return (React.createElement("g", { className: className, "aria-label": axisAriaLabel, ref: function (node) { return (_this.axisRef = node); } },
            annotationBrush,
            axisTickLabels,
            axisTickLines,
            baseline === true ? (React.createElement("line", { key: "baseline", className: "axis-baseline " + className, stroke: "black", strokeLinecap: "square", x1: baselineX, x2: baselineX2, y1: baselineY, y2: baselineY2 })) : null,
            axisTitle,
            summaryGraphic));
    };
    return Axis;
}(React.Component));
exports.default = Axis;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_contour_1 = __webpack_require__(512);
var d3_scale_1 = __webpack_require__(24);
var d3_hexbin_1 = __webpack_require__(517);
var regression_1 = __importDefault(__webpack_require__(274));
var d3_shape_1 = __webpack_require__(18);
var generateLineBounds = function (xydata, basedata, topBoundingAccessor, bottomBoundingAccessor) {
    var tops = xydata.map(function (d, i) { return [
        d[0],
        d[1] + topBoundingAccessor(basedata[i])
    ]; });
    var bottoms = xydata.map(function (d, i) { return [
        d[0],
        d[1] - bottomBoundingAccessor(basedata[i])
    ]; });
    return __spread(tops, bottoms.reverse());
};
function lineBounding(_a) {
    var summaryType = _a.summaryType, data = _a.data, defined = _a.defined;
    var projectedSummaries = [];
    if (!summaryType.type) {
        summaryType = { type: summaryType };
    }
    var boundingAccessor = summaryType.boundingAccessor, _b = summaryType.topBoundingAccessor, topBoundingAccessor = _b === void 0 ? boundingAccessor : _b, _c = summaryType.bottomBoundingAccessor, bottomBoundingAccessor = _c === void 0 ? boundingAccessor : _c;
    data.forEach(function (lineData) {
        var definedData = lineData._baseData.map(defined);
        var currentBaseData = [];
        var currentXYFC = [];
        var boundingPieces = [
            {
                xyf: currentXYFC,
                base: currentBaseData
            }
        ];
        definedData.forEach(function (d, i) {
            if (d === true) {
                currentBaseData.push(lineData._baseData[i]);
                currentXYFC.push(lineData._xyfCoordinates[i]);
            }
            else if (definedData[i + 1]) {
                currentBaseData = [];
                currentXYFC = [];
                boundingPieces.push({
                    xyf: currentXYFC,
                    base: currentBaseData
                });
            }
        });
        boundingPieces.forEach(function (_a) {
            var xyf = _a.xyf, base = _a.base;
            var boundingProjectedSummary = {
                data: lineData,
                parentSummary: lineData,
                _xyfCoordinates: generateLineBounds(xyf, base, topBoundingAccessor, bottomBoundingAccessor)
            };
            projectedSummaries = __spread(projectedSummaries, [boundingProjectedSummary]);
        });
    });
    return projectedSummaries;
}
exports.lineBounding = lineBounding;
function contouring(_a) {
    var summaryType = _a.summaryType, data = _a.data, finalXExtent = _a.finalXExtent, finalYExtent = _a.finalYExtent;
    var projectedSummaries = [];
    if (!summaryType.type) {
        summaryType = { type: summaryType };
    }
    var _b = summaryType.resolution, resolution = _b === void 0 ? 500 : _b, _c = summaryType.thresholds, thresholds = _c === void 0 ? 10 : _c, _d = summaryType.bandwidth, bandwidth = _d === void 0 ? 20 : _d, neighborhood = summaryType.neighborhood;
    var xScale = d3_scale_1.scaleLinear()
        .domain(finalXExtent)
        .rangeRound([0, resolution])
        .nice();
    var yScale = d3_scale_1.scaleLinear()
        .domain(finalYExtent)
        .rangeRound([resolution, 0])
        .nice();
    data.forEach(function (contourData) {
        var contourProjectedSummaries = d3_contour_1.contourDensity()
            .size([resolution, resolution])
            .x(function (d) { return xScale(d[0]); })
            .y(function (d) { return yScale(d[1]); })
            .thresholds(thresholds)
            .bandwidth(bandwidth)(contourData._xyfCoordinates);
        if (neighborhood) {
            contourProjectedSummaries = [contourProjectedSummaries[0]];
        }
        var max = Math.max.apply(Math, __spread(contourProjectedSummaries.map(function (d) { return d.value; })));
        contourProjectedSummaries.forEach(function (summary) {
            summary.parentSummary = contourData;
            summary.bounds = [];
            summary.percent = summary.value / max;
            summary.coordinates.forEach(function (poly) {
                poly.forEach(function (subpoly, i) {
                    poly[i] = subpoly.map(function (coordpair) {
                        coordpair = [
                            xScale.invert(coordpair[0]),
                            yScale.invert(coordpair[1])
                        ];
                        return coordpair;
                    });
                    //Only push bounds for the main poly, not its interior rings, otherwise you end up labeling interior cutouts
                    if (i === 0) {
                        summary.bounds.push(shapeBounds(poly[i]));
                    }
                });
            });
        });
        projectedSummaries = __spread(projectedSummaries, contourProjectedSummaries);
    });
    return projectedSummaries;
}
exports.contouring = contouring;
function hexbinning(_a) {
    var _b = _a.preprocess, preprocess = _b === void 0 ? true : _b, _c = _a.processedData, processedData = _c === void 0 ? false : _c, baseSummaryType = _a.summaryType, baseData = _a.data, baseXExtent = _a.finalXExtent, baseYExtent = _a.finalYExtent, size = _a.size, _d = _a.xScaleType, xScaleType = _d === void 0 ? d3_scale_1.scaleLinear() : _d, _e = _a.yScaleType, yScaleType = _e === void 0 ? d3_scale_1.scaleLinear() : _e, margin = _a.margin, baseMarkProps = _a.baseMarkProps, styleFn = _a.styleFn, classFn = _a.classFn, renderFn = _a.renderFn, chartSize = _a.chartSize;
    var finalXExtent = baseXExtent;
    var finalYExtent = baseYExtent;
    console.log("baseData", baseData);
    if (!finalXExtent) {
        var xData = baseData.coordinates.map(function (p) { return p.x; });
        finalXExtent = [Math.min.apply(Math, __spread(xData)), Math.max.apply(Math, __spread(xData))];
    }
    if (!finalYExtent) {
        var yData = baseData.coordinates.map(function (p) { return p.y; });
        finalYExtent = [Math.min.apply(Math, __spread(yData)), Math.max.apply(Math, __spread(yData))];
    }
    if (processedData && baseData[0]) {
        return baseData[0].coordinates;
    }
    var projectedSummaries = [];
    var summaryType;
    if (!baseSummaryType.type) {
        summaryType = { type: summaryType };
    }
    else {
        summaryType = baseSummaryType;
    }
    var 
    //    binGraphic = "hex",
    _f = summaryType.bins, 
    //    binGraphic = "hex",
    bins = _f === void 0 ? 0.05 : _f, cellPx = summaryType.cellPx, _g = summaryType.binValue, binValue = _g === void 0 ? function (d) { return d.length; } : _g, binMax = summaryType.binMax, customMark = summaryType.customMark;
    if (baseData.coordinates && !baseData._xyfCoordinates) {
        baseData._xyfCoordinates = baseData.coordinates.map(function (d) { return [d.x, d.y]; });
    }
    var data = Array.isArray(baseData) ? baseData : [baseData];
    var hexBinXScale = xScaleType.domain(finalXExtent).range([0, size[0]]);
    var hexBinYScale = yScaleType.domain(finalYExtent).range([0, size[1]]);
    var actualResolution = (cellPx && cellPx / 2) || ((bins > 1 ? 1 / bins : bins) * size[0]) / 2;
    var hexbinner = d3_hexbin_1.hexbin()
        .x(function (d) { return hexBinXScale(d._xyfPoint[0]); })
        .y(function (d) { return hexBinYScale(d._xyfPoint[1]); })
        .radius(actualResolution)
        .size(size);
    var hexMax;
    var allHexes = hexbinner.centers();
    data.forEach(function (hexbinData) {
        hexMax = 0;
        var hexes = hexbinner(hexbinData._xyfCoordinates.map(function (d, i) { return (__assign({ _xyfPoint: d }, hexbinData.coordinates[i])); }));
        var centerHash = {};
        hexes.forEach(function (d) {
            centerHash[parseInt(d.x) + "-" + parseInt(d.y)] = true;
        });
        allHexes.forEach(function (hexCenter) {
            if (!centerHash[parseInt(hexCenter[0]) + "-" + parseInt(hexCenter[1])]) {
                var newHex = [];
                newHex.x = hexCenter[0];
                newHex.y = hexCenter[1];
                hexes.push(newHex);
            }
        });
        hexMax = Math.max.apply(Math, __spread(hexes.map(function (d) { return binValue(d); })));
        if (binMax) {
            binMax(hexMax);
        }
        //Option for blank hexe
        var hexBase = [
            [0, -1],
            [0.866, -0.5],
            [0.866, 0.5],
            [0, 1],
            [-0.866, 0.5],
            [-0.866, -0.5]
        ];
        var hexWidth = hexBinXScale.invert(actualResolution) - finalXExtent[0];
        var hexHeight = hexBinYScale.invert(actualResolution) - finalYExtent[0];
        var hexacoordinates = hexBase.map(function (d) { return [
            d[0] * hexWidth,
            d[1] * hexHeight
        ]; });
        var hexbinProjectedSummaries = hexes.map(function (d) {
            var hexValue = binValue(d);
            var gx = d.x;
            var gy = d.y;
            d.x = hexBinXScale.invert(d.x);
            d.y = hexBinYScale.invert(d.y);
            var percent = hexValue / hexMax;
            return {
                customMark: customMark && (React.createElement("g", { transform: "translate(" + gx + "," + (size[1] - gy) + ")" }, customMark({
                    d: __assign(__assign({}, d), { binItems: d, percent: percent, value: hexValue, radius: actualResolution, hexCoordinates: hexBase.map(function (d) { return [
                            d[0] * actualResolution,
                            d[1] * actualResolution
                        ]; }) }),
                    baseMarkProps: baseMarkProps,
                    margin: margin,
                    styleFn: styleFn,
                    classFn: classFn,
                    renderFn: renderFn,
                    chartSize: chartSize,
                    adjustedSize: size
                }))),
                _xyfCoordinates: hexacoordinates.map(function (p) { return [p[0] + d.x, p[1] + d.y]; }),
                value: hexValue,
                percent: percent,
                data: d,
                parentSummary: hexbinData,
                centroid: true
            };
        });
        projectedSummaries = __spread(projectedSummaries, hexbinProjectedSummaries);
    });
    if (preprocess) {
        projectedSummaries.forEach(function (d) {
            d.x = d.data.x;
            d.y = d.data.y;
        });
        return {
            type: "hexbin",
            processedData: true,
            coordinates: projectedSummaries,
            binMax: hexMax
        };
    }
    return projectedSummaries;
}
exports.hexbinning = hexbinning;
// ADD PRECALC AND EXPOSE PRECALC FUNCTION
function heatmapping(_a) {
    var _b = _a.preprocess, preprocess = _b === void 0 ? true : _b, _c = _a.processedData, processedData = _c === void 0 ? false : _c, baseSummaryType = _a.summaryType, baseData = _a.data, _d = _a.finalXExtent, finalXExtent = _d === void 0 ? [
        Math.min.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.x; }))),
        Math.max.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.x; })))
    ] : _d, _e = _a.finalYExtent, finalYExtent = _e === void 0 ? [
        Math.min.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.y; }))),
        Math.max.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.y; })))
    ] : _e, size = _a.size, _f = _a.xScaleType, xScaleType = _f === void 0 ? d3_scale_1.scaleLinear() : _f, _g = _a.yScaleType, yScaleType = _g === void 0 ? d3_scale_1.scaleLinear() : _g, margin = _a.margin, baseMarkProps = _a.baseMarkProps, styleFn = _a.styleFn, classFn = _a.classFn, renderFn = _a.renderFn, chartSize = _a.chartSize;
    if (processedData && baseData[0]) {
        return baseData[0].coordinates;
    }
    if (baseData.coordinates && !baseData._xyfCoordinates) {
        baseData._xyfCoordinates = baseData.coordinates.map(function (d) { return [d.x, d.y]; });
    }
    var data = Array.isArray(baseData) ? baseData : [baseData];
    var projectedSummaries = [];
    var summaryType;
    if (!baseSummaryType.type) {
        summaryType = { type: summaryType };
    }
    else {
        summaryType = baseSummaryType;
    }
    var 
    //    binGraphic = "square",
    _h = summaryType.binValue, 
    //    binGraphic = "square",
    binValue = _h === void 0 ? function (d) { return d.length; } : _h, _j = summaryType.xBins, xBins = _j === void 0 ? summaryType.yBins || 0.05 : _j, _k = summaryType.yBins, yBins = _k === void 0 ? xBins : _k, _l = summaryType.xCellPx, xCellPx = _l === void 0 ? !summaryType.xBins && summaryType.yCellPx : _l, _m = summaryType.yCellPx, yCellPx = _m === void 0 ? !summaryType.yBins && xCellPx : _m, customMark = summaryType.customMark, binMax = summaryType.binMax;
    var xBinPercent = xBins < 1 ? xBins : 1 / xBins;
    var yBinPercent = yBins < 1 ? yBins : 1 / yBins;
    var heatmapBinXScale = xScaleType.domain(finalXExtent).range([0, size[0]]);
    var heatmapBinYScale = yScaleType.domain(finalYExtent).range([size[1], 0]);
    var actualResolution = [
        Math.ceil(((xCellPx && xCellPx / size[0]) || xBinPercent) * size[0] * 10) /
            10,
        Math.ceil(((yCellPx && yCellPx / size[1]) || yBinPercent) * size[1] * 10) /
            10
    ];
    var maxValue = -Infinity;
    data.forEach(function (heatmapData) {
        var grid = [];
        var flatGrid = [];
        var cell;
        var gridColumn;
        for (var i = 0; i < size[0]; i += actualResolution[0]) {
            var x = heatmapBinXScale.invert(i);
            var x1 = heatmapBinXScale.invert(i + actualResolution[0]);
            gridColumn = [];
            grid.push(gridColumn);
            for (var j = 0; j < size[1]; j += actualResolution[1]) {
                var y = heatmapBinYScale.invert(j);
                var y1 = heatmapBinYScale.invert(j + actualResolution[1]);
                cell = {
                    gx: i,
                    gy: j,
                    gw: actualResolution[0],
                    gh: actualResolution[1],
                    x: (x + x1) / 2,
                    y: (y + y1) / 2,
                    binItems: [],
                    value: 0,
                    _xyfCoordinates: [
                        [x, y],
                        [x1, y],
                        [x1, y1],
                        [x, y1]
                    ],
                    parentSummary: heatmapData
                };
                gridColumn.push(cell);
                flatGrid.push(cell);
            }
            gridColumn.push(cell);
        }
        grid.push(gridColumn);
        heatmapData._xyfCoordinates.forEach(function (d, di) {
            var baseX = heatmapBinXScale(d[0]);
            var baseY = heatmapBinXScale(d[1]);
            var xCoordinate = Math.floor(baseX / actualResolution[0]);
            var yCoordinate = Math.floor(baseY / actualResolution[1]);
            if (grid[xCoordinate][yCoordinate]) {
                grid[xCoordinate][yCoordinate].binItems.push(heatmapData.coordinates[di]);
            }
        });
        flatGrid.forEach(function (d) {
            d.value = binValue(d.binItems);
            maxValue = Math.max(maxValue, d.value);
        });
        flatGrid.forEach(function (d) {
            d.percent = d.value / maxValue;
            d.customMark = customMark && (React.createElement("g", { transform: "translate(" + d.gx + "," + d.gy + ")" }, customMark({
                d: d,
                baseMarkProps: baseMarkProps,
                margin: margin,
                styleFn: styleFn,
                classFn: classFn,
                renderFn: renderFn,
                chartSize: chartSize,
                adjustedSize: size
            })));
        });
        projectedSummaries = __spread(projectedSummaries, flatGrid);
    });
    if (binMax) {
        binMax(maxValue);
    }
    if (preprocess) {
        return {
            type: "heatmap",
            processedData: true,
            coordinates: projectedSummaries,
            binMax: maxValue
        };
    }
    return projectedSummaries;
}
exports.heatmapping = heatmapping;
function trendlining(_a) {
    var _b = _a.preprocess, preprocess = _b === void 0 ? false : _b, baseSummaryType = _a.summaryType, baseData = _a.data, _c = _a.finalXExtent, finalXExtent = _c === void 0 ? [
        Math.min.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.x; }))),
        Math.max.apply(Math, __spread(baseData.coordinates.map(function (d) { return d.x; })))
    ] : _c, _d = _a.xScaleType, xScaleType = _d === void 0 ? d3_scale_1.scaleLinear() : _d;
    if (preprocess) {
        return baseData[0].coordinates;
    }
    var projectedSummaries = [];
    var summaryType;
    if (!baseSummaryType.type) {
        summaryType = { type: summaryType };
    }
    else {
        summaryType = baseSummaryType;
    }
    var _e = summaryType.regressionType, baseRegressionType = _e === void 0 ? "linear" : _e, _f = summaryType.order, order = _f === void 0 ? 2 : _f, _g = summaryType.precision, precision = _g === void 0 ? 4 : _g, _h = summaryType.controlPoints, controlPoints = _h === void 0 ? 20 : _h, _j = summaryType.curve, curve = _j === void 0 ? d3_shape_1.curveCardinal : _j;
    var regressionType = baseRegressionType;
    if (finalXExtent[0] < 0 &&
        (baseRegressionType === "logarithmic" ||
            baseRegressionType === "power" ||
            baseRegressionType === "exponential")) {
        console.error("Cannot use this " + baseRegressionType + " regressionType type with value range that goes below 0, defaulting to linear");
        regressionType = "linear";
    }
    if (baseData.coordinates && !baseData._xyfCoordinates) {
        baseData._xyfCoordinates = baseData.coordinates.map(function (d) { return [d.x, d.y]; });
    }
    var data = Array.isArray(baseData) ? baseData : [baseData];
    var xScale = xScaleType.domain([0, 1]).range(finalXExtent);
    projectedSummaries = [];
    data.forEach(function (bdata) {
        var regressionLine = regression_1.default[regressionType](bdata._xyfCoordinates.map(function (d) {
            var x = d[0];
            var y = d[1];
            if (typeof x !== "number") {
                x = x.getTime();
            }
            if (typeof y !== "number") {
                y = y.getTime();
            }
            return [x, y];
        }), {
            order: order,
            precision: precision
        });
        var controlStep = 1 / controlPoints;
        var steps = [0, 1];
        if (regressionType !== "linear") {
            steps = [];
            for (var step = 0; step < 1 + controlStep; step += controlStep) {
                steps.push(step);
            }
        }
        var controlPointArray = [];
        steps.forEach(function (controlPoint) {
            controlPointArray.push(regressionLine.predict(xScale(controlPoint)));
        });
        projectedSummaries.push({
            centroid: false,
            customMark: undefined,
            data: bdata,
            parentSummary: bdata,
            value: regressionLine.string,
            r2: regressionLine.r2,
            curve: curve,
            _xyfCoordinates: controlPointArray
        });
    });
    return projectedSummaries;
}
exports.trendlining = trendlining;
function shapeBounds(coordinates) {
    var left = [Infinity, 0];
    var right = [-Infinity, 0];
    var top = [0, Infinity];
    var bottom = [0, -Infinity];
    coordinates.forEach(function (d) {
        left = d[0] < left[0] ? d : left;
        right = d[0] > right[0] ? d : right;
        bottom = d[1] > bottom[1] ? d : bottom;
        top = d[1] < top[1] ? d : top;
    });
    return {
        center: [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2],
        top: top,
        left: left,
        right: right,
        bottom: bottom
    };
}
exports.shapeBounds = shapeBounds;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
function pointOnArcAtAngle(center, angle, distance) {
    var radians = Math.PI * (angle + 0.75) * 2;
    var xPosition = center[0] + distance * Math.cos(radians);
    var yPosition = center[1] + distance * Math.sin(radians);
    return [xPosition, yPosition];
}
exports.pointOnArcAtAngle = pointOnArcAtAngle;
exports.renderLaidOutPieces = function (_a) {
    var data = _a.data, shouldRender = _a.shouldRender, canvasRender = _a.canvasRender, canvasDrawing = _a.canvasDrawing, styleFn = _a.styleFn, classFn = _a.classFn, baseMarkProps = _a.baseMarkProps, renderKeyFn = _a.renderKeyFn, ariaLabel = _a.ariaLabel, axis = _a.axis;
    var valueFormat = axis && axis[0] && axis[0].tickFormat;
    if (!shouldRender)
        return null;
    var renderedPieces = [];
    data.forEach(function (d, i) {
        if (canvasRender && canvasRender(d) === true) {
            var canvasPiece = {
                baseClass: "orframe-piece",
                tx: d.renderElement.tx || 0,
                ty: d.renderElement.ty || 0,
                d: d.piece,
                i: i,
                markProps: d.renderElement || d,
                styleFn: styleFn,
                classFn: classFn
            };
            canvasDrawing.push(canvasPiece);
        }
        else {
            if (React.isValidElement(d.renderElement || d)) {
                renderedPieces.push(d.renderElement || d);
            }
            else {
                /*ariaLabel.items*/
                var pieceAriaLabel = d.o + " " + ariaLabel.items + " value " + ((valueFormat && valueFormat(d.piece.value)) || d.piece.value);
                renderedPieces.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: renderKeyFn
                        ? renderKeyFn(d.piece)
                        : d.renderKey || "piece-render-" + i }, d.renderElement || d, { "aria-label": pieceAriaLabel })));
            }
        }
    });
    return renderedPieces;
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
var d3_shape_1 = __webpack_require__(18);
var areaDrawing_1 = __webpack_require__(83);
exports.curveHash = {
    step: d3_shape_1.curveStep,
    stepbefore: d3_shape_1.curveStepBefore,
    stepafter: d3_shape_1.curveStepAfter,
    cardinal: d3_shape_1.curveCardinal,
    basis: d3_shape_1.curveBasis,
    linear: d3_shape_1.curveLinear,
    catmullrom: d3_shape_1.curveCatmullRom,
    monotone: d3_shape_1.curveMonotoneY,
    monotonex: d3_shape_1.curveMonotoneX,
    monotoney: d3_shape_1.curveMonotoneY,
    natural: d3_shape_1.curveNatural
};
function lineGeneratorDecorator(_a) {
    var generator = _a.generator, projectedCoordinateNames = _a.projectedCoordinateNames, defined = _a.defined, xScale = _a.xScale, yScale = _a.yScale, interpolator = _a.interpolator, simpleLine = _a.simpleLine;
    var x = projectedCoordinateNames.x, y = projectedCoordinateNames.y, yTop = projectedCoordinateNames.yTop, yBottom = projectedCoordinateNames.yBottom, xBottom = projectedCoordinateNames.xBottom, xTop = projectedCoordinateNames.xTop;
    generator.x(function (d) { return xScale(d[x]); }).curve(interpolator);
    if (simpleLine) {
        generator.y(function (d) { return yScale(d[y]); });
    }
    else {
        generator.y0(function (d) { return yScale(d[yBottom]); }).y1(function (d) { return yScale(d[yTop]); });
        generator.x0(function (d) { return xScale(d[xBottom]); }).x1(function (d) { return xScale(d[xTop]); });
    }
    if (defined) {
        generator.defined(function (p, q) { return defined(p, q); });
    }
    else {
        generator.defined(function (p) { return !p._xyFrameUndefined; });
    }
}
exports.lineGeneratorDecorator = lineGeneratorDecorator;
function createPoints(_a) {
    var xScale = _a.xScale, yScale = _a.yScale, canvasDrawing = _a.canvasDrawing, data = _a.data, projectedCoordinateNames = _a.projectedCoordinateNames, customMark = _a.customMark, canvasRender = _a.canvasRender, styleFn = _a.styleFn, classFn = _a.classFn, renderKeyFn = _a.renderKeyFn, renderMode = _a.renderMode, baseMarkProps = _a.baseMarkProps, baseShowLinePoints = _a.showLinePoints;
    var y = projectedCoordinateNames.y, x = projectedCoordinateNames.x, xMiddle = projectedCoordinateNames.xMiddle, yMiddle = projectedCoordinateNames.yMiddle, yTop = projectedCoordinateNames.yTop, yBottom = projectedCoordinateNames.yBottom;
    var showLinePoints = baseShowLinePoints === true ? undefined : baseShowLinePoints;
    var whichPoints = {
        top: yTop,
        bottom: yBottom
    };
    var whichWay = whichPoints[showLinePoints];
    var mappedPoints = [];
    data.forEach(function (d, i) {
        var dX = xScale(d[xMiddle] !== undefined ? d[xMiddle] : d[x]);
        var dY = yScale(d[whichWay] !== undefined
            ? d[whichWay]
            : d[yMiddle] !== undefined
                ? d[yMiddle]
                : d[y]);
        var pointAriaLabel = "Point at x " + d.x + " and y " + d.y;
        // CUSTOM MARK IMPLEMENTATION
        var renderedCustomMark = !customMark
            ? undefined
            : React.isValidElement(customMark)
                ? customMark
                : customMark({ d: d.data, xy: d, i: i, xScale: xScale, yScale: yScale });
        var markProps = customMark
            ? Object.assign(baseMarkProps, renderedCustomMark.props, {
                "aria-label": pointAriaLabel
            })
            : __assign(__assign({}, baseMarkProps), { key: "piece-" + i, markType: "circle", r: 2, "aria-label": pointAriaLabel });
        if (renderedCustomMark &&
            renderedCustomMark.props &&
            !renderedCustomMark.props.markType &&
            (!canvasRender || canvasRender(d.data, i) !== true)) {
            mappedPoints.push(React.createElement("g", { transform: "translate(" + dX + "," + dY + ")", key: renderKeyFn ? renderKeyFn(d.data, i) : "custom-point-mark-" + i, style: styleFn ? styleFn(d.data, i) : {}, className: classFn ? classFn(d.data, i) : "" }, renderedCustomMark));
        }
        else {
            if (canvasRender && canvasRender(d.data, i) === true) {
                var canvasPoint = {
                    type: "point",
                    baseClass: "frame-piece",
                    tx: dX,
                    ty: dY,
                    d: d,
                    i: i,
                    markProps: markProps,
                    styleFn: styleFn,
                    renderFn: renderMode,
                    classFn: classFn
                };
                canvasDrawing.push(canvasPoint);
            }
            else {
                var yCoordinates = Array.isArray(d[y])
                    ? d[y].map(function (p) { return yScale(p); })
                    : [dY];
                yCoordinates.forEach(function (yc, yi) {
                    var xCoordinates = Array.isArray(d[x])
                        ? d[x].map(function (p) { return xScale(p); })
                        : [dX];
                    xCoordinates.forEach(function (xc, xi) {
                        mappedPoints.push(clonedAppliedElement({
                            baseClass: "frame-piece",
                            tx: xc,
                            ty: yc,
                            d: (d.data && __assign(__assign({}, d), d.data)) || d,
                            i: yi === 0 && xi === 0 ? i : i + "-" + yi + "-" + xi,
                            markProps: markProps,
                            styleFn: styleFn,
                            renderFn: renderMode,
                            renderKeyFn: renderKeyFn,
                            classFn: classFn,
                            yi: yi
                        }));
                    });
                });
            }
        }
    });
    return mappedPoints;
}
exports.createPoints = createPoints;
function createLines(_a) {
    var xScale = _a.xScale, yScale = _a.yScale, canvasDrawing = _a.canvasDrawing, data = _a.data, projectedCoordinateNames = _a.projectedCoordinateNames, customMark = _a.customMark, canvasRender = _a.canvasRender, styleFn = _a.styleFn, classFn = _a.classFn, renderMode = _a.renderMode, renderKeyFn = _a.renderKeyFn, type = _a.type, defined = _a.defined, baseMarkProps = _a.baseMarkProps, ariaLabel = _a.ariaLabel, _b = _a.axesData, axesData = _b === void 0 ? [] : _b;
    var xAxis = axesData.find(function (d) { return d.orient === "bottom" || d.orient === "top"; });
    var yAxis = axesData.find(function (d) { return d.orient === "left" || d.orient === "right"; });
    var xAxisFormatter = (xAxis && xAxis.tickFormat) || (function (d) { return d; });
    var yAxisFormatter = (yAxis && yAxis.tickFormat) || (function (d) { return d; });
    var customLine = typeof type === "object" ? type : { type: type };
    var interpolator = typeof customLine.interpolator === "string"
        ? exports.curveHash[customLine.interpolator]
        : customLine.interpolator || d3_shape_1.curveLinear;
    var lineGenerator = customLine.simpleLine ? d3_shape_1.line() : d3_shape_1.area();
    lineGeneratorDecorator({
        projectedCoordinateNames: projectedCoordinateNames,
        defined: defined,
        interpolator: interpolator,
        generator: lineGenerator,
        xScale: xScale,
        yScale: yScale,
        simpleLine: customLine.simpleLine
    });
    var dynamicLineGenerator = (interpolator.dynamicInterpolator &&
        (function (d, i) {
            var dynLineGenerator = d3_shape_1.area();
            lineGeneratorDecorator({
                projectedCoordinateNames: projectedCoordinateNames,
                defined: defined,
                interpolator: interpolator.dynamicInterpolator(d, i),
                generator: dynLineGenerator,
                xScale: xScale,
                yScale: yScale,
                simpleLine: customLine.simpleLine
            });
            return dynLineGenerator;
        })) ||
        (function () { return lineGenerator; });
    var mappedLines = [];
    data.forEach(function (d, i) {
        if (customMark && typeof customMark === "function") {
            //shim to make customLineMark work until Semiotic 2
            var compatibleData = __assign(__assign({}, d), { data: d.data.map(function (p) { return (__assign(__assign({}, p.data), p)); }) });
            mappedLines.push(customMark({ d: compatibleData, i: i, xScale: xScale, yScale: yScale, canvasDrawing: canvasDrawing }));
        }
        else {
            var builtInDisplayProps = {};
            if (customLine.simpleLine) {
                builtInDisplayProps.fill = "none";
                builtInDisplayProps.stroke = "black";
            }
            var pathString = dynamicLineGenerator(d, i)(d.data.map(function (p) { return Object.assign({}, p.data, p); }));
            var markProps = __assign(__assign(__assign({}, builtInDisplayProps), baseMarkProps), { markType: "path", d: pathString, "aria-label": d.data &&
                    d.data.length > 0 &&
                    d.data.length + " point " + ariaLabel.items + " starting value " + yAxisFormatter(d.data[0].y) + " at " + xAxisFormatter(d.data[0].x) + " ending value " + yAxisFormatter(d.data[d.data.length - 1].y) + " at " + xAxisFormatter(d.data[d.data.length - 1].x) });
            if (canvasRender && canvasRender(d, i) === true) {
                var canvasLine = {
                    type: "line",
                    baseClass: "xyframe-line",
                    tx: 0,
                    ty: 0,
                    d: d,
                    i: i,
                    markProps: markProps,
                    styleFn: styleFn,
                    renderFn: renderMode,
                    classFn: classFn
                };
                canvasDrawing.push(canvasLine);
            }
            else {
                mappedLines.push(clonedAppliedElement({
                    baseClass: "xyframe-line",
                    d: d,
                    i: i,
                    markProps: markProps,
                    styleFn: styleFn,
                    renderFn: renderMode,
                    renderKeyFn: renderKeyFn,
                    classFn: classFn
                }));
            }
        }
    });
    if (customLine.type === "difference" && data.length === 2) {
        //Create the overlay line for the difference chart
        var diffdataA = data[0].data.map(function (basedata, baseI) {
            var linePoint = basedata.yTop > data[1].data[baseI].yTop
                ? basedata.yTop
                : basedata.yBottom;
            return {
                x: basedata.x,
                y: linePoint,
                yBottom: linePoint,
                yTop: linePoint
            };
        });
        var diffdataB = data[0].data.map(function (basedata, baseI) {
            var linePoint = data[1].data[baseI].yTop > basedata.yTop
                ? data[1].data[baseI].yTop
                : data[1].data[baseI].yBottom;
            return {
                x: basedata.x,
                y: linePoint,
                yBottom: linePoint,
                yTop: linePoint
            };
        });
        var doClassname = classFn
            ? "xyframe-line " + classFn(diffdataA)
            : "xyframe-line";
        var overLine = d3_shape_1.line();
        lineGeneratorDecorator({
            projectedCoordinateNames: projectedCoordinateNames,
            defined: defined,
            interpolator: interpolator,
            generator: overLine,
            xScale: xScale,
            yScale: yScale,
            simpleLine: true
        });
        //      let baseStyle = props.lineStyle ? props.lineStyle(diffdata, 0) : {}
        var diffOverlayA = (React.createElement(semiotic_mark_1.Mark, { key: "xyline-diff-a", className: doClassname + " difference-overlay-a", markType: "path", d: overLine(diffdataA), style: { fill: "none", pointerEvents: "none" } }));
        mappedLines.push(diffOverlayA);
        var diffOverlayB = (React.createElement(semiotic_mark_1.Mark, { key: "xyline-diff-b", className: doClassname + " difference-overlay-b", markType: "path", d: overLine(diffdataB), style: { fill: "none", pointerEvents: "none" } }));
        mappedLines.push(diffOverlayB);
    }
    return mappedLines;
}
exports.createLines = createLines;
function createSummaries(_a) {
    var xScale = _a.xScale, yScale = _a.yScale, canvasDrawing = _a.canvasDrawing, data = _a.data, canvasRender = _a.canvasRender, styleFn = _a.styleFn, classFn = _a.classFn, renderKeyFn = _a.renderKeyFn, renderMode = _a.renderMode, baseMarkProps = _a.baseMarkProps, customMark = _a.customMark;
    var summaryClass = classFn || (function () { return ""; });
    var summaryStyle = styleFn || (function () { return ({}); });
    var renderFn = renderMode;
    if (!Array.isArray(data)) {
        data = [data];
    }
    var renderedSummaries = [];
    data.forEach(function (d, i) {
        var className = "xyframe-summary";
        if (summaryClass) {
            className = "xyframe-summary " + summaryClass(d);
        }
        var drawD = "";
        var shouldBeValid = false;
        if (typeof d.customMark === "string" ||
            React.isValidElement(d.customMark)) {
            drawD = d.customMark;
            shouldBeValid = true;
        }
        else if (d.type === "MultiPolygon") {
            var polycoords = d.coordinates;
            polycoords.forEach(function (coord) {
                coord.forEach(function (c) {
                    drawD += "M" + c
                        .map(function (p) { return xScale(p[0]) + "," + yScale(p[1]); })
                        .join("L") + "Z ";
                });
            });
        }
        else if (customMark) {
            var xyfCoords = d._xyfCoordinates;
            var projectedCoordinates = xyfCoords.map(function (p) { return [
                xScale(p[0]),
                yScale(p[1])
            ]; });
            // CUSTOM MARK IMPLEMENTATION
            drawD = customMark({
                d: d,
                i: i,
                classFn: summaryClass,
                styleFn: summaryStyle,
                renderFn: renderFn,
                projectedCoordinates: projectedCoordinates,
                xScale: xScale,
                yScale: yScale,
                bounds: areaDrawing_1.shapeBounds(projectedCoordinates)
            });
            shouldBeValid = true;
        }
        else {
            var xyfCoords = d._xyfCoordinates;
            if (d.curve) {
                var lineDrawing = d3_shape_1.line()
                    .x(function (d) { return xScale(d[0]); })
                    .y(function (d) { return yScale(d[1]); })
                    .curve(d.curve);
                drawD = lineDrawing(xyfCoords);
            }
            else {
                drawD = "M" + xyfCoords
                    .map(function (p) { return xScale(p[0]) + "," + yScale(p[1]); })
                    .join("L") + "Z";
            }
        }
        var renderKey = renderKeyFn ? renderKeyFn(d, i) : "summary-" + i;
        if (shouldBeValid && React.isValidElement(drawD)) {
            renderedSummaries.push(drawD);
        }
        else if (canvasRender && canvasRender(d, i) === true) {
            var canvasSummary = {
                type: "summary",
                baseClass: "xyframe-summary",
                tx: 0,
                ty: 0,
                d: d,
                i: i,
                markProps: { markType: "path", d: drawD },
                styleFn: summaryStyle,
                renderFn: renderFn,
                classFn: function () { return className; }
            };
            canvasDrawing.push(canvasSummary);
        }
        else {
            renderedSummaries.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: renderKey, forceUpdate: true, renderMode: renderFn ? renderFn(d, i) : undefined, className: className, markType: "path", d: drawD, style: summaryStyle(d, i) })));
        }
    });
    return renderedSummaries;
}
exports.createSummaries = createSummaries;
function clonedAppliedElement(_a) {
    var tx = _a.tx, ty = _a.ty, d = _a.d, i = _a.i, markProps = _a.markProps, styleFn = _a.styleFn, renderFn = _a.renderFn, classFn = _a.classFn, renderKeyFn = _a.renderKeyFn, baseClass = _a.baseClass, yi = _a.yi;
    markProps.style = styleFn ? styleFn(d, i, yi) : {};
    markProps.className = baseClass;
    markProps.key = renderKeyFn
        ? renderKeyFn(d, i, yi)
        : baseClass + "-" + (d.key === undefined ? i : d.key);
    if (tx || ty) {
        markProps.transform = "translate(" + (tx || 0) + "," + (ty || 0) + ")";
    }
    if (classFn) {
        markProps.className = baseClass + " " + classFn(d, i, yi);
    }
    if (markProps.style.r) {
        markProps.r = markProps.style.r;
    }
    if (!markProps.markType) {
        var RenderableMark = markProps;
        return React.createElement(RenderableMark);
    }
    markProps.renderMode = renderFn ? renderFn(d, i, yi) : undefined;
    return React.createElement(semiotic_mark_1.Mark, __assign({}, markProps));
}
exports.clonedAppliedElement = clonedAppliedElement;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var element_resize_event_1 = __importDefault(__webpack_require__(325));
var createResponsiveFrame = function (ParticularFrame) {
    var _a;
    return _a = /** @class */ (function (_super) {
            __extends(ResponsiveFrame, _super);
            function ResponsiveFrame(props) {
                var _this = _super.call(this, props) || this;
                _this.node = null;
                _this.isResizing = undefined;
                _this._onResize = function (width, height) {
                    _this.setState({ containerHeight: height, containerWidth: width });
                };
                _this.state = {
                    containerHeight: undefined,
                    containerWidth: undefined
                };
                return _this;
            }
            ResponsiveFrame.prototype.componentDidMount = function () {
                var _this = this;
                var element = this.node;
                var debounce = this.props.debounce;
                var actualElementResizeEvent = this.props.elementResizeEvent || element_resize_event_1.default;
                actualElementResizeEvent(element, function () {
                    window.clearTimeout(_this.isResizing);
                    _this.isResizing = setTimeout(function () {
                        _this.isResizing = false;
                        _this.setState({
                            containerHeight: element.offsetHeight,
                            containerWidth: element.offsetWidth
                        });
                    }, debounce);
                });
                this.setState({
                    containerHeight: element.offsetHeight,
                    containerWidth: element.offsetWidth
                });
            };
            ResponsiveFrame.prototype.render = function () {
                var _this = this;
                var _a = this.props, responsiveWidth = _a.responsiveWidth, responsiveHeight = _a.responsiveHeight, size = _a.size, dataVersion = _a.dataVersion, debounce = _a.debounce, gridDisplay = _a.gridDisplay, rest = __rest(_a, ["responsiveWidth", "responsiveHeight", "size", "dataVersion", "debounce", "gridDisplay"]);
                var _b = this.state, containerHeight = _b.containerHeight, containerWidth = _b.containerWidth;
                var actualSize = __spread(size);
                var returnEmpty = false;
                if (responsiveWidth) {
                    if (!containerWidth)
                        returnEmpty = true;
                    actualSize[0] = containerWidth;
                }
                if (responsiveHeight) {
                    if (!containerHeight)
                        returnEmpty = true;
                    actualSize[1] = containerHeight;
                }
                var dataVersionWithSize = dataVersion + actualSize.toString() + debounce;
                return (React.createElement("div", { className: "responsive-container", style: gridDisplay
                        ? { minWidth: "0px", minHeight: "0px" }
                        : { height: "100%", width: "100%" }, ref: function (node) { return (_this.node = node); } }, !returnEmpty && (React.createElement(ParticularFrame, __assign({}, rest, { size: actualSize, dataVersion: dataVersion ? dataVersionWithSize : undefined })))));
            };
            return ResponsiveFrame;
        }(React.Component)),
        _a.defaultProps = {
            size: [500, 500],
            debounce: 200
        },
        _a.displayName = "Responsive" + ParticularFrame.displayName,
        _a;
};
exports.default = createResponsiveFrame;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(22),
    stubFalse = __webpack_require__(344);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(133)(module)))

/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(90),
    stackClear = __webpack_require__(356),
    stackDelete = __webpack_require__(357),
    stackGet = __webpack_require__(358),
    stackHas = __webpack_require__(359),
    stackSet = __webpack_require__(360);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(351),
    listCacheDelete = __webpack_require__(352),
    listCacheGet = __webpack_require__(353),
    listCacheHas = __webpack_require__(354),
    listCacheSet = __webpack_require__(355);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(75);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(373);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(388),
    Map = __webpack_require__(142),
    Promise = __webpack_require__(389),
    Set = __webpack_require__(390),
    WeakMap = __webpack_require__(391),
    baseGetTag = __webpack_require__(42),
    toSource = __webpack_require__(193);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(95);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(188),
    baseKeysIn = __webpack_require__(413),
    isArrayLike = __webpack_require__(54);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* reexport */ cluster; });
__webpack_require__.d(__webpack_exports__, "hierarchy", function() { return /* reexport */ hierarchy; });
__webpack_require__.d(__webpack_exports__, "pack", function() { return /* reexport */ src_pack; });
__webpack_require__.d(__webpack_exports__, "packSiblings", function() { return /* reexport */ siblings; });
__webpack_require__.d(__webpack_exports__, "packEnclose", function() { return /* reexport */ enclose; });
__webpack_require__.d(__webpack_exports__, "partition", function() { return /* reexport */ src_partition; });
__webpack_require__.d(__webpack_exports__, "stratify", function() { return /* reexport */ src_stratify; });
__webpack_require__.d(__webpack_exports__, "tree", function() { return /* reexport */ tree; });
__webpack_require__.d(__webpack_exports__, "treemap", function() { return /* reexport */ src_treemap; });
__webpack_require__.d(__webpack_exports__, "treemapBinary", function() { return /* reexport */ binary; });
__webpack_require__.d(__webpack_exports__, "treemapDice", function() { return /* reexport */ dice; });
__webpack_require__.d(__webpack_exports__, "treemapSlice", function() { return /* reexport */ treemap_slice; });
__webpack_require__.d(__webpack_exports__, "treemapSliceDice", function() { return /* reexport */ sliceDice; });
__webpack_require__.d(__webpack_exports__, "treemapSquarify", function() { return /* reexport */ squarify; });
__webpack_require__.d(__webpack_exports__, "treemapResquarify", function() { return /* reexport */ treemap_resquarify; });

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

/* harmony default export */ var cluster = (function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

/* harmony default export */ var hierarchy_count = (function() {
  return this.eachAfter(count);
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/each.js
/* harmony default export */ var each = (function(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
/* harmony default export */ var eachBefore = (function(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
/* harmony default export */ var eachAfter = (function(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/sum.js
/* harmony default export */ var sum = (function(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/sort.js
/* harmony default export */ var sort = (function(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/path.js
/* harmony default export */ var path = (function(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
});

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/ancestors.js
/* harmony default export */ var ancestors = (function() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/descendants.js
/* harmony default export */ var descendants = (function() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/leaves.js
/* harmony default export */ var leaves = (function() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/links.js
/* harmony default export */ var links = (function() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/hierarchy/index.js












function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: hierarchy_count,
  each: each,
  eachAfter: eachAfter,
  eachBefore: eachBefore,
  sum: sum,
  sort: sort,
  path: path,
  ancestors: ancestors,
  descendants: descendants,
  leaves: leaves,
  links: links,
  copy: node_copy
};

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/array.js
var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/enclose.js


/* harmony default export */ var enclose = (function(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
});

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/siblings.js


function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function siblings_Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new siblings_Node(a), b = new siblings_Node(b), c = new siblings_Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new siblings_Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

/* harmony default export */ var siblings = (function(circles) {
  packEnclose(circles);
  return circles;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}

/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/pack/index.js




function defaultRadius(d) {
  return Math.sqrt(d.value);
}

/* harmony default export */ var src_pack = (function() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
});

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/round.js
/* harmony default export */ var treemap_round = (function(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/dice.js
/* harmony default export */ var dice = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/partition.js



/* harmony default export */ var src_partition = (function() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(treemap_round);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        dice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/stratify.js



var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

/* harmony default export */ var src_stratify = (function() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/tree.js


function tree_defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ var tree = (function() {
  var separation = tree_defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/slice.js
/* harmony default export */ var treemap_slice = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/squarify.js



var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) dice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemap_slice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

/* harmony default export */ var squarify = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi));

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/index.js





/* harmony default export */ var src_treemap = (function() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(treemap_round);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/binary.js
/* harmony default export */ var binary = (function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/sliceDice.js



/* harmony default export */ var sliceDice = (function(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemap_slice : dice)(parent, x0, y0, x1, y1);
});

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/treemap/resquarify.js




/* harmony default export */ var treemap_resquarify = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) dice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemap_slice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi));

// CONCATENATED MODULE: ./node_modules/d3-hierarchy/src/index.js

















/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);


/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* Selection */ "a"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* Selection */ "a"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__[/* root */ "c"]);
});


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return styleValue; });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);


/* harmony default export */ __webpack_exports__["a"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__[/* basis */ "a"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
});


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return genericArray; });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);



/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return (Object(_numberArray_js__WEBPACK_IMPORTED_MODULE_1__[/* isNumberArray */ "b"])(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"] : genericArray)(a, b);
});

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);


/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


/* harmony default export */ __webpack_exports__["a"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(_ascending_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(f(d), x);
  };
}


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return quickselect; });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

/* harmony default export */ __webpack_exports__["default"] = (memoizeOne);


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "transition", function() { return /* reexport */ src_transition_transition; });
__webpack_require__.d(__webpack_exports__, "active", function() { return /* reexport */ src_active; });
__webpack_require__.d(__webpack_exports__, "interrupt", function() { return /* reexport */ interrupt; });

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/index.js + 31 modules
var selection = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(521);

// EXTERNAL MODULE: ./node_modules/d3-timer/src/timer.js
var timer = __webpack_require__(229);

// CONCATENATED MODULE: ./node_modules/d3-timer/src/timeout.js


/* harmony default export */ var timeout = (function(callback, delay, time) {
  var t = new timer["a" /* Timer */];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/schedule.js



var emptyOn = Object(dispatch["a" /* default */])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ var transition_schedule = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(timer["c" /* timer */])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-transition/src/interrupt.js


/* harmony default export */ var interrupt = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/interrupt.js


/* harmony default export */ var selection_interrupt = (function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
});

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/transform/index.js + 2 modules
var transform = __webpack_require__(150);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/namespace.js
var namespace = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/tween.js


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ var transition_tween = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

// EXTERNAL MODULE: ./node_modules/d3-color/src/color.js
var color = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/rgb.js
var rgb = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/string.js
var string = __webpack_require__(104);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/interpolate.js



/* harmony default export */ var transition_interpolate = (function(a, b) {
  var c;
  return (typeof b === "number" ? number["a" /* default */]
      : b instanceof color["e" /* default */] ? rgb["a" /* default */]
      : (c = Object(color["e" /* default */])(b)) ? (b = c, rgb["a" /* default */])
      : string["a" /* default */])(a, b);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attr.js





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ var attr = (function(name, value) {
  var fullname = Object(namespace["a" /* default */])(name), i = fullname === "transform" ? transform["b" /* interpolateTransformSvg */] : transition_interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attrTween.js


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_attrTween = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(namespace["a" /* default */])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/delay.js


function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

/* harmony default export */ var transition_delay = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/duration.js


function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

/* harmony default export */ var duration = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/ease.js


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

/* harmony default export */ var ease = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = __webpack_require__(101);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/filter.js



/* harmony default export */ var filter = (function(match) {
  if (typeof match !== "function") match = Object(matcher["a" /* default */])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/merge.js


/* harmony default export */ var transition_merge = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/on.js


function on_start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = on_start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ var transition_on = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/remove.js
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ var transition_remove = (function() {
  return this.on("end.remove", removeFunction(this._id));
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selector.js
var selector = __webpack_require__(57);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/select.js




/* harmony default export */ var transition_select = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(selector["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        transition_schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selectorAll.js
var selectorAll = __webpack_require__(100);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selectAll.js




/* harmony default export */ var selectAll = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(selectorAll["a" /* default */])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            transition_schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selection.js


var Selection = selection["b" /* default */].prototype.constructor;

/* harmony default export */ var transition_selection = (function() {
  return new Selection(this._groups, this._parents);
});

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/style.js
var style = __webpack_require__(102);

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/style.js






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(style["b" /* styleValue */])(this, name),
        string1 = (this.style.removeProperty(name), Object(style["b" /* styleValue */])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(style["b" /* styleValue */])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(style["b" /* styleValue */])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(style["b" /* styleValue */])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ var transition_style = (function(name, value, priority) {
  var i = (name += "") === "transform" ? transform["a" /* interpolateTransformCss */] : transition_interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_styleTween = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/text.js


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ var transition_text = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_textTween = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/transition.js



/* harmony default export */ var transition_transition = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        transition_schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/end.js


/* harmony default export */ var transition_end = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/index.js





















var transition_id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function src_transition_transition(name) {
  return Object(selection["b" /* default */])().transition(name);
}

function newId() {
  return ++transition_id;
}

var selection_prototype = selection["b" /* default */].prototype;

Transition.prototype = src_transition_transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: selectAll,
  filter: filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: duration,
  ease: ease,
  end: transition_end
};

// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/transition.js





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function transition_inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(timer["b" /* now */])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ var selection_transition = (function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = Object(timer["b" /* now */])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        transition_schedule(node, name, id, i, group, timing || transition_inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/index.js




selection["b" /* default */].prototype.interrupt = selection_interrupt;
selection["b" /* default */].prototype.transition = selection_transition;

// CONCATENATED MODULE: ./node_modules/d3-transition/src/active.js



var root = [null];

/* harmony default export */ var src_active = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/index.js






/***/ }),
/* 113 */,
/* 114 */,
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.memoize = exports.findPrevColumnNotHidden = exports.findNextColumnNotHidden = exports.checkErrors = exports.enableStickyPosition = exports.sortColumns = exports.isNotFixed = exports.isRightFixed = exports.isLeftFixed = exports.getColumnId = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var getColumnId = function getColumnId(column) {
  if (column.id) return column.id;
  if (typeof column.accessor === 'string') return column.accessor;
  return null;
};

exports.getColumnId = getColumnId;

var isLeftFixed = function isLeftFixed(column) {
  return [true, 'left'].includes(column.fixed);
};

exports.isLeftFixed = isLeftFixed;

var isRightFixed = function isRightFixed(column) {
  return column.fixed === 'right';
};

exports.isRightFixed = isRightFixed;

var isNotFixed = function isNotFixed(column) {
  return !column.fixed;
};

exports.isNotFixed = isNotFixed;

var sortColumns = function sortColumns(columns) {
  return _toConsumableArray(columns.filter(isLeftFixed)).concat(_toConsumableArray(columns.filter(isNotFixed)), _toConsumableArray(columns.filter(isRightFixed)));
};

exports.sortColumns = sortColumns;

var enableStickyPosition = function enableStickyPosition() {
  if (typeof window === 'undefined') return true; // document is undefined in SSR

  var el = document.createElement('a');
  var mStyle = el.style;
  mStyle.cssText = 'position:sticky;position:-webkit-sticky;position:-ms-sticky;';
  return mStyle.position.indexOf('sticky') !== -1;
};

exports.enableStickyPosition = enableStickyPosition;

var checkErrors = function checkErrors(columns) {
  var hasGroups = !!columns.find(function (column) {
    return column.columns;
  });
  var fixedColumnsWithoutGroup = columns.filter(function (column) {
    return column.fixed && !column.columns;
  }).map(function (_ref) {
    var Header = _ref.Header;
    return "'".concat(Header, "'");
  });

  if (hasGroups && fixedColumnsWithoutGroup.length) {
    throw new Error("WARNING react-table-hoc-fixed-column:\n          \nYour ReactTable has group and fixed columns outside groups, and that will break UI.\n          \nYou must place ".concat(fixedColumnsWithoutGroup.join(' and '), " columns into a group (even a group with an empty Header label)\n"));
  }

  var bugWithUnderColumnsFixed = columns.find(function (parentCol) {
    return !parentCol.fixed && parentCol.columns && parentCol.columns.find(function (col) {
      return col.fixed;
    });
  });

  if (bugWithUnderColumnsFixed) {
    var childBugs = bugWithUnderColumnsFixed.columns.find(function (_ref2) {
      var fixed = _ref2.fixed;
      return fixed;
    });
    throw new Error("WARNING react-table-hoc-fixed-column:\n          \nYour ReactTable contain columns group with at least one child columns fixed.\n          \nWhen ReactTable has columns groups, only columns groups can be fixed\n          \nYou must set fixed: 'left' | 'right' for the '".concat(bugWithUnderColumnsFixed.Header, "' column, or remove the fixed property of '").concat(childBugs.Header, "' column."));
  }
};

exports.checkErrors = checkErrors;

var findNextColumnNotHidden = function findNextColumnNotHidden(columns, currentIndex) {
  for (var i = currentIndex + 1; i < columns.length; i += 1) {
    var column = columns[i];
    if (column.show !== false) return column;
  }

  return undefined;
};

exports.findNextColumnNotHidden = findNextColumnNotHidden;

var findPrevColumnNotHidden = function findPrevColumnNotHidden(columns, currentIndex) {
  for (var i = currentIndex - 1; i >= 0; i -= 1) {
    var column = columns[i];
    if (column.show !== false) return column;
  }

  return undefined;
};

exports.findPrevColumnNotHidden = findPrevColumnNotHidden;

var areArgumentsEqual = function areArgumentsEqual(prevArgs, currentArgs) {
  if (!prevArgs || !currentArgs) return false;
  if (prevArgs.length !== currentArgs.length) return false;
  var prevArgSize = prevArgs.length;

  for (var index = 0; index < prevArgSize; index += 1) {
    if (prevArgs[index] !== currentArgs[index]) {
      return false;
    }
  }

  return true;
};

var memoize = function memoize(funcToMemoize) {
  var prevArgs;
  var memoizedResult;

  var getMemoizedFunction = function getMemoizedFunction() {
    for (var _len = arguments.length, currentArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      currentArgs[_key] = arguments[_key];
    }

    if (!areArgumentsEqual(prevArgs, currentArgs)) {
      memoizedResult = funcToMemoize.apply(void 0, currentArgs);
    }

    prevArgs = currentArgs;
    return memoizedResult;
  };

  return getMemoizedFunction;
};

exports.memoize = memoize;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _typeLine = _interopRequireDefault(__webpack_require__(162));

var _Connector2 = _interopRequireDefault(__webpack_require__(117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorLine =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorLine, _Connector);

  function ConnectorLine() {
    _classCallCheck(this, ConnectorLine);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorLine).apply(this, arguments));
  }

  _createClass(ConnectorLine, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          radius = _ref.radius,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height;
      return (0, _typeLine.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        outerRadius: outerRadius,
        width: width,
        height: height
      });
    }
  }]);

  return ConnectorLine;
}(_Connector2.default);

exports.default = ConnectorLine;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Handle = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Connector =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Connector, _React$Component);

  function Connector() {
    _classCallCheck(this, Connector);

    return _possibleConstructorReturn(this, _getPrototypeOf(Connector).apply(this, arguments));
  }

  _createClass(Connector, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          color = _this$props.color,
          dx = _this$props.dx,
          dy = _this$props.dy,
          customID = _this$props.customID,
          editMode = _this$props.editMode;

      if (dx === 0 && dy === 0) {
        return _react.default.createElement("g", {
          className: "annotation-connector"
        });
      }

      var d = this.getComponents(this.props) || [];
      var cleanedProps = Object.assign({}, this.props);
      delete cleanedProps.children;

      var childrenWithProps = _react.default.Children.map(this.props.children, function (child) {
        return _react.default.cloneElement(child, _objectSpread({}, cleanedProps, child.props, {
          scale: cleanedProps.endScale || child.props.endScale,
          lineData: d.components[0].data
        }));
      });

      var handles;

      if (editMode && d.handles && d.handles.length > 0) {
        handles = d.handles.map(function (h, i) {
          return _react.default.createElement(_Handle.default, {
            key: "connectorhandle-".concat(i),
            handleStart: _this.props.dragStart,
            handleStop: _this.props.dragEnd,
            x: h.x,
            y: h.y,
            offsetParent: h.offsetParent && _this.connector,
            handleDrag: function handleDrag(e, data) {
              _this.props.dragConnectorSettings(e, d.handleFunction(h, data));
            }
          });
        });
      }

      return _react.default.createElement("g", _extends({
        className: "annotation-connector"
      }, this.props.gAttrs), d.components && d.components.map(function (c, i) {
        var attrs = {};
        if (!c) return null;
        Object.keys(c.attrs).forEach(function (k) {
          if (c.attrs[k] && k !== "text") {
            attrs[k.replace(/-([a-z])/g, function (g) {
              return g[1].toUpperCase();
            })] = c.attrs[k];
          }
        });
        return _react.default.createElement(c.type, _extends({
          mask: customID ? "url(#".concat(customID, ")") : undefined,
          key: i,
          className: c.className,
          fill: "none",
          stroke: color
        }, attrs), c.attrs.text);
      }), childrenWithProps, handles);
    }
  }]);

  return Connector;
}(_react.default.Component);

exports.default = Connector;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var leftRightDynamic = exports.leftRightDynamic = function leftRightDynamic(align, y) {
  if (!align || align === "dynamic" || align === "left" || align === "right") {
    if (y < 0) {
      align = "top";
    } else {
      align = "bottom";
    }
  }
  return align;
};

var topBottomDynamic = exports.topBottomDynamic = function topBottomDynamic(align, x) {
  if (!align || align === "dynamic" || align === "top" || align === "bottom") {
    if (x < 0) {
      align = "right";
    } else {
      align = "left";
    }
  }
  return align;
};

var orientationTopBottom = ["topBottom", "top", "bottom"];
var orientationLeftRight = ["leftRight", "left", "right"];

exports.default = function (_ref) {
  var _ref$padding = _ref.padding,
      padding = _ref$padding === undefined ? 0 : _ref$padding,
      _ref$bbox = _ref.bbox,
      bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
      align = _ref.align,
      orientation = _ref.orientation,
      _ref$offset = _ref.offset,
      offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

  var x = -bbox.x;
  var y = -bbox.y;
  if (orientationTopBottom.indexOf(orientation) !== -1) {
    align = topBottomDynamic(align, offset.x);
    if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
      y -= bbox.height + padding;
    } else {
      y += padding;
    }

    if (align === "middle") {
      x -= bbox.width / 2;
    } else if (align === "right") {
      x -= bbox.width;
    }
  } else if (orientationLeftRight.indexOf(orientation) !== -1) {
    align = leftRightDynamic(align, offset.y);
    if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
      x -= bbox.width + padding;
    } else {
      x += padding;
    }

    if (align === "middle") {
      y -= bbox.height / 2;
    } else if (align === "top") {
      y -= bbox.height;
    }
  }

  return { x: x, y: y };
};

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(end)).h),
          s = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(start.s, end.s),
          l = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(start.l, end.l),
          opacity = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["b"] = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* hue */ "c"]));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var AnnotationLayer_1 = __importDefault(__webpack_require__(158));
var InteractionLayer_1 = __importDefault(__webpack_require__(168));
var VisualizationLayer_1 = __importDefault(__webpack_require__(171));
var frameFunctions_1 = __webpack_require__(33);
var jsx_1 = __webpack_require__(275);
var SpanOrDiv_1 = __webpack_require__(41);
var blankArray = [];
var defaultZeroMargin = { top: 0, bottom: 0, left: 0, right: 0 };
var Frame = /** @class */ (function (_super) {
    __extends(Frame, _super);
    function Frame(props) {
        var _this = _super.call(this, props) || this;
        _this.canvasContext = null;
        _this.setVoronoi = function (d) {
            _this.setState({ voronoiHover: d });
        };
        var matte = props.matte, size = props.size, margin = props.margin, frameKey = props.frameKey, additionalDefs = props.additionalDefs, name = props.name;
        var generatedDefs = jsx_1.generateFinalDefs({
            matte: matte,
            size: size,
            margin: margin,
            frameKey: frameKey,
            additionalDefs: additionalDefs,
            name: name
        });
        _this.state = {
            canvasContext: null,
            voronoiHover: undefined,
            finalDefs: generatedDefs.defs,
            matte: generatedDefs.matte,
            SpanOrDiv: SpanOrDiv_1.HOCSpanOrDiv(props.useSpans),
            props: props
        };
        return _this;
    }
    Frame.prototype.componentDidMount = function () {
        this.setState({
            canvasContext: this.canvasContext
        });
    };
    Frame.prototype.componentDidUpdate = function () {
        if (this.canvasContext !== this.state.canvasContext)
            this.setState({
                canvasContext: this.canvasContext
            });
    };
    Frame.getDerivedStateFromProps = function (nextProps, prevState) {
        var lp = prevState.props;
        var matte = nextProps.matte, size = nextProps.size, _a = nextProps.margin, margin = _a === void 0 ? defaultZeroMargin : _a, frameKey = nextProps.frameKey, additionalDefs = nextProps.additionalDefs;
        var lpMargin = lp.margin || defaultZeroMargin;
        if (lp.size[0] !== size[0] ||
            lp.size[1] !== size[1] ||
            lpMargin.top !== margin.top ||
            lpMargin.bottom !== margin.bottom ||
            lpMargin.right !== margin.right ||
            lpMargin.left !== margin.left ||
            lpMargin.top !== margin.top ||
            lp.matte !== nextProps.matte ||
            lp.additionalDefs !== nextProps.additionalDefs) {
            var generatedDefs = jsx_1.generateFinalDefs({
                matte: matte,
                size: size,
                margin: margin,
                frameKey: frameKey,
                additionalDefs: additionalDefs,
                name: name
            });
            return {
                finalDefs: generatedDefs.defs,
                matte: generatedDefs.matte,
                props: nextProps
            };
        }
        return null;
    };
    Frame.prototype.render = function () {
        var _this = this;
        var _a = this.props, axes = _a.axes, axesTickLines = _a.axesTickLines, _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.name, name = _c === void 0 ? "" : _c, frameKey = _a.frameKey, projectedCoordinateNames = _a.projectedCoordinateNames, renderPipeline = _a.renderPipeline, size = _a.size, _d = _a.adjustedSize, adjustedSize = _d === void 0 ? size : _d, title = _a.title, xScale = _a.xScale, yScale = _a.yScale, dataVersion = _a.dataVersion, annotations = _a.annotations, projectedYMiddle = _a.projectedYMiddle, interaction = _a.interaction, customClickBehavior = _a.customClickBehavior, customHoverBehavior = _a.customHoverBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, points = _a.points, _e = _a.margin, margin = _e === void 0 ? defaultZeroMargin : _e, backgroundGraphics = _a.backgroundGraphics, foregroundGraphics = _a.foregroundGraphics, beforeElements = _a.beforeElements, afterElements = _a.afterElements, defaultSVGRule = _a.defaultSVGRule, defaultHTMLRule = _a.defaultHTMLRule, adjustedPosition = _a.adjustedPosition, legendSettings = _a.legendSettings, annotationSettings = _a.annotationSettings, overlay = _a.overlay, columns = _a.columns, rScale = _a.rScale, projection = _a.projection, interactionOverflow = _a.interactionOverflow, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasRendering = _a.canvasRendering, renderOrder = _a.renderOrder, showLinePoints = _a.showLinePoints, _f = _a.disableCanvasInteraction, disableCanvasInteraction = _f === void 0 ? false : _f, sketchyRenderingEngine = _a.sketchyRenderingEngine, disableContext = _a.disableContext, frameRenderOrder = _a.frameRenderOrder, additionalVizElements = _a.additionalVizElements, interactionSettings = _a.interactionSettings;
        var hoverAnnotation = this.props.hoverAnnotation;
        if (!hoverAnnotation &&
            (customClickBehavior || customHoverBehavior || customDoubleClickBehavior)) {
            hoverAnnotation = blankArray;
        }
        var _g = this.state, voronoiHover = _g.voronoiHover, canvasContext = _g.canvasContext, finalDefs = _g.finalDefs, matte = _g.matte, SpanOrDiv = _g.SpanOrDiv;
        var areaAnnotations = [];
        var totalAnnotations = annotations
            ? __spread(annotations, areaAnnotations) : areaAnnotations;
        if (voronoiHover) {
            if (Array.isArray(voronoiHover)) {
                totalAnnotations.push.apply(totalAnnotations, __spread(voronoiHover));
            }
            else {
                totalAnnotations.push(voronoiHover);
            }
        }
        var annotationLayer = ((totalAnnotations &&
            totalAnnotations.length > 0) ||
            legendSettings) && (React.createElement(AnnotationLayer_1.default, { legendSettings: legendSettings, margin: margin, axes: axes, voronoiHover: this.setVoronoi, annotationHandling: annotationSettings, pointSizeFunction: annotationSettings.layout &&
                annotationSettings.layout.pointSizeFunction, labelSizeFunction: annotationSettings.layout &&
                annotationSettings.layout.labelSizeFunction, annotations: totalAnnotations, svgAnnotationRule: function (d, i, thisALayer) {
                return defaultSVGRule(__assign({ d: d,
                    i: i, annotationLayer: thisALayer }, renderPipeline));
            }, htmlAnnotationRule: function (d, i, thisALayer) {
                return defaultHTMLRule(__assign({ d: d,
                    i: i, annotationLayer: thisALayer }, renderPipeline));
            }, useSpans: useSpans, size: adjustedSize, position: [
                adjustedPosition[0] + margin.left,
                adjustedPosition[1] + margin.top
            ] }));
        var generatedTitle = frameFunctions_1.generateFrameTitle({
            title: title,
            size: size
        });
        var finalBackgroundGraphics = typeof backgroundGraphics === "function"
            ? backgroundGraphics({ size: size, margin: margin })
            : backgroundGraphics;
        var finalForegroundGraphics = typeof foregroundGraphics === "function"
            ? foregroundGraphics({ size: size, margin: margin })
            : foregroundGraphics;
        return (React.createElement(SpanOrDiv, { span: useSpans, className: className + " frame " + name, style: {
                background: "none"
            } },
            beforeElements && (React.createElement(SpanOrDiv, { span: useSpans, className: name + " frame-before-elements" }, beforeElements)),
            React.createElement(SpanOrDiv, { span: useSpans, className: "frame-elements", style: { height: size[1] + "px", width: size[0] + "px" } },
                React.createElement(SpanOrDiv, { span: useSpans, className: "visualization-layer", style: { position: "absolute" } },
                    backgroundGraphics && (React.createElement("svg", { className: "background-graphics", style: { position: "absolute" }, width: size[0], height: size[1] }, backgroundGraphics && (React.createElement("g", { "aria-hidden": true, className: "background-graphics" }, finalBackgroundGraphics)))),
                    canvasRendering && (React.createElement("canvas", { className: "frame-canvas", ref: function (canvasContextRef) {
                            return (_this.canvasContext = canvasContextRef);
                        }, style: {
                            position: "absolute",
                            left: "0px",
                            top: "0px"
                        }, width: size[0], height: size[1] })),
                    React.createElement("svg", { className: "visualization-layer", style: { position: "absolute" }, width: size[0], height: size[1] },
                        finalDefs,
                        React.createElement(VisualizationLayer_1.default, { disableContext: disableContext, renderPipeline: renderPipeline, position: adjustedPosition, width: adjustedSize[0], height: adjustedSize[1], projectedCoordinateNames: projectedCoordinateNames, xScale: xScale, yScale: yScale, axes: axes, title: generatedTitle, frameKey: frameKey, canvasContext: canvasContext, dataVersion: dataVersion, matte: matte, margin: margin, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, voronoiHover: this.setVoronoi, renderOrder: renderOrder, sketchyRenderingEngine: sketchyRenderingEngine, axesTickLines: axesTickLines, additionalVizElements: additionalVizElements, frameRenderOrder: frameRenderOrder }),
                        generatedTitle && (React.createElement("g", { className: "frame-title" }, generatedTitle)),
                        foregroundGraphics && (React.createElement("g", { "aria-hidden": true, className: "foreground-graphics" }, finalForegroundGraphics)))),
                React.createElement(InteractionLayer_1.default, { useSpans: useSpans, hoverAnnotation: hoverAnnotation, projectedX: projectedCoordinateNames.x, projectedY: projectedCoordinateNames.y, projectedYMiddle: projectedYMiddle, interaction: interaction, voronoiHover: this.setVoronoi, customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: points, showLinePoints: showLinePoints, canvasRendering: canvasRendering, position: adjustedPosition, margin: margin, size: adjustedSize, svgSize: size, xScale: xScale, yScale: yScale, enabled: true, overlay: overlay, oColumns: columns, rScale: rScale, projection: projection, interactionOverflow: interactionOverflow, disableCanvasInteraction: disableCanvasInteraction, renderPipeline: renderPipeline, advancedSettings: interactionSettings }),
                annotationLayer),
            afterElements && (React.createElement(SpanOrDiv, { span: useSpans, className: name + " frame-after-elements" }, afterElements))));
    };
    Frame.defaultProps = {
        annotationSettings: {},
        adjustedPosition: [0, 0],
        projectedCoordinateNames: { x: "x", y: "y" },
        renderOrder: [],
        frameRenderOrder: [
            "axes-tick-lines",
            "viz-layer",
            "matte",
            "axes-labels",
            "labels"
        ],
        additionalVizElements: {}
    };
    return Frame;
}(React.Component));
exports.default = Frame;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.projectedX = "x";
exports.projectedY = "y";
exports.projectedYMiddle = "yMiddle";
exports.projectedYTop = "yTop";
exports.projectedYBottom = "yBottom";
exports.projectedXMiddle = "xMiddle";
exports.projectedXTop = "xTop";
exports.projectedXBottom = "xBottom";


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
var horizontalTornTickGenerator = function (width, ticks, y, orient) {
    var step = width / ticks;
    var currentStep = 0;
    var tickPath = "M0," + y;
    var mod = orient === "right" ? -1 : 1;
    while (currentStep <= width) {
        tickPath += "L" + currentStep + "," + y;
        if (currentStep < width) {
            tickPath += "L" + (currentStep + step / 2) + "," + (y + 10 * mod);
        }
        currentStep += step;
    }
    return tickPath;
};
var verticalTornTickGenerator = function (height, ticks, x, orient) {
    var step = height / ticks;
    var currentStep = 0;
    var tickPath = "M" + x + ",0";
    var mod = orient === "bottom" ? -1 : 1;
    while (currentStep <= height) {
        tickPath += "L" + x + "," + currentStep;
        if (currentStep < height) {
            tickPath += "L" + (x + 10 * mod) + "," + (currentStep + step / 2);
        }
        currentStep += step;
    }
    return tickPath;
};
var generateTornBaseline = function (orient, baselineSettings) {
    var tornD = "";
    var x1 = baselineSettings.x1, x2 = baselineSettings.x2, y1 = baselineSettings.y1, y2 = baselineSettings.y2;
    if (orient === "left" || orient === "right") {
        var calcWidth = Math.abs(x2 - x1);
        var ticks = Math.ceil(calcWidth / 40);
        tornD = horizontalTornTickGenerator(calcWidth, ticks, orient === "right" ? 0 : y1, orient);
    }
    else {
        var calcHeight = Math.abs(y2 - y1);
        var ticks = Math.ceil(calcHeight / 40);
        tornD = verticalTornTickGenerator(calcHeight, ticks, x1, orient);
    }
    return tornD;
};
var defaultTickLineGenerator = function (_a) {
    var xy = _a.xy, orient = _a.orient, i = _a.i, baseMarkProps = _a.baseMarkProps, _b = _a.className, className = _b === void 0 ? "" : _b, jaggedBase = _a.jaggedBase;
    var genD = "M" + xy.x1 + "," + xy.y1 + "L" + xy.x2 + "," + xy.y2;
    if (jaggedBase && i === 0) {
        genD = generateTornBaseline(orient, xy);
    }
    return (React.createElement(semiotic_mark_1.Mark, __assign({ key: i, markType: "path", renderMode: xy.renderMode, fill: "none", stroke: "black", strokeWidth: "1px", simpleInterpolate: true, d: genD, className: "tick-line tick " + orient + " " + className }, baseMarkProps)));
};
var outboundTickLineGenerator = function (_a) {
    var xy = _a.xy, orient = _a.orient, i = _a.i, _b = _a.className, className = _b === void 0 ? "" : _b;
    var tickLength = 8;
    var genD = "M-4," + xy.y1 + "L" + xy.x1 + "," + xy.y2;
    if (orient === "left") {
        genD = "M" + (xy.x1 - tickLength) + "," + xy.y1 + "L" + xy.x1 + "," + xy.y2;
    }
    else if (orient === "right") {
        genD = "M" + xy.x2 + "," + xy.y1 + "L" + (xy.x2 + tickLength) + "," + xy.y2;
    }
    else if (orient === "top") {
        genD = "M" + xy.x1 + "," + (xy.y1 - tickLength) + "L" + xy.x1 + "," + xy.y1;
    }
    else if (orient === "bottom") {
        genD = "M" + xy.x1 + "," + xy.y2 + "L" + xy.x1 + "," + (xy.y2 + tickLength);
    }
    return (React.createElement(semiotic_mark_1.Mark, { key: i, markType: "path", renderMode: xy.renderMode, fill: "none", stroke: "black", strokeWidth: "1px", simpleInterpolate: true, d: genD, className: "outbound-tick-line tick " + orient + " " + className }));
};
function generateTickValues(tickValues, ticks, scale) {
    var axisSize = Math.abs(scale.range()[1] - scale.range()[0]);
    if (!tickValues) {
        if (!ticks) {
            ticks = Math.max(1, Math.floor(axisSize / 40));
        }
        tickValues = (scale.ticks && scale.ticks(ticks)) || scale.domain();
    }
    return tickValues;
}
exports.generateTickValues = generateTickValues;
function axisPieces(_a) {
    var _b = _a.renderMode, renderMode = _b === void 0 ? function () { return undefined; } : _b, _c = _a.padding, padding = _c === void 0 ? 5 : _c, scale = _a.scale, ticks = _a.ticks, _d = _a.tickValues, tickValues = _d === void 0 ? generateTickValues(undefined, ticks, scale) : _d, _e = _a.orient, orient = _e === void 0 ? "left" : _e, size = _a.size, _f = _a.footer, footer = _f === void 0 ? false : _f, _g = _a.tickSize, tickSize = _g === void 0 ? footer
        ? -10
        : ["top", "bottom"].find(function (d) { return d === orient; })
            ? size[1]
            : size[0] : _g, jaggedBase = _a.jaggedBase;
    //returns x1 (start of line), x2 (end of line) associated with the value of the tick
    var axisDomain = [], position1, position2, domain1, domain2, tposition1, tposition2, textPositionMod = 0, textPositionMod2 = 0, defaultAnchor = "middle";
    switch (orient) {
        case "top":
            position1 = "x1";
            position2 = "x2";
            domain1 = "y1";
            domain2 = "y2";
            axisDomain = [0, tickSize];
            tposition1 = "tx";
            tposition2 = "ty";
            textPositionMod -= 20 - padding;
            break;
        case "bottom":
            position1 = "x1";
            position2 = "x2";
            domain1 = "y2";
            domain2 = "y1";
            axisDomain = [size[1], size[1] - tickSize];
            tposition1 = "tx";
            tposition2 = "ty";
            textPositionMod += 20 + padding;
            break;
        case "right":
            position1 = "y2";
            position2 = "y1";
            domain1 = "x2";
            domain2 = "x1";
            axisDomain = [size[0], size[0] - tickSize];
            tposition1 = "ty";
            tposition2 = "tx";
            textPositionMod += 5 + padding;
            textPositionMod2 += 5;
            defaultAnchor = "start";
            break;
        //left
        default:
            position1 = "y1";
            position2 = "y2";
            domain1 = "x1";
            domain2 = "x2";
            axisDomain = [0, tickSize];
            tposition1 = "ty";
            tposition2 = "tx";
            textPositionMod -= 5 + padding;
            textPositionMod2 += 5;
            defaultAnchor = "end";
            break;
    }
    var generatedTicks = tickValues instanceof Function ? tickValues({ orient: orient }) : tickValues;
    if (jaggedBase &&
        generatedTicks.find(function (t) { return t === scale.domain()[0]; }) === undefined) {
        generatedTicks = __spread([scale.domain()[0]], generatedTicks);
    }
    return generatedTicks.map(function (tick, i) {
        var _a;
        var tickPosition = scale(tick);
        return _a = {},
            _a[position1] = tickPosition,
            _a[position2] = tickPosition,
            _a[domain1] = axisDomain[0],
            _a[domain2] = axisDomain[1],
            _a[tposition1] = tickPosition + textPositionMod2,
            _a[tposition2] = axisDomain[0] + textPositionMod,
            _a.defaultAnchor = defaultAnchor,
            _a.renderMode = renderMode(tick, i),
            _a.value = tick,
            _a;
    });
}
exports.axisPieces = axisPieces;
exports.axisLabels = function (_a) {
    var axisParts = _a.axisParts, tickFormat = _a.tickFormat, _b = _a.rotate, rotate = _b === void 0 ? 0 : _b, _c = _a.center, center = _c === void 0 ? false : _c, orient = _a.orient;
    return axisParts.map(function (axisPart, i) {
        var renderedValue = tickFormat(axisPart.value, i);
        if (typeof renderedValue !== "object" || renderedValue instanceof Date) {
            renderedValue = (React.createElement("text", { textAnchor: axisPart.defaultAnchor, className: "axis-label" }, renderedValue.toString ? renderedValue.toString() : renderedValue));
        }
        var textX = axisPart.tx;
        var textY = axisPart.ty;
        if (center) {
            switch (orient) {
                case "right":
                    textX -= (axisPart.x2 - axisPart.x1) / 2;
                    break;
                case "left":
                    textX += (axisPart.x2 - axisPart.x1) / 2;
                    break;
                case "top":
                    textY += (axisPart.y2 - axisPart.y1) / 2;
                    break;
                case "bottom":
                    textY -= (axisPart.y2 - axisPart.y1) / 2;
                    break;
            }
        }
        return (React.createElement("g", { key: i, pointerEvents: "none", transform: "translate(" + textX + "," + textY + ") rotate(" + rotate + ")", className: "axis-label" }, renderedValue));
    });
};
exports.baselineGenerator = function (orient, size, className) {
    var offsets = {
        left: { x: 0, y: 0, width: 0, height: size[1] },
        right: { x: size[0], y: 0, width: 0, height: size[1] },
        top: { x: 0, y: 0, width: size[0], height: 0 },
        bottom: { x: 0, y: size[1], width: size[0], height: 0 }
    };
    var orientOffset = offsets[orient];
    return (React.createElement("line", { key: "baseline", className: "axis-baseline " + className, stroke: "black", strokeLinecap: "square", x1: orientOffset.x, x2: orientOffset.x + orientOffset.width, y1: orientOffset.y, y2: orientOffset.y + orientOffset.height }));
};
exports.axisLines = function (_a) {
    var axisParts = _a.axisParts, orient = _a.orient, _b = _a.tickLineGenerator, tickLineGenerator = _b === void 0 ? defaultTickLineGenerator : _b, baseMarkProps = _a.baseMarkProps, className = _a.className, jaggedBase = _a.jaggedBase, scale = _a.scale, _c = _a.showOutboundTickLines, showOutboundTickLines = _c === void 0 ? false : _c;
    var axisLines = axisParts.map(function (axisPart, i) {
        return tickLineGenerator({
            xy: axisPart,
            orient: orient,
            i: i,
            baseMarkProps: baseMarkProps,
            className: className,
            jaggedBase: jaggedBase,
            scale: scale
        });
    });
    var outboundAxisLines = showOutboundTickLines ?
        axisParts.map(function (axisPart, i) {
            return outboundTickLineGenerator({
                xy: axisPart,
                orient: orient,
                i: i,
                className: className
            });
        })
        : [];
    return __spread(axisLines, [outboundAxisLines]);
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var Axis_1 = __importDefault(__webpack_require__(82));
var semiotic_mark_1 = __webpack_require__(15);
var areaDrawing_1 = __webpack_require__(83);
var d3_array_1 = __webpack_require__(3);
var d3_array_2 = __webpack_require__(3);
var SvgHelper_1 = __webpack_require__(71);
var d3_shape_1 = __webpack_require__(18);
var pieceDrawing_1 = __webpack_require__(84);
var frameFunctions_1 = __webpack_require__(33);
var d3_scale_1 = __webpack_require__(24);
var general_1 = __webpack_require__(85);
var d3_array_3 = __webpack_require__(3);
var contourMap = function (d) { return [d.xy.x, d.xy.y]; };
var verticalXYSorting = function (a, b) { return a.xy.y - b.xy.y; };
var horizontalXYSorting = function (a, b) { return b.xy.x - a.xy.x; };
var emptyObjectReturnFn = function () { return ({}); };
function createSummaryAxis(_a) {
    var summary = _a.summary, summaryI = _a.summaryI, axisSettings = _a.axisSettings, axisCreator = _a.axisCreator, projection = _a.projection, actualMax = _a.actualMax, adjustedSize = _a.adjustedSize, columnWidth = _a.columnWidth;
    var axisTranslate = "translate(" + summary.x + ",0)";
    var axisDomain = [0, actualMax];
    if (projection === "horizontal") {
        axisTranslate = "translate(" + 0 + "," + summary.x + ")";
        axisDomain = [actualMax, 0];
    }
    else if (projection === "radial") {
        axisTranslate = "translate(0, 0)";
    }
    var axisWidth = projection === "horizontal" ? adjustedSize[0] : columnWidth;
    var axisHeight = projection === "vertical" ? adjustedSize[1] : columnWidth;
    axisSettings.size = [axisWidth, axisHeight];
    var axisScale = d3_scale_1.scaleLinear()
        .domain(axisDomain)
        .range([0, columnWidth]);
    var renderedSummaryAxis = axisCreator(axisSettings, summaryI, axisScale);
    return (React.createElement("g", { className: "summary-axis", key: "summaryPiece-axis-" + summaryI, transform: axisTranslate }, renderedSummaryAxis));
}
function boxplotRenderFn(_a) {
    var data = _a.data, type = _a.type, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, projection = _a.projection, adjustedSize = _a.adjustedSize, baseMarkProps = _a.baseMarkProps;
    var summaryElementStylingFn = type.elementStyleFn || emptyObjectReturnFn;
    var keys = Object.keys(data);
    var renderedSummaryMarks = [];
    var summaryXYCoords = [];
    keys.forEach(function (key, summaryI) {
        var summary = data[key];
        var eventListeners = eventListenersGenerator(summary, summaryI);
        var columnWidth = summary.width;
        var thisSummaryData = summary.pieceData;
        var calculatedSummaryStyle = styleFn(thisSummaryData[0].data, summaryI);
        var calculatedSummaryClass = classFn(thisSummaryData[0].data, summaryI);
        var summaryPositionNest, summaryValueNest, translate, extentlineX1, extentlineX2, extentlineY1, extentlineY2, topLineX1, topLineX2, midLineX1, midLineX2, bottomLineX1, bottomLineX2, rectTopWidth, rectTopHeight, rectTopY, rectTopX, rectBottomWidth, rectBottomHeight, rectBottomY, rectBottomX, rectWholeWidth, rectWholeHeight, rectWholeY, rectWholeX, topLineY1, topLineY2, bottomLineY1, bottomLineY2, midLineY1, midLineY2;
        var renderValue = renderMode ? renderMode(summary, summaryI) : undefined;
        summaryValueNest = thisSummaryData.map(function (p) { return p.value; }).sort(function (a, b) { return a - b; });
        summaryValueNest = [
            d3_array_1.quantile(summaryValueNest, 0.0),
            d3_array_1.quantile(summaryValueNest, 0.25),
            d3_array_1.quantile(summaryValueNest, 0.5),
            d3_array_1.quantile(summaryValueNest, 0.75),
            d3_array_1.quantile(summaryValueNest, 1.0)
        ];
        //translate
        if (projection === "vertical") {
            summaryPositionNest = thisSummaryData
                .map(function (p) { return p.scaledVerticalValue; })
                .sort(function (a, b) { return b - a; });
            translate = "translate(" + (summary.x + summary.padding) + ",0)";
            summaryPositionNest = [
                d3_array_1.quantile(summaryPositionNest, 0.0),
                d3_array_1.quantile(summaryPositionNest, 0.25),
                d3_array_1.quantile(summaryPositionNest, 0.5),
                d3_array_1.quantile(summaryPositionNest, 0.75),
                d3_array_1.quantile(summaryPositionNest, 1.0)
            ];
            extentlineX1 = 0;
            extentlineX2 = 0;
            extentlineY1 = summaryPositionNest[0];
            extentlineY2 = summaryPositionNest[4];
            topLineX1 = -columnWidth / 2;
            topLineX2 = columnWidth / 2;
            midLineX1 = -columnWidth / 2;
            midLineX2 = columnWidth / 2;
            bottomLineX1 = -columnWidth / 2;
            bottomLineX2 = columnWidth / 2;
            rectBottomWidth = columnWidth;
            rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[2];
            rectBottomY = summaryPositionNest[2];
            rectBottomX = -columnWidth / 2;
            rectTopWidth = columnWidth;
            rectTopHeight = summaryPositionNest[2] - summaryPositionNest[3];
            rectWholeWidth = columnWidth;
            rectWholeHeight = summaryPositionNest[1] - summaryPositionNest[3];
            rectWholeY = summaryPositionNest[3];
            rectWholeX = -columnWidth / 2;
            rectTopY = summaryPositionNest[3];
            rectTopX = -columnWidth / 2;
            topLineY1 = summaryPositionNest[0];
            topLineY2 = summaryPositionNest[0];
            bottomLineY1 = summaryPositionNest[4];
            bottomLineY2 = summaryPositionNest[4];
            midLineY1 = summaryPositionNest[2];
            midLineY2 = summaryPositionNest[2];
            summaryXYCoords.push({
                label: "Maximum",
                key: key,
                summaryPieceName: "max",
                x: 0,
                y: summaryPositionNest[4],
                value: summaryValueNest[4]
            }, {
                label: "3rd Quartile",
                key: key,
                summaryPieceName: "q3area",
                x: 0,
                y: summaryPositionNest[3],
                value: summaryValueNest[3]
            }, {
                label: "Median",
                key: key,
                summaryPieceName: "median",
                x: 0,
                y: summaryPositionNest[2],
                value: summaryValueNest[2]
            }, {
                label: "1st Quartile",
                key: key,
                summaryPieceName: "q1area",
                x: 0,
                y: summaryPositionNest[1],
                value: summaryValueNest[1]
            }, {
                label: "Minimum",
                key: key,
                summaryPieceName: "min",
                x: 0,
                y: summaryPositionNest[0],
                value: summaryValueNest[0]
            });
        }
        else if (projection === "horizontal") {
            summaryPositionNest = thisSummaryData
                .map(function (p) { return p.scaledValue; })
                .sort(function (a, b) { return a - b; });
            translate = "translate(0," + (summary.x + summary.padding) + ")";
            summaryPositionNest = [
                d3_array_1.quantile(summaryPositionNest, 0.0),
                d3_array_1.quantile(summaryPositionNest, 0.25),
                d3_array_1.quantile(summaryPositionNest, 0.5),
                d3_array_1.quantile(summaryPositionNest, 0.75),
                d3_array_1.quantile(summaryPositionNest, 1.0)
            ];
            extentlineY1 = 0;
            extentlineY2 = 0;
            extentlineX1 = summaryPositionNest[0];
            extentlineX2 = summaryPositionNest[4];
            topLineY1 = -columnWidth / 2;
            topLineY2 = columnWidth / 2;
            midLineY1 = -columnWidth / 2;
            midLineY2 = columnWidth / 2;
            bottomLineY1 = -columnWidth / 2;
            bottomLineY2 = columnWidth / 2;
            rectTopHeight = columnWidth;
            rectTopWidth = summaryPositionNest[3] - summaryPositionNest[2];
            rectTopX = summaryPositionNest[2];
            rectTopY = -columnWidth / 2;
            rectBottomHeight = columnWidth;
            rectBottomWidth = summaryPositionNest[2] - summaryPositionNest[1];
            rectBottomX = summaryPositionNest[1];
            rectBottomY = -columnWidth / 2;
            rectWholeHeight = columnWidth;
            rectWholeWidth = summaryPositionNest[3] - summaryPositionNest[1];
            rectWholeX = summaryPositionNest[1];
            rectWholeY = -columnWidth / 2;
            topLineX1 = summaryPositionNest[0];
            topLineX2 = summaryPositionNest[0];
            bottomLineX1 = summaryPositionNest[4];
            bottomLineX2 = summaryPositionNest[4];
            midLineX1 = summaryPositionNest[2];
            midLineX2 = summaryPositionNest[2];
            summaryXYCoords.push({
                label: "Maximum",
                key: key,
                summaryPieceName: "max",
                x: summaryPositionNest[4],
                y: 0,
                value: summaryValueNest[4]
            }, {
                label: "3rd Quartile",
                key: key,
                summaryPieceName: "q3area",
                x: summaryPositionNest[3],
                y: 0,
                value: summaryValueNest[3]
            }, {
                label: "Median",
                key: key,
                summaryPieceName: "median",
                x: summaryPositionNest[2],
                y: 0,
                value: summaryValueNest[2]
            }, {
                label: "1st Quartile",
                key: key,
                summaryPieceName: "q1area",
                x: summaryPositionNest[1],
                y: 0,
                value: summaryValueNest[1]
            }, {
                label: "Minimum",
                key: key,
                summaryPieceName: "min",
                x: summaryPositionNest[0],
                y: 0,
                value: summaryValueNest[0]
            });
        }
        if (projection === "radial") {
            summaryPositionNest = thisSummaryData
                .map(function (p) { return p.scaledValue; })
                .sort(function (a, b) { return a - b; });
            summaryPositionNest = [
                d3_array_1.quantile(summaryPositionNest, 0.0),
                d3_array_1.quantile(summaryPositionNest, 0.25),
                d3_array_1.quantile(summaryPositionNest, 0.5),
                d3_array_1.quantile(summaryPositionNest, 0.75),
                d3_array_1.quantile(summaryPositionNest, 1.0)
            ];
            extentlineX1 = 0;
            extentlineX2 = 0;
            extentlineY1 = summaryPositionNest[0];
            extentlineY2 = summaryPositionNest[4];
            topLineX1 = -columnWidth / 2;
            topLineX2 = columnWidth / 2;
            midLineX1 = -columnWidth / 2;
            midLineX2 = columnWidth / 2;
            bottomLineX1 = -columnWidth / 2;
            bottomLineX2 = columnWidth / 2;
            rectTopWidth = columnWidth;
            rectTopHeight = summaryPositionNest[1] - summaryPositionNest[3];
            rectTopY = summaryPositionNest[3];
            rectTopX = -columnWidth / 2;
            rectBottomWidth = columnWidth;
            rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[3];
            rectBottomY = summaryPositionNest[3];
            rectBottomX = -columnWidth / 2;
            topLineY1 = summaryPositionNest[0];
            topLineY2 = summaryPositionNest[0];
            bottomLineY1 = summaryPositionNest[4];
            bottomLineY2 = summaryPositionNest[4];
            midLineY1 = summaryPositionNest[2];
            midLineY2 = summaryPositionNest[2];
            var twoPI = Math.PI * 2;
            var bottomLineArcGenerator = d3_shape_1.arc()
                .innerRadius(bottomLineY1 / 2)
                .outerRadius(bottomLineY1 / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var topLineArcGenerator = d3_shape_1.arc()
                .innerRadius(topLineY1 / 2)
                .outerRadius(topLineY1 / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var midLineArcGenerator = d3_shape_1.arc()
                .innerRadius(midLineY1 / 2)
                .outerRadius(midLineY1 / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var bodyArcTopGenerator = d3_shape_1.arc()
                .innerRadius(summaryPositionNest[1] / 2)
                .outerRadius(midLineY1 / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var bodyArcBottomGenerator = d3_shape_1.arc()
                .innerRadius(midLineY1 / 2)
                .outerRadius(summaryPositionNest[3] / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var bodyArcWholeGenerator = d3_shape_1.arc()
                .innerRadius(summaryPositionNest[1] / 2)
                .outerRadius(summaryPositionNest[3] / 2);
            //        .padAngle(summary.pct_padding * twoPI);
            var startAngle = summary.pct_start + summary.pct_padding / 2;
            var endAngle = summary.pct + summary.pct_start - summary.pct_padding / 2;
            var midAngle = summary.pct / 2 + summary.pct_start;
            startAngle *= twoPI;
            endAngle *= twoPI;
            var radialAdjustX = adjustedSize[0] / 2;
            var radialAdjustY = adjustedSize[1] / 2;
            //        const bottomPoint = bottomLineArcGenerator.centroid({ startAngle, endAngle })
            //        const topPoint = topLineArcGenerator.centroid({ startAngle, endAngle })
            var bottomPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[4] / 2);
            var topPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[0] / 2);
            var thirdPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[3] / 2);
            var midPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[2] / 2);
            var firstPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[1] / 2);
            summaryXYCoords.push({
                label: "Minimum",
                key: key,
                summaryPieceName: "min",
                x: topPoint[0] + radialAdjustX,
                y: topPoint[1] + radialAdjustY,
                value: summaryValueNest[0]
            }, {
                label: "1st Quartile",
                key: key,
                summaryPieceName: "q3area",
                x: firstPoint[0] + radialAdjustX,
                y: firstPoint[1] + radialAdjustY,
                value: summaryValueNest[1]
            }, {
                label: "Median",
                key: key,
                summaryPieceName: "median",
                x: midPoint[0] + radialAdjustX,
                y: midPoint[1] + radialAdjustY,
                value: summaryValueNest[2]
            }, {
                label: "3rd Quartile",
                key: key,
                summaryPieceName: "q1area",
                x: thirdPoint[0] + radialAdjustX,
                y: thirdPoint[1] + radialAdjustY,
                value: summaryValueNest[3]
            }, {
                label: "Maximum",
                key: key,
                summaryPieceName: "max",
                x: bottomPoint[0] + radialAdjustX,
                y: bottomPoint[1] + radialAdjustY,
                value: summaryValueNest[4]
            });
            translate = "translate(" + radialAdjustX + "," + radialAdjustY + ")";
            renderedSummaryMarks.push(React.createElement("g", __assign({}, eventListeners, { className: calculatedSummaryClass, transform: translate, key: "summaryPiece-" + summaryI, role: "img", tabIndex: -1, "data-o": key, "aria-label": key + " boxplot showing " + summaryXYCoords
                    .filter(function (d) { return d.key === key; })
                    .map(function (d) { return d.label + " " + d.value; }) }),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "line", x1: bottomPoint[0], x2: topPoint[0], y1: bottomPoint[1], y2: topPoint[1], style: Object.assign({ strokeWidth: 2 }, calculatedSummaryStyle, summaryElementStylingFn("whisker")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: topLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("max")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: midLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("median")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: bottomLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("min")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: bodyArcWholeGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, summaryElementStylingFn("iqrarea")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: bodyArcTopGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q3area")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "path", d: bodyArcBottomGenerator({ startAngle: startAngle, endAngle: endAngle }), style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q1area")) }))));
        }
        else {
            renderedSummaryMarks.push(React.createElement("g", __assign({}, eventListeners, { className: calculatedSummaryClass, transform: translate, key: "summaryPiece-" + summaryI, role: "img", tabIndex: -1, "data-o": key, "aria-label": key + " boxplot showing " + summaryXYCoords
                    .filter(function (d) { return d.key === key; })
                    .map(function (d) { return d.label + " " + d.value; })
                    .join(", ") }),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "line", x1: extentlineX1, x2: extentlineX2, y1: extentlineY1, y2: extentlineY2, style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("whisker")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "line", x1: topLineX1, x2: topLineX2, y1: topLineY1, y2: topLineY2, style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("min")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "line", x1: bottomLineX1, x2: bottomLineX2, y1: bottomLineY1, y2: bottomLineY2, style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("max")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "rect", x: rectWholeX, width: rectWholeWidth, y: rectWholeY, height: rectWholeHeight, style: Object.assign({ strokeWidth: "1px" }, calculatedSummaryStyle, summaryElementStylingFn("iqrarea")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "rect", x: rectTopX, width: rectTopWidth, y: rectTopY, height: rectTopHeight, style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q3area")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "rect", x: rectBottomX, width: rectBottomWidth, y: rectBottomY, height: rectBottomHeight, style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q1area")) })),
                React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderValue, markType: "line", x1: midLineX1, x2: midLineX2, y1: midLineY1, y2: midLineY2, style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("median")) }))));
        }
    });
    return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}
exports.boxplotRenderFn = boxplotRenderFn;
function contourRenderFn(_a) {
    var data = _a.data, type = _a.type, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, adjustedSize = _a.adjustedSize, baseMarkProps = _a.baseMarkProps;
    var keys = Object.keys(data);
    var renderedSummaryMarks = [];
    var summaryXYCoords = [];
    keys.forEach(function (key, ordsetI) {
        var ordset = data[key];
        var renderValue = renderMode && renderMode(ordset, ordsetI);
        type.thresholds = type.thresholds || 8;
        type.bandwidth = type.bandwidth || 12;
        type.resolution = type.resolution || 1000;
        var projectedOrd = [
            { id: ordset, _xyfCoordinates: ordset.xyData.map(contourMap) }
        ];
        var oContours = areaDrawing_1.contouring({
            summaryType: type,
            data: projectedOrd,
            finalXExtent: [0, adjustedSize[0]],
            finalYExtent: [0, adjustedSize[1]]
        });
        var contourMarks = [];
        oContours.forEach(function (d, i) {
            d.coordinates.forEach(function (coords, ii) {
                var eventListeners = eventListenersGenerator(d, i);
                contourMarks.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, eventListeners, { renderMode: renderValue, simpleInterpolate: true, key: i + "-" + ii, style: styleFn(ordset.pieceData[0].data, ordsetI), className: classFn(ordset.pieceData[0].data, ordsetI), markType: "path", d: "M" + d.coordinates[0].map(function (p) { return p.join(","); }).join("L") + "Z" })));
            });
        });
        renderedSummaryMarks.push(React.createElement("g", { key: "contour-container-" + ordsetI, role: "img", tabIndex: -1, "data-o": key, "aria-label": key + " Contour plot" }, contourMarks));
    });
    return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}
exports.contourRenderFn = contourRenderFn;
function axisGenerator(axisProps, i, axisScale) {
    return (React.createElement(Axis_1.default, { label: axisProps.label, key: axisProps.key || "orframe-summary-axis-" + i, orient: axisProps.orient, size: axisProps.size, ticks: axisProps.ticks, tickSize: axisProps.tickSize, tickFormat: axisProps.tickFormat, tickValues: axisProps.tickValues, rotate: axisProps.rotate, scale: axisScale, className: axisProps.className }));
}
function bucketizedRenderingFn(_a) {
    var data = _a.data, type = _a.type, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, projection = _a.projection, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, baseMarkProps = _a.baseMarkProps;
    var renderedSummaryMarks = [];
    var summaryXYCoords = [];
    var buckets = type.bins || 25;
    var relativeBuckets = type.relative ? {} : false;
    var summaryValueAccessor = type.binValue || (function (d) { return d.length; });
    var axisCreator;
    if (type.axis) {
        type.axis.orient =
            projection === "horizontal" &&
                ["left", "right"].indexOf(type.axis.orient) === -1
                ? "left"
                : type.axis.orient;
        type.axis.orient =
            projection === "vertical" &&
                ["bottom", "top"].indexOf(type.axis.orient) === -1
                ? "bottom"
                : type.axis.orient;
        axisCreator = axisGenerator;
        if (projection === "radial") {
            console.error("Summary axes cannot be drawn for radial histograms");
            axisCreator = function () { return null; };
        }
    }
    var bucketSize = chartSize / buckets;
    var keys = Object.keys(data);
    var binMax = 0;
    var calculatedBins = keys.map(function (key, summaryI) {
        var summary = data[key];
        var thisSummaryData = summary.xyData;
        var xySorting = projection === "vertical" ? verticalXYSorting : horizontalXYSorting;
        var summaryPositionNest = thisSummaryData.sort(xySorting);
        var violinHist = d3_array_2.histogram();
        var binDomain = projection === "vertical" ? [0, chartSize] : [0, chartSize];
        var binOffset = 0;
        var binBuckets = [];
        for (var x = 0; x < buckets; x++) {
            binBuckets.push(binDomain[0] + (x / buckets) * (chartSize - binOffset));
        }
        //    binBuckets.push(binDomain[1]);
        var xyValue = projection === "vertical"
            ? function (p) { return p.piece.scaledVerticalValue; }
            : function (p) { return p.piece.scaledValue; };
        var keyBins;
        if (type.useBins === false) {
            var calculatedValues_1 = summaryPositionNest.map(function (value) { return xyValue(value); });
            keyBins = summaryPositionNest
                .map(function (value, i) {
                var bucketArray = [];
                bucketArray.x0 = calculatedValues_1[i] - 1;
                bucketArray.x1 = calculatedValues_1[i] + 1;
                bucketArray.push(value);
                return bucketArray;
            })
                .sort(function (a, b) { return a.x0 - b.x0; });
            bucketSize = chartSize / keyBins.length;
        }
        else {
            keyBins = violinHist
                .domain(binDomain)
                .thresholds(binBuckets)
                .value(xyValue)(summaryPositionNest);
        }
        keyBins = keyBins.map(function (d) { return ({
            y: d.x0,
            y1: d.x1 - d.x0,
            pieces: d,
            value: summaryValueAccessor(d.map(function (p) { return p.piece.data; }))
        }); });
        if (type.type === "histogram" || type.type === "heatmap") {
            keyBins = keyBins.filter(function (d) { return d.value !== 0; });
        }
        var relativeMax = keyBins.length === 0 ? 0 : d3_array_2.max(keyBins.map(function (d) { return d.value; }));
        if (relativeBuckets) {
            relativeBuckets[key] = relativeMax;
        }
        binMax = Math.max(binMax, relativeMax);
        return { bins: keyBins, summary: summary, summaryI: summaryI, thisSummaryData: thisSummaryData };
    });
    var numHorizons = type.horizon ? binMax / type.horizon : type.numHorizons || 4;
    var horizon = type.horizon || binMax / numHorizons;
    calculatedBins.forEach(function (_a) {
        var bins = _a.bins, summary = _a.summary, summaryI = _a.summaryI, thisSummaryData = _a.thisSummaryData;
        var eventListeners = eventListenersGenerator(summary, summaryI);
        var columnWidth = summary.width;
        var renderValue = renderMode && renderMode(summary, summaryI);
        var calculatedSummaryStyle = thisSummaryData[0]
            ? styleFn(thisSummaryData[0].piece.data, summaryI)
            : {};
        var calculatedSummaryClass = thisSummaryData[0]
            ? classFn(thisSummaryData[0].piece.data, summaryI)
            : "";
        var translate = [summary.middle, 0];
        if (projection === "horizontal") {
            translate = [bucketSize, summary.middle];
        }
        else if (projection === "radial") {
            translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
        }
        var actualMax = (relativeBuckets && relativeBuckets[summary.name]) || binMax;
        if (type.type === "heatmap" || type.type === "histogram") {
            var mappedBars = SvgHelper_1.groupBarMark({
                bins: bins,
                binMax: binMax,
                relativeBuckets: relativeBuckets,
                columnWidth: columnWidth,
                projection: projection,
                adjustedSize: adjustedSize,
                summaryI: summaryI,
                summary: summary,
                renderValue: renderValue,
                summaryStyle: calculatedSummaryStyle,
                type: type,
                baseMarkProps: baseMarkProps
            });
            var tiles = mappedBars.marks;
            if (projection === "radial") {
                translate = [0, 0];
            }
            if (type.axis && type.type === "histogram") {
                renderedSummaryMarks.push(createSummaryAxis({
                    summary: summary,
                    summaryI: summaryI,
                    axisSettings: type.axis,
                    axisCreator: axisCreator,
                    projection: projection,
                    actualMax: actualMax,
                    adjustedSize: adjustedSize,
                    columnWidth: columnWidth
                }));
            }
            mappedBars.points.forEach(function (d) {
                d.x += translate[0];
                d.y += translate[1];
            });
            summaryXYCoords.push.apply(summaryXYCoords, __spread(mappedBars.points));
            renderedSummaryMarks.push(React.createElement("g", __assign({}, eventListeners, { transform: "translate(" + translate + ")", key: "summaryPiece-" + summaryI, role: "img", tabIndex: -1, "data-o": summary.name, "aria-label": summary.name + " " + type.type }), tiles));
        }
        else if (type.type === "violin") {
            var subsets = type.subsets || [false];
            bins[0].y = bins[0].y - bucketSize / 2;
            bins[bins.length - 1].y = bins[bins.length - 1].y + bucketSize / 2;
            subsets.forEach(function (subsettingFn, subsettingIndex) {
                var actualBins = bins;
                if (subsettingFn) {
                    calculatedSummaryStyle = thisSummaryData[0]
                        ? styleFn(thisSummaryData[0].piece.data, summaryI, subsettingIndex)
                        : {};
                    calculatedSummaryClass = thisSummaryData[0]
                        ? classFn(thisSummaryData[0].piece.data, summaryI, subsettingIndex)
                        : "";
                    actualBins = bins.map(function (d) {
                        var actualPieces = d.pieces.filter(function (p, pi) { return subsettingFn(p.piece, pi); }).map(function (d) { return d; });
                        var actualValue = summaryValueAccessor(actualPieces);
                        return (__assign(__assign({}, d), { pieces: actualPieces, value: actualValue }));
                    });
                }
                var violinArea = d3_shape_1.area().curve(type.curve || d3_shape_1.curveCatmullRom);
                var violinPoints = [];
                if (projection === "horizontal") {
                    actualBins.forEach(function (summaryPoint) {
                        var xValue = summaryPoint.y - bucketSize / 2;
                        var yValue = ((summaryPoint.value / actualMax) * columnWidth) / 2;
                        violinPoints.push({
                            x: xValue,
                            y0: -yValue,
                            y1: yValue
                        });
                        summaryXYCoords.push({
                            key: summary.name,
                            x: xValue + translate[0],
                            y: yValue + translate[1],
                            pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                            value: summaryPoint.value
                        });
                    });
                    violinArea
                        .x(function (d) { return d.x; })
                        .y0(function (d) { return d.y0; })
                        .y1(function (d) { return d.y1; })
                        .defined(function (d, i) {
                        return d.y0 !== 0 ||
                            ((violinPoints[i - 1] && violinPoints[i - 1].y0 !== 0) ||
                                (violinPoints[i + 1] && violinPoints[i + 1].y0 !== 0));
                    });
                }
                else if (projection === "vertical") {
                    actualBins.forEach(function (summaryPoint) {
                        var yValue = summaryPoint.y + bucketSize / 2;
                        var xValue = ((summaryPoint.value / actualMax) * columnWidth) / 2;
                        violinPoints.push({
                            y: yValue,
                            x0: -xValue,
                            x1: xValue
                        });
                        summaryXYCoords.push({
                            key: summary.name,
                            x: xValue + translate[0],
                            y: yValue + translate[1],
                            pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                            value: summaryPoint.value
                        });
                    });
                    violinArea
                        .y(function (d) { return d.y; })
                        .x0(function (d) { return d.x0; })
                        .x1(function (d) { return d.x1; })
                        .defined(function (d, i) {
                        return d.x0 !== 0 ||
                            ((violinPoints[i - 1] && violinPoints[i - 1].x0 !== 0) ||
                                (violinPoints[i + 1] && violinPoints[i + 1].x0 !== 0));
                    });
                }
                else if (projection === "radial") {
                    var angle_1 = summary.pct - summary.pct_padding / 2;
                    var midAngle_1 = summary.pct_middle;
                    violinPoints = actualBins;
                    violinArea = function (inbins) {
                        var forward = [];
                        var backward = [];
                        inbins.forEach(function (bin) {
                            var outsidePoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle_1 + (angle_1 * bin.value) / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2);
                            var insidePoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle_1 - (angle_1 * bin.value) / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2);
                            //Ugh a terrible side effect has appeared
                            summaryXYCoords.push({
                                key: summary.name,
                                x: insidePoint[0] + translate[0],
                                y: insidePoint[1] + translate[1],
                                pieces: bin.pieces.map(function (d) { return d.piece; }),
                                value: bin.value
                            });
                            summaryXYCoords.push({
                                key: summary.name,
                                x: outsidePoint[0] + translate[0],
                                y: outsidePoint[1] + translate[1],
                                pieces: bin.pieces.map(function (d) { return d.piece; }),
                                value: bin.value
                            });
                            forward.push(outsidePoint);
                            backward.push(insidePoint);
                        });
                        return "M" + forward.map(function (d) { return d.join(","); }).join("L") + "L" + backward
                            .reverse()
                            .map(function (d) { return d.join(","); })
                            .join("L") + "Z";
                    };
                }
                renderedSummaryMarks.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { transform: "translate(" + translate + ")", key: "summaryPiece-" + summaryI + "-" + subsettingIndex }, eventListeners, { renderMode: renderValue, markType: "path", className: calculatedSummaryClass, style: calculatedSummaryStyle, d: violinArea(violinPoints), role: "img", tabIndex: -1, "data-o": summary.name, "aria-label": summary.name + " distribution" })));
            });
        }
        else if (type.type === "ridgeline") {
            var zeroedStart = Object.assign({}, bins[0], { value: 0 });
            var zeroedEnd = Object.assign({}, bins[bins.length - 1], { value: 0 });
            //Ridgeline plots need to visually signify the zero baseline with their start and end position
            zeroedStart.y = zeroedStart.y - bucketSize / 2;
            zeroedEnd.y = zeroedEnd.y + bucketSize / 2;
            var joyBins_1 = __spread([zeroedStart], bins, [zeroedEnd]);
            var joyPoints_1 = [];
            var interpolatorSetting = type.curve || type.interpolator;
            var actualInterpolator = typeof interpolatorSetting === "string"
                ? general_1.curveHash[interpolatorSetting]
                : interpolatorSetting;
            var joyArea = d3_shape_1.line()
                .curve(actualInterpolator || d3_shape_1.curveCatmullRom)
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; });
            var joyHeight_1 = type.amplitude || 0;
            if (type.axis && type.type === "histogram") {
                renderedSummaryMarks.push(createSummaryAxis({
                    summary: summary,
                    summaryI: summaryI,
                    axisSettings: __assign({ baseline: false }, type.axis),
                    axisCreator: axisCreator,
                    projection: projection,
                    actualMax: actualMax,
                    adjustedSize: adjustedSize,
                    columnWidth: columnWidth
                }));
            }
            if (projection === "horizontal") {
                joyBins_1.forEach(function (summaryPoint, i) {
                    var xValue = summaryPoint.y - bucketSize / 2;
                    var yValue = type.flip
                        ? (summaryPoint.value / actualMax) * (columnWidth + joyHeight_1) -
                            columnWidth / 2
                        : (-summaryPoint.value / actualMax) * (columnWidth + joyHeight_1) +
                            columnWidth / 2;
                    joyPoints_1.push({
                        y: yValue,
                        x: xValue
                    });
                    //Don't make an interaction point for the first or last
                    if (i !== 0 && i !== joyBins_1.length - 1) {
                        summaryXYCoords.push({
                            key: summary.name,
                            x: xValue + translate[0],
                            y: yValue + translate[1],
                            pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                            value: summaryPoint.value
                        });
                    }
                });
            }
            else if (projection === "vertical") {
                joyBins_1.forEach(function (summaryPoint) {
                    var yValue = summaryPoint.y + bucketSize / 2;
                    var xValue = type.flip === true
                        ? (summaryPoint.value / actualMax) * (columnWidth + joyHeight_1) -
                            columnWidth / 2
                        : (-summaryPoint.value / actualMax) * (columnWidth + joyHeight_1) +
                            columnWidth / 2;
                    joyPoints_1.push({
                        y: yValue,
                        x: xValue
                    });
                    summaryXYCoords.push({
                        key: summary.name,
                        x: xValue + translate[0],
                        y: yValue + translate[1],
                        pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                        value: summaryPoint.value
                    });
                });
            }
            else if (projection === "radial") {
                var angle_2 = summary.pct - summary.pct_padding / 2;
                var midAngle_2 = summary.pct_start + summary.pct_padding / 2;
                translate = [0, 0];
                joyPoints_1 = joyBins_1;
                joyArea = function (inbins) {
                    var forward = [];
                    inbins.forEach(function (bin) {
                        var outsidePoint = pieceDrawing_1.pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], midAngle_2 + (angle_2 * bin.value) / actualMax, (bin.y + bin.y1 - bucketSize / 2) / 2);
                        //Ugh a terrible side effect has appeared
                        summaryXYCoords.push({
                            key: summary.name,
                            x: outsidePoint[0] + translate[0],
                            y: outsidePoint[1] + translate[1],
                            pieces: bin.pieces.map(function (d) { return d.piece; }),
                            value: bin.value
                        });
                        forward.push(outsidePoint);
                    });
                    return "M" + forward.map(function (d) { return d.join(","); }).join("L") + "Z";
                };
            }
            if (type.axis) {
                renderedSummaryMarks.push(createSummaryAxis({
                    summary: summary,
                    summaryI: summaryI,
                    axisSettings: type.axis,
                    axisCreator: axisCreator,
                    projection: projection,
                    actualMax: actualMax,
                    adjustedSize: adjustedSize,
                    columnWidth: columnWidth
                }));
            }
            renderedSummaryMarks.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { transform: "translate(" + translate + ")", key: "summaryPiece-" + summaryI }, eventListeners, { renderMode: renderValue, markType: "path", className: calculatedSummaryClass, style: calculatedSummaryStyle, d: joyArea(joyPoints_1), role: "img", tabIndex: -1, "data-o": summary.name, "aria-label": summary.name + " distribution" })));
        }
        else if (type.type === "horizon") {
            var zeroedStart = Object.assign({}, bins[0], { value: 0 });
            var zeroedEnd = Object.assign({}, bins[bins.length - 1], { value: 0 });
            zeroedStart.y = zeroedStart.y - bucketSize / 2;
            zeroedEnd.y = zeroedEnd.y + bucketSize / 2;
            var horizonBins_1 = __spread([zeroedStart], bins, [zeroedEnd]);
            var horizonStyle_1 = type.elementStyleFn || (function () { return ({}); });
            var multiBins = [];
            var remainingPieces = true;
            var currentHorizon_1 = 0;
            while (remainingPieces === true) {
                var currentStrip = horizonBins_1.map(function (d) { return (__assign(__assign({}, d), { value: Math.max(0, Math.min(d.value - currentHorizon_1, horizon)) })); });
                multiBins.push(currentStrip.map(function (d) { return (__assign(__assign({}, d), { value: d.value * numHorizons })); }));
                currentHorizon_1 += horizon;
                if (d3_array_2.max(currentStrip.map(function (d) { return d.value; })) < horizon) {
                    remainingPieces = false;
                }
            }
            multiBins = multiBins.filter(function (d) { return d3_array_3.sum(d.map(function (p) { return p.value; })) > 0; });
            horizonBins_1.forEach(function (summaryPoint, i) {
                if (i !== 0 && i !== horizonBins_1.length - 1) {
                    if (projection === "horizontal") {
                        var xValue = summaryPoint.y - bucketSize / 2;
                        var yValue = (-summaryPoint.value / actualMax) * (columnWidth) +
                            columnWidth / 2;
                        summaryXYCoords.push({
                            key: summary.name,
                            x: xValue + translate[0],
                            y: yValue + translate[1],
                            pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                            value: summaryPoint.value
                        });
                    }
                    else if (projection === "vertical") {
                        var yValue = summaryPoint.y + bucketSize / 2;
                        var xValue = type.flip === true
                            ? (summaryPoint.value / actualMax) * (columnWidth) -
                                columnWidth / 2
                            : (-summaryPoint.value / actualMax) * (columnWidth) +
                                columnWidth / 2;
                        summaryXYCoords.push({
                            key: summary.name,
                            x: xValue + translate[0],
                            y: yValue + translate[1],
                            pieces: summaryPoint.pieces.map(function (d) { return d.piece; }),
                            value: summaryPoint.value
                        });
                    }
                }
            });
            var multiBinMarks = multiBins.map(function (multiBin, multiBinI) {
                var horizonPoints = [];
                var interpolatorSetting = type.curve || type.interpolator;
                var actualInterpolator = typeof interpolatorSetting === "string"
                    ? general_1.curveHash[interpolatorSetting]
                    : interpolatorSetting;
                var horizonArea = d3_shape_1.line()
                    .curve(actualInterpolator || d3_shape_1.curveLinear)
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; });
                if (projection === "horizontal") {
                    multiBin.forEach(function (summaryPoint) {
                        var xValue = summaryPoint.y - bucketSize / 2;
                        var yValue = (-summaryPoint.value / actualMax) * (columnWidth) +
                            columnWidth / 2;
                        horizonPoints.push({
                            y: yValue,
                            x: xValue
                        });
                        //Don't make an interaction point for the first or last
                    });
                }
                else if (projection === "vertical") {
                    multiBin.forEach(function (summaryPoint) {
                        var yValue = summaryPoint.y + bucketSize / 2;
                        var xValue = type.flip === true
                            ? (summaryPoint.value / actualMax) * (columnWidth) -
                                columnWidth / 2
                            : (-summaryPoint.value / actualMax) * (columnWidth) +
                                columnWidth / 2;
                        horizonPoints.push({
                            y: yValue,
                            x: xValue
                        });
                    });
                }
                else if (projection === "radial") {
                    var angle_3 = summary.pct - summary.pct_padding / 2;
                    var midAngle_3 = summary.pct_start + summary.pct_padding / 2;
                    translate = [0, 0];
                    horizonPoints = multiBin;
                    horizonArea = function (inbins) {
                        var forward = [];
                        inbins.forEach(function (bin) {
                            var outsidePoint = pieceDrawing_1.pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], midAngle_3 + (angle_3 * bin.value) / actualMax, (bin.y + bin.y1 - bucketSize / 2) / 2);
                            forward.push(outsidePoint);
                        });
                        return "M" + forward.map(function (d) { return d.join(","); }).join("L") + "Z";
                    };
                }
                return React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { transform: "translate(" + translate + ")", key: "summaryPiece-" + summaryI + "-" + multiBinI }, eventListeners, { renderMode: renderValue, markType: "path", className: calculatedSummaryClass, style: __assign(__assign({}, calculatedSummaryStyle), horizonStyle_1(multiBin, multiBinI)), d: horizonArea(horizonPoints), role: "img", tabIndex: -1, "data-o": summary.name, "aria-label": summary.name + " distribution" }));
            });
            if (type.axis) {
                renderedSummaryMarks.push(createSummaryAxis({
                    summary: summary,
                    summaryI: summaryI,
                    axisSettings: type.axis,
                    axisCreator: axisCreator,
                    projection: projection,
                    actualMax: actualMax,
                    adjustedSize: adjustedSize,
                    columnWidth: columnWidth
                }));
            }
            renderedSummaryMarks.push(React.createElement("g", null, multiBinMarks));
        }
    });
    return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}
exports.bucketizedRenderingFn = bucketizedRenderingFn;
exports.drawSummaries = function (_a) {
    var data = _a.data, type = _a.type, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, classFn = _a.classFn, projection = _a.projection, adjustedSize = _a.adjustedSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps;
    if (!type || !type.type)
        return;
    type = typeof type === "string" ? { type: type } : type;
    var chartSize = projection === "vertical" ? adjustedSize[1] : adjustedSize[0];
    return frameFunctions_1.orFrameSummaryRenderer({
        data: data,
        type: type,
        renderMode: renderMode,
        eventListenersGenerator: eventListenersGenerator,
        styleFn: styleFn,
        classFn: classFn,
        projection: projection,
        adjustedSize: adjustedSize,
        chartSize: chartSize,
        margin: margin,
        baseMarkProps: baseMarkProps
    });
};
exports.renderLaidOutSummaries = function (_a) {
    var data = _a.data;
    return data;
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var TooltipPositioner = /** @class */ (function (_super) {
    __extends(TooltipPositioner, _super);
    function TooltipPositioner() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.containerRef = React.createRef();
        _this.state = {
            collision: null,
            tooltipContainerInitialDimensions: null,
            tooltipContentArgsCurrent: null
        };
        // simple heuristics to check if the tooltip container exceeds the viewport
        // if so, capture the suggested offset
        _this.checkPosition = function () {
            var tooltipContainerInitialDimensions = _this.containerRef.current.getBoundingClientRect();
            var right = tooltipContainerInitialDimensions.right, left = tooltipContainerInitialDimensions.left, top = tooltipContainerInitialDimensions.top, bottom = tooltipContainerInitialDimensions.bottom, width = tooltipContainerInitialDimensions.width, height = tooltipContainerInitialDimensions.height;
            // flags to indicate whether the data point + tooltip dimension collides with the viewport
            // on each of the 4 directions/sides
            var collision = {
                left: false,
                right: false,
                top: false,
                bottom: false
            };
            if ((left + width) > window.innerWidth) {
                collision.right = true;
            }
            if ((left - width) < 0) {
                collision.left = true;
            }
            if ((top + height) > window.innerHeight) {
                collision.bottom = true;
            }
            if ((top - height) < 0) {
                collision.top = true;
            }
            _this.setState({
                collision: collision,
                tooltipContainerInitialDimensions: tooltipContainerInitialDimensions,
                tooltipContentArgsCurrent: _this.props.tooltipContentArgs
            });
        };
        return _this;
    }
    TooltipPositioner.prototype.componentDidMount = function () {
        if (this.containerRef.current && !this.state.collision) {
            this.checkPosition();
        }
    };
    TooltipPositioner.prototype.componentDidUpdate = function (pp) {
        // if new args, reset collision state
        if (pp.tooltipContentArgs !== this.props.tooltipContentArgs) {
            this.setState({
                collision: null,
                tooltipContainerInitialDimensions: null
            });
        }
        else if (this.containerRef.current && !this.state.collision) {
            this.checkPosition();
        }
    };
    TooltipPositioner.prototype.render = function () {
        var _a = this.props, tooltipContent = _a.tooltipContent, tooltipContentArgs = _a.tooltipContentArgs;
        var _b = this.state, collision = _b.collision, tooltipContainerInitialDimensions = _b.tooltipContainerInitialDimensions, tooltipContentArgsCurrent = _b.tooltipContentArgsCurrent;
        var containerStyle = {
            //to handle issue when the tooltip content has margins set by client,
            // which results in the tooltip container having smaller height,
            // which in turn causes the css transform to be inaccurate
            // (ref: https://www.w3.org/TR/css-box-3/#collapsing-margins)
            overflow: 'hidden',
            opacity: collision && (tooltipContentArgsCurrent === tooltipContentArgs) ? 1 : 0
        };
        var tooltipContainerAttributes = {
            tooltipContainerInitialDimensions: tooltipContainerInitialDimensions,
        };
        var tooltipContainerClasses = collision ?
            [
                'tooltip-container',
                'tooltip-collision-evaluated',
                collision && collision.top && 'collision-top',
                collision && collision.bottom && 'collision-bottom',
                collision && collision.right && 'collision-right',
                collision && collision.left && 'collision-left',
            ].filter(function (el) { return el; }).join(' ')
            : 'tooltip-container';
        return (React.createElement("div", { ref: this.containerRef, style: containerStyle, className: tooltipContainerClasses }, tooltipContent(__assign(__assign({}, tooltipContentArgs), { tooltipContainerAttributes: tooltipContainerAttributes }))));
    };
    return TooltipPositioner;
}(React.Component));
exports.default = TooltipPositioner;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutCircle;

var _SubjectCircle = _interopRequireDefault(__webpack_require__(281));

var _ConnectorElbow = _interopRequireDefault(__webpack_require__(67));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutCircle(props) {
  var className = (0, _classnames.default)("callout circle", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectCircle.default, {
    radius: 20
  });
}

/***/ }),
/* 126 */
/***/ (function(module, exports) {

/**
 * Signed area of the triangle (p0, p1, p2)
 * @param  {Array.<Number>} p0
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Number}
 */
module.exports = function signedArea(p0, p1, p2) {
  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

//size is a special case and handled checking the actual values in the size array
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var sharedChangeProps = [
    "customClickBehavior",
    "customHoverBehavior",
    "customDoubleClickBehavior",
    "hoverAnnotation",
    "name",
    "title",
    "margin",
    "className",
    "additionalDefs",
    "renderKey"
];
exports.xyFrameDataProps = [
    "lines",
    "points",
    "summaries",
    "xScaleType",
    "yScaleType",
    "xAccessor",
    "yAccessor",
    "lineDataAccessor",
    "areaDataAccessor",
    "summaryDataAccessor",
    "lineType",
    "showLinePoints",
    "showSummaryPoints",
    "defined",
    "summaryType"
];
exports.xyFrameChangeProps = __spread(sharedChangeProps, exports.xyFrameDataProps, [
    "axes",
    "xExtent",
    "yExtent",
    "invertX",
    "invertY",
    "defined",
    "lineStyle",
    "pointStyle",
    "summaryStyle",
    "lineClass",
    "pointClass",
    "areaClass",
    "summaryClass",
    "canvasPoints",
    "customPointMark",
    "customLineMark",
    "lineIDAccessor"
]);
exports.orFrameChangeProps = __spread(sharedChangeProps, [
    "pieceHoverAnnotation",
    "summaryHoverAnnotation",
    "data",
    "orient",
    "oScaleType",
    "rScaleType",
    "oExtent",
    "rExtent",
    "invertO",
    "invertR",
    "oAccessor",
    "rAccessor",
    "oPadding",
    "projection",
    "type",
    "summaryType",
    "connectorType",
    "dataAccessor",
    "rBaseline",
    "oSort",
    "dynamicColumnWidth",
    "style",
    "connectorStyle",
    "summaryStyle",
    "summaryPosition",
    "oLabel",
    "axes",
    "renderFn"
]);
exports.networkFrameChangeProps = __spread(sharedChangeProps, [
    "graph",
    "nodes",
    "edges",
    "nodeIDAccessor",
    "sourceAccessor",
    "targetAccessor",
    "nodeSizeAccessor",
    "customNodeIcon",
    "nodeLabels",
    "edgeWidthAccessor",
    "networkType",
    "renderFn",
    "nodeStyle",
    "edgeStyle",
    "edgeType",
    "filterRenderedNodes"
]);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_scale_1 = __webpack_require__(24);
var frame_props_1 = __webpack_require__(127);
var orframeRules_1 = __webpack_require__(300);
var baseRules_1 = __webpack_require__(51);
var multiAccessorUtils_1 = __webpack_require__(69);
var Frame_1 = __importDefault(__webpack_require__(120));
var dataFunctions_1 = __webpack_require__(52);
var ordinal_1 = __webpack_require__(305);
var xScale = d3_scale_1.scaleLinear();
var yScale = d3_scale_1.scaleLinear();
var projectedCoordinatesObject = { y: "y", x: "x" };
var defaultOverflow = { top: 0, bottom: 0, left: 0, right: 0 };
var OrdinalFrame = /** @class */ (function (_super) {
    __extends(OrdinalFrame, _super);
    function OrdinalFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.defaultORSVGRule = function (_a) {
            var d = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.props, projection = _b.projection, svgAnnotationRules = _b.svgAnnotationRules;
            var _c = _this.state, adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize, oAccessor = _c.oAccessor, rAccessor = _c.rAccessor, oScale = _c.oScale, rScale = _c.rScale, projectedColumns = _c.projectedColumns, orFrameRender = _c.orFrameRender, pieceIDAccessor = _c.pieceIDAccessor, rScaleType = _c.rScaleType, summaryType = _c.summaryType, type = _c.type;
            var screenCoordinates = [0, 0];
            orframeRules_1.getColumnScreenCoordinates;
            if (d.isColumnAnnotation) {
                var _d = __read(orframeRules_1.getColumnScreenCoordinates({
                    d: d,
                    projectedColumns: projectedColumns,
                    oAccessor: oAccessor,
                    summaryType: summaryType,
                    type: type,
                    projection: projection,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize
                }).coordinates, 2), xPosition = _d[0], yPosition = _d[1];
                screenCoordinates = [xPosition, yPosition];
            }
            else if (d.coordinates || (d.type === "enclose" && d.neighbors)) {
                screenCoordinates = (d.coordinates || d.neighbors).map(function (p) {
                    var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, p) || p.column;
                    var oColumn = projectedColumns[pO];
                    var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, p);
                    return orframeRules_1.screenProject({
                        p: p,
                        adjustedSize: adjustedSize,
                        rScale: rScale,
                        rAccessor: rAccessor,
                        idPiece: idPiece,
                        projection: projection,
                        oColumn: oColumn,
                        rScaleType: rScaleType
                    });
                });
            }
            else {
                var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d) || d.column;
                var oColumn = projectedColumns[pO];
                var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, d);
                screenCoordinates = orframeRules_1.screenProject({
                    p: d,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    idPiece: idPiece,
                    projection: projection,
                    oColumn: oColumn,
                    rScaleType: rScaleType
                });
            }
            var voronoiHover = annotationLayer.voronoiHover;
            //TODO: Process your rules first
            var customAnnotation = svgAnnotationRules &&
                svgAnnotationRules({
                    d: d,
                    i: i,
                    oScale: oScale,
                    rScale: rScale,
                    oAccessor: oAccessor,
                    rAccessor: rAccessor,
                    orFrameProps: _this.props,
                    orFrameState: _this.state,
                    screenCoordinates: screenCoordinates,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer,
                    categories: projectedColumns,
                    voronoiHover: voronoiHover
                });
            if (svgAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "ordinal-line") {
                return orframeRules_1.svgOrdinalLine({ d: d, screenCoordinates: screenCoordinates, voronoiHover: voronoiHover });
            }
            else if (d.type === "or") {
                return orframeRules_1.svgORRule({ d: d, i: i, screenCoordinates: screenCoordinates, projection: projection });
            }
            else if (d.type === "highlight") {
                return orframeRules_1.svgHighlightRule({
                    d: d,
                    pieceIDAccessor: pieceIDAccessor,
                    orFrameRender: orFrameRender,
                    oAccessor: oAccessor
                });
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return orframeRules_1.basicReactAnnotationRule({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "enclose") {
                return orframeRules_1.svgEncloseRule({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "enclose-rect") {
                return orframeRules_1.svgRectEncloseRule({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "r") {
                return orframeRules_1.svgRRule({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    projection: projection,
                    adjustedSize: adjustedSize,
                    adjustedPosition: adjustedPosition
                });
            }
            else if (d.type === "category") {
                return orframeRules_1.svgCategoryRule({
                    projection: projection,
                    d: d,
                    i: i,
                    categories: _this.state.projectedColumns,
                    adjustedSize: adjustedSize
                });
            }
            return null;
        };
        _this.defaultORHTMLRule = function (_a) {
            var d = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.state, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, oAccessor = _b.oAccessor, rAccessor = _b.rAccessor, oScale = _b.oScale, rScale = _b.rScale, projectedColumns = _b.projectedColumns, summaryType = _b.summaryType, type = _b.type, pieceIDAccessor = _b.pieceIDAccessor, rScaleType = _b.rScaleType;
            var _c = _this.props, htmlAnnotationRules = _c.htmlAnnotationRules, tooltipContent = _c.tooltipContent, optimizeCustomTooltipPosition = _c.optimizeCustomTooltipPosition, projection = _c.projection, size = _c.size, useSpans = _c.useSpans;
            var screenCoordinates = [0, 0];
            var voronoiHover = annotationLayer.voronoiHover;
            if (d.coordinates || (d.type === "enclose" && d.neighbors)) {
                screenCoordinates = (d.coordinates || d.neighbors).map(function (p) {
                    var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, p) || p.column;
                    var oColumn = projectedColumns[pO];
                    var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, p);
                    return orframeRules_1.screenProject({
                        p: p,
                        adjustedSize: adjustedSize,
                        rScale: rScale,
                        rAccessor: rAccessor,
                        idPiece: idPiece,
                        projection: projection,
                        oColumn: oColumn,
                        rScaleType: rScaleType
                    });
                });
            }
            else if (d.type === "column-hover") {
                var _d = __read(orframeRules_1.getColumnScreenCoordinates({
                    d: d,
                    projectedColumns: projectedColumns,
                    oAccessor: oAccessor,
                    summaryType: summaryType,
                    type: type,
                    projection: projection,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize
                }).coordinates, 2), xPosition = _d[0], yPosition = _d[1];
                screenCoordinates = [xPosition, yPosition];
            }
            else {
                var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d) || d.column;
                var oColumn = projectedColumns[pO];
                var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, d);
                screenCoordinates = orframeRules_1.screenProject({
                    p: d,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    idPiece: idPiece,
                    projection: projection,
                    oColumn: oColumn,
                    rScaleType: rScaleType
                });
            }
            var flippedRScale = projection === "vertical"
                ? rScaleType.domain(rScale.domain()).range(rScale.range().reverse())
                : rScale;
            //TODO: Process your rules first
            var customAnnotation = htmlAnnotationRules &&
                htmlAnnotationRules({
                    d: d,
                    i: i,
                    oScale: oScale,
                    rScale: flippedRScale,
                    oAccessor: oAccessor,
                    rAccessor: rAccessor,
                    orFrameProps: _this.props,
                    screenCoordinates: screenCoordinates,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer,
                    orFrameState: _this.state,
                    categories: _this.state.projectedColumns,
                    voronoiHover: voronoiHover
                });
            if (htmlAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            if (d.type === "frame-hover") {
                return orframeRules_1.htmlFrameHoverRule({
                    d: d,
                    i: i,
                    rAccessor: rAccessor,
                    oAccessor: oAccessor,
                    projection: projection,
                    tooltipContent: tooltipContent,
                    optimizeCustomTooltipPosition: optimizeCustomTooltipPosition,
                    projectedColumns: projectedColumns,
                    useSpans: useSpans,
                    pieceIDAccessor: pieceIDAccessor,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    type: type,
                    rScaleType: rScaleType
                });
            }
            else if (d.type === "column-hover") {
                return orframeRules_1.htmlColumnHoverRule({
                    d: d,
                    i: i,
                    summaryType: summaryType,
                    oAccessor: oAccessor,
                    projectedColumns: projectedColumns,
                    type: type,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    projection: projection,
                    tooltipContent: tooltipContent,
                    optimizeCustomTooltipPosition: optimizeCustomTooltipPosition,
                    useSpans: useSpans
                });
            }
            return null;
        };
        var baseState = {
            adjustedPosition: [],
            adjustedSize: [],
            backgroundGraphics: undefined,
            foregroundGraphics: undefined,
            axisData: undefined,
            renderNumber: 0,
            oLabels: { labels: [] },
            oAccessor: dataFunctions_1.stringToArrayFn("renderKey"),
            rAccessor: dataFunctions_1.stringToArrayFn("value"),
            oScale: d3_scale_1.scaleBand(),
            rScale: d3_scale_1.scaleLinear(),
            axes: undefined,
            calculatedOExtent: [],
            calculatedRExtent: [0, 1],
            columnOverlays: [],
            dataVersion: undefined,
            legendSettings: undefined,
            margin: { top: 0, bottom: 0, left: 0, right: 0 },
            oExtent: [],
            oScaleType: d3_scale_1.scaleBand(),
            orFrameRender: {},
            pieceDataXY: [],
            pieceIDAccessor: dataFunctions_1.stringToFn("semioticPieceID"),
            projectedColumns: {},
            rExtent: [],
            rScaleType: d3_scale_1.scaleLinear(),
            summaryType: { type: "none" },
            title: {},
            type: { type: "none" },
            props: props
        };
        _this.state = __assign(__assign({}, baseState), ordinal_1.calculateOrdinalFrame(props, baseState));
        return _this;
    }
    OrdinalFrame.prototype.componentWillUnmount = function () {
        var onUnmount = this.props.onUnmount;
        if (onUnmount) {
            onUnmount(this.props, this.state);
        }
    };
    OrdinalFrame.getDerivedStateFromProps = function (nextProps, prevState) {
        var props = prevState.props;
        if ((prevState.dataVersion &&
            prevState.dataVersion !== nextProps.dataVersion) ||
            !prevState.projectedColumns ||
            props.size[0] !== nextProps.size[0] ||
            props.size[1] !== nextProps.size[1] ||
            (!prevState.dataVersion &&
                frame_props_1.orFrameChangeProps.find(function (d) {
                    return props[d] !== nextProps[d];
                }))) {
            return __assign(__assign({}, ordinal_1.calculateOrdinalFrame(nextProps, prevState)), { props: nextProps });
        }
        else {
            return { props: nextProps };
        }
    };
    OrdinalFrame.prototype.render = function () {
        var _a = this.props, className = _a.className, annotationSettings = _a.annotationSettings, annotations = _a.annotations, matte = _a.matte, renderKey = _a.renderKey, interaction = _a.interaction, customClickBehavior = _a.customClickBehavior, customHoverBehavior = _a.customHoverBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, projection = _a.projection, backgroundGraphics = _a.backgroundGraphics, foregroundGraphics = _a.foregroundGraphics, afterElements = _a.afterElements, beforeElements = _a.beforeElements, disableContext = _a.disableContext, summaryType = _a.summaryType, summaryHoverAnnotation = _a.summaryHoverAnnotation, pieceHoverAnnotation = _a.pieceHoverAnnotation, hoverAnnotation = _a.hoverAnnotation, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasPieces = _a.canvasPieces, canvasSummaries = _a.canvasSummaries, canvasConnectors = _a.canvasConnectors, renderOrder = _a.renderOrder, additionalDefs = _a.additionalDefs, sketchyRenderingEngine = _a.sketchyRenderingEngine, frameRenderOrder = _a.frameRenderOrder, disableCanvasInteraction = _a.disableCanvasInteraction;
        var _b = this.state, orFrameRender = _b.orFrameRender, projectedColumns = _b.projectedColumns, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, legendSettings = _b.legendSettings, columnOverlays = _b.columnOverlays, axesTickLines = _b.axesTickLines, axes = _b.axes, margin = _b.margin, pieceDataXY = _b.pieceDataXY, oLabels = _b.oLabels, title = _b.title;
        var size = [
            adjustedSize[0] + margin.left + margin.right,
            adjustedSize[1] + margin.top + margin.bottom
        ];
        var interactionOverflow;
        if (summaryType && summaryType.amplitude) {
            if (projection === "horizontal") {
                interactionOverflow = {
                    top: summaryType.amplitude,
                    bottom: 0,
                    left: 0,
                    right: 0
                };
            }
            else if (projection === "radial") {
                interactionOverflow = defaultOverflow;
            }
            else {
                interactionOverflow = {
                    top: 0,
                    bottom: 0,
                    left: summaryType.amplitude,
                    right: 0
                };
            }
        }
        var renderedForegroundGraphics = typeof foregroundGraphics === "function"
            ? foregroundGraphics({ size: size, margin: margin })
            : foregroundGraphics;
        return (React.createElement(Frame_1.default, { name: "ordinalframe", renderPipeline: orFrameRender, adjustedPosition: adjustedPosition, adjustedSize: adjustedSize, size: size, xScale: xScale, yScale: yScale, axes: axes, useSpans: useSpans, axesTickLines: axesTickLines, title: title, matte: matte, additionalDefs: additionalDefs, className: className + " " + projection, frameKey: "none", renderFn: renderKey, projectedCoordinateNames: projectedCoordinatesObject, defaultSVGRule: this.defaultORSVGRule.bind(this), defaultHTMLRule: this.defaultORHTMLRule.bind(this), hoverAnnotation: summaryHoverAnnotation || pieceHoverAnnotation || hoverAnnotation, annotations: annotations, annotationSettings: annotationSettings, legendSettings: legendSettings, interaction: interaction && __assign(__assign({}, interaction), { brush: interaction.columnsBrush !== true && "oBrush", projection: projection,
                projectedColumns: projectedColumns }), customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: pieceDataXY, margin: margin, columns: projectedColumns, backgroundGraphics: backgroundGraphics, foregroundGraphics: renderedForegroundGraphics, beforeElements: beforeElements, afterElements: afterElements, overlay: columnOverlays, rScale: this.state.rScale, projection: projection, disableContext: disableContext, interactionOverflow: interactionOverflow, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, canvasRendering: !!(canvasPieces || canvasSummaries || canvasConnectors), renderOrder: renderOrder, disableCanvasInteraction: disableCanvasInteraction, sketchyRenderingEngine: sketchyRenderingEngine, frameRenderOrder: frameRenderOrder, additionalVizElements: oLabels }));
    };
    OrdinalFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: [],
        annotationSettings: {},
        projection: "vertical",
        size: [500, 500],
        className: "",
        data: [],
        oScaleType: d3_scale_1.scaleBand,
        rScaleType: d3_scale_1.scaleLinear,
        type: "none",
        summaryType: "none",
        useSpans: false,
        optimizeCustomTooltipPosition: false
    };
    OrdinalFrame.displayName = "OrdinalFrame";
    return OrdinalFrame;
}(React.Component));
exports.default = OrdinalFrame;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.genericFunction = function (value) { return function () { return value; }; };


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var Frame_1 = __importDefault(__webpack_require__(120));
var dataFunctions_1 = __webpack_require__(52);
var frame_props_1 = __webpack_require__(127);
var networkframeRules_1 = __webpack_require__(317);
var baseRules_1 = __webpack_require__(51);
var functions_1 = __webpack_require__(129);
var d3_scale_1 = __webpack_require__(24);
var network_1 = __webpack_require__(183);
var blankArray = [];
var matrixRenderOrder = ["nodes", "edges"];
var generalRenderOrder = ["edges", "nodes"];
var projectedCoordinateNames = { y: "y", x: "x" };
var xScale = d3_scale_1.scaleLinear();
var yScale = d3_scale_1.scaleLinear();
var NetworkFrame = /** @class */ (function (_super) {
    __extends(NetworkFrame, _super);
    function NetworkFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.defaultNetworkSVGRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.state, projectedNodes = _b.projectedNodes, projectedEdges = _b.projectedEdges, nodeIDAccessor = _b.nodeIDAccessor, nodeSizeAccessor = _b.nodeSizeAccessor, networkFrameRender = _b.networkFrameRender, adjustedSize = _b.adjustedSize, adjustedPosition = _b.adjustedPosition;
            //TODO PASS FRAME STYLE FNs TO HIGHLIGHT
            var svgAnnotationRules = _this.props.svgAnnotationRules;
            var d = baseD.ids
                ? baseD
                : baseD.edge
                    ? __assign(__assign({}, (projectedEdges.find(function (p) {
                        return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) &&
                            nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
                    }) || {})), baseD) : __assign(__assign({}, (projectedNodes.find(function (p) { return nodeIDAccessor(p) === baseD.id; }) || {})), baseD);
            var voronoiHover = annotationLayer.voronoiHover;
            if (svgAnnotationRules) {
                var customAnnotation = svgAnnotationRules({
                    d: d,
                    i: i,
                    networkFrameProps: _this.props,
                    networkFrameState: _this.state,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    voronoiHover: voronoiHover,
                    screenCoordinates: [d.x, d.y],
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
                if (customAnnotation !== null) {
                    return customAnnotation;
                }
            }
            if (d.type === "node") {
                return networkframeRules_1.svgNodeRule({
                    d: d,
                    i: i,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "basic-node-label") {
                return (React.createElement("g", { key: d.key || "basic-" + i, transform: "translate(" + d.x + "," + d.y + ")" }, baseD.element || baseD.label));
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return networkframeRules_1.svgReactAnnotationRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor
                });
            }
            else if (d.type === "enclose") {
                return networkframeRules_1.svgEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "enclose-rect") {
                return networkframeRules_1.svgRectEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "enclose-hull") {
                return networkframeRules_1.svgHullEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "highlight") {
                return networkframeRules_1.svgHighlightRule({
                    d: d,
                    i: i,
                    networkFrameRender: networkFrameRender
                });
            }
            return null;
        };
        _this.defaultNetworkHTMLRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.props, tooltipContent = _b.tooltipContent, optimizeCustomTooltipPosition = _b.optimizeCustomTooltipPosition, htmlAnnotationRules = _b.htmlAnnotationRules, useSpans = _b.useSpans;
            var _c = _this.state, projectedNodes = _c.projectedNodes, projectedEdges = _c.projectedEdges, nodeIDAccessor = _c.nodeIDAccessor, adjustedSize = _c.adjustedSize, adjustedPosition = _c.adjustedPosition;
            var voronoiHover = annotationLayer.voronoiHover;
            var d = baseD.ids
                ? baseD
                : baseD.edge
                    ? __assign(__assign({}, (projectedEdges.find(function (p) {
                        return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) &&
                            nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
                    }) || {})), baseD) : __assign(__assign({}, (projectedNodes.find(function (p) { return nodeIDAccessor(p) === baseD.id; }) || {})), baseD);
            if (htmlAnnotationRules) {
                var customAnnotation = htmlAnnotationRules({
                    d: d,
                    i: i,
                    networkFrameProps: _this.props,
                    networkFrameState: _this.state,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    voronoiHover: voronoiHover,
                    screenCoordinates: [d.x, d.y],
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
                if (customAnnotation !== null) {
                    return customAnnotation;
                }
            }
            if (d.type === "frame-hover") {
                return networkframeRules_1.htmlFrameHoverRule({
                    d: d,
                    i: i,
                    tooltipContent: tooltipContent,
                    optimizeCustomTooltipPosition: optimizeCustomTooltipPosition,
                    useSpans: useSpans,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    nodeIDAccessor: nodeIDAccessor
                });
            }
            return null;
        };
        var baseState = {
            dataVersion: undefined,
            nodeData: [],
            edgeData: [],
            adjustedPosition: [],
            adjustedSize: [],
            backgroundGraphics: null,
            foregroundGraphics: null,
            projectedNodes: [],
            projectedEdges: [],
            renderNumber: 0,
            nodeLabelAnnotations: [],
            graphSettings: {
                type: "empty-start",
                nodes: [],
                edges: [],
                nodeHash: new Map(),
                edgeHash: new Map(),
                hierarchicalNetwork: false
            },
            edgeWidthAccessor: dataFunctions_1.stringToFn("weight"),
            legendSettings: undefined,
            margin: { top: 0, left: 0, right: 0, bottom: 0 },
            networkFrameRender: {},
            nodeIDAccessor: dataFunctions_1.stringToFn("id"),
            nodeSizeAccessor: functions_1.genericFunction(5),
            overlay: [],
            projectedXYPoints: [],
            sourceAccessor: dataFunctions_1.stringToFn("source"),
            targetAccessor: dataFunctions_1.stringToFn("target"),
            title: { title: undefined },
            props: props
        };
        _this.state = __assign(__assign({}, baseState), network_1.calculateNetworkFrame(props, baseState));
        return _this;
    }
    NetworkFrame.prototype.componentWillUnmount = function () {
        var onUnmount = this.props.onUnmount;
        if (onUnmount) {
            onUnmount(this.props, this.state);
        }
    };
    NetworkFrame.getDerivedStateFromProps = function (nextProps, prevState) {
        var props = prevState.props;
        if ((prevState.dataVersion &&
            prevState.dataVersion !== nextProps.dataVersion) ||
            (!prevState.projectedNodes && !prevState.projectedEdges) ||
            props.size[0] !== nextProps.size[0] ||
            props.size[1] !== nextProps.size[1] ||
            (!prevState.dataVersion &&
                frame_props_1.networkFrameChangeProps.find(function (d) {
                    return props[d] !== nextProps[d];
                }))) {
            return __assign(__assign({}, network_1.calculateNetworkFrame(nextProps, prevState)), { props: nextProps });
        }
        return { props: nextProps };
    };
    NetworkFrame.prototype.onNodeClick = function (d, i) {
        var onNodeClick = this.props.onNodeClick;
        if (onNodeClick) {
            onNodeClick(d, i);
        }
    };
    NetworkFrame.prototype.onNodeEnter = function (d, i) {
        var onNodeEnter = this.props.onNodeEnter;
        if (onNodeEnter) {
            onNodeEnter(d, i);
        }
    };
    NetworkFrame.prototype.onNodeOut = function (d, i) {
        var onNodeOut = this.props.onNodeOut;
        if (onNodeOut) {
            onNodeOut(d, i);
        }
    };
    NetworkFrame.prototype.render = function () {
        var _a = this.props, annotations = _a.annotations, annotationSettings = _a.annotationSettings, className = _a.className, customClickBehavior = _a.customClickBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, customHoverBehavior = _a.customHoverBehavior, size = _a.size, matte = _a.matte, hoverAnnotation = _a.hoverAnnotation, beforeElements = _a.beforeElements, afterElements = _a.afterElements, interaction = _a.interaction, disableContext = _a.disableContext, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasNodes = _a.canvasNodes, canvasEdges = _a.canvasEdges, additionalDefs = _a.additionalDefs, _b = _a.renderOrder, renderOrder = _b === void 0 ? this.state.graphSettings &&
            this.state.graphSettings.type === "matrix"
            ? matrixRenderOrder
            : generalRenderOrder : _b, sketchyRenderingEngine = _a.sketchyRenderingEngine, frameRenderOrder = _a.frameRenderOrder, disableCanvasInteraction = _a.disableCanvasInteraction, interactionSettings = _a.interactionSettings;
        var _c = this.state, backgroundGraphics = _c.backgroundGraphics, foregroundGraphics = _c.foregroundGraphics, projectedXYPoints = _c.projectedXYPoints, margin = _c.margin, legendSettings = _c.legendSettings, adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize, networkFrameRender = _c.networkFrameRender, nodeLabelAnnotations = _c.nodeLabelAnnotations, overlay = _c.overlay, title = _c.title;
        var formattedOverlay;
        if (overlay && overlay.length > 0) {
            formattedOverlay = overlay;
        }
        var activeHoverAnnotation;
        if (Array.isArray(hoverAnnotation)) {
            activeHoverAnnotation = hoverAnnotation;
        }
        else if (customClickBehavior ||
            customDoubleClickBehavior ||
            customHoverBehavior) {
            activeHoverAnnotation = blankArray;
        }
        else {
            activeHoverAnnotation = !!hoverAnnotation;
        }
        return (React.createElement(Frame_1.default, { name: "networkframe", renderPipeline: networkFrameRender, adjustedPosition: adjustedPosition, adjustedSize: adjustedSize, size: size, xScale: xScale, yScale: yScale, title: title, matte: matte, className: className, additionalDefs: additionalDefs, frameKey: "none", projectedCoordinateNames: projectedCoordinateNames, defaultSVGRule: this.defaultNetworkSVGRule, defaultHTMLRule: this.defaultNetworkHTMLRule, hoverAnnotation: activeHoverAnnotation, annotations: __spread(annotations, nodeLabelAnnotations), annotationSettings: annotationSettings, legendSettings: legendSettings, interaction: interaction, customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: projectedXYPoints, margin: margin, overlay: formattedOverlay, backgroundGraphics: backgroundGraphics, foregroundGraphics: foregroundGraphics, beforeElements: beforeElements, afterElements: afterElements, disableContext: disableContext, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, useSpans: !!useSpans, canvasRendering: !!(canvasNodes || canvasEdges), renderOrder: renderOrder, disableCanvasInteraction: disableCanvasInteraction, sketchyRenderingEngine: sketchyRenderingEngine, frameRenderOrder: frameRenderOrder, interactionSettings: interactionSettings }));
    };
    NetworkFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: [],
        annotationSettings: {},
        size: [500, 500],
        className: "",
        name: "networkframe",
        networkType: { type: "force", iterations: 500 },
        filterRenderedNodes: function (d) { return d.id !== "root-generated"; }
    };
    NetworkFrame.displayName = "NetworkFrame";
    return NetworkFrame;
}(React.Component));
exports.default = NetworkFrame;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(186),
    castFunction = __webpack_require__(190);

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

module.exports = forOwn;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(343),
    isObjectLike = __webpack_require__(25);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(345),
    baseUnary = __webpack_require__(137),
    nodeUtil = __webpack_require__(138);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 137 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(185);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(133)(module)))

/***/ }),
/* 139 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    isObject = __webpack_require__(20);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(189);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(365),
    mapCacheDelete = __webpack_require__(372),
    mapCacheGet = __webpack_require__(374),
    mapCacheHas = __webpack_require__(375),
    mapCacheSet = __webpack_require__(376);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(387),
    stubArray = __webpack_require__(200);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(16),
    isSymbol = __webpack_require__(95);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(208);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(196);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkboard = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _checkboard = __webpack_require__(434);

var checkboard = _interopRequireWildcard(_checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Checkboard = exports.Checkboard = function Checkboard(_ref) {
  var white = _ref.white,
      grey = _ref.grey,
      size = _ref.size,
      renderers = _ref.renderers,
      borderRadius = _ref.borderRadius,
      boxShadow = _ref.boxShadow,
      children = _ref.children;

  var styles = (0, _reactcss2.default)({
    'default': {
      grid: {
        borderRadius: borderRadius,
        boxShadow: boxShadow,
        absolute: '0px 0px 0px 0px',
        background: 'url(' + checkboard.get(white, grey, size, renderers.canvas) + ') center left'
      }
    }
  });
  return (0, _react.isValidElement)(children) ? _react2.default.cloneElement(children, _extends({}, children.props, { style: _extends({}, children.props.style, styles.grid) })) : _react2.default.createElement('div', { style: styles.grid });
};

Checkboard.defaultProps = {
  size: 8,
  white: 'transparent',
  grey: 'rgba(0,0,0,.08)',
  renderers: {}
};

exports.default = Checkboard;

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "ReactTableDefaults", function() { return /* binding */ ReactTableDefaults; });

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(0);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(5);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(63);

// CONCATENATED MODULE: ./node_modules/react-table/es/utils.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }





//
/* harmony default export */ var utils = ({
  get: get,
  set: set,
  takeRight: takeRight,
  last: last,
  orderBy: orderBy,
  range: range,
  remove: remove,
  clone: clone,
  getFirstDefined: getFirstDefined,
  sum: sum,
  makeTemplateComponent: makeTemplateComponent,
  groupBy: groupBy,
  isArray: isArray,
  splitProps: splitProps,
  compactObject: compactObject,
  isSortingDesc: isSortingDesc,
  normalizeComponent: normalizeComponent,
  asPx: asPx
});

function get(obj, path, def) {
  if (!path) {
    return obj;
  }
  var pathObj = makePathArray(path);
  var val = void 0;
  try {
    val = pathObj.reduce(function (current, pathPart) {
      return current[pathPart];
    }, obj);
  } catch (e) {
    // continue regardless of error
  }
  return typeof val !== 'undefined' ? val : def;
}

function set() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var path = arguments[1];
  var value = arguments[2];

  var keys = makePathArray(path);
  var keyPart = void 0;
  var cursor = obj;
  while ((keyPart = keys.shift()) && keys.length) {
    if (!cursor[keyPart]) {
      cursor[keyPart] = {};
    }
    cursor = cursor[keyPart];
  }
  cursor[keyPart] = value;
  return obj;
}

function takeRight(arr, n) {
  var start = n > arr.length ? 0 : arr.length - n;
  return arr.slice(start);
}

function last(arr) {
  return arr[arr.length - 1];
}

function range(n) {
  var arr = [];
  for (var i = 0; i < n; i += 1) {
    arr.push(n);
  }
  return arr;
}

function orderBy(arr, funcs, dirs, indexKey) {
  return arr.sort(function (rowA, rowB) {
    for (var i = 0; i < funcs.length; i += 1) {
      var comp = funcs[i];
      var desc = dirs[i] === false || dirs[i] === 'desc';
      var sortInt = comp(rowA, rowB);
      if (sortInt) {
        return desc ? -sortInt : sortInt;
      }
    }
    // Use the row index for tie breakers
    return dirs[0] ? rowA[indexKey] - rowB[indexKey] : rowB[indexKey] - rowA[indexKey];
  });
}

function remove(a, b) {
  return a.filter(function (o, i) {
    var r = b(o);
    if (r) {
      a.splice(i, 1);
      return true;
    }
    return false;
  });
}

function clone(a) {
  try {
    return JSON.parse(JSON.stringify(a, function (key, value) {
      if (typeof value === 'function') {
        return value.toString();
      }
      return value;
    }));
  } catch (e) {
    return a;
  }
}

function getFirstDefined() {
  for (var i = 0; i < arguments.length; i += 1) {
    if (typeof (arguments.length <= i ? undefined : arguments[i]) !== 'undefined') {
      return arguments.length <= i ? undefined : arguments[i];
    }
  }
}

function sum(arr) {
  return arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

function makeTemplateComponent(compClass, displayName) {
  if (!displayName) {
    throw new Error('No displayName found for template component:', compClass);
  }
  var cmp = function cmp(_ref) {
    var children = _ref.children,
        className = _ref.className,
        rest = _objectWithoutProperties(_ref, ['children', 'className']);

    return react_default.a.createElement(
      'div',
      _extends({ className: classnames_default()(compClass, className) }, rest),
      children
    );
  };
  cmp.displayName = displayName;
  return cmp;
}

function groupBy(xs, key) {
  return xs.reduce(function (rv, x, i) {
    var resKey = typeof key === 'function' ? key(x, i) : x[key];
    rv[resKey] = isArray(rv[resKey]) ? rv[resKey] : [];
    rv[resKey].push(x);
    return rv;
  }, {});
}

function asPx(value) {
  value = Number(value);
  return Number.isNaN(value) ? null : value + 'px';
}

function isArray(a) {
  return Array.isArray(a);
}

// ########################################################################
// Non-exported Helpers
// ########################################################################

function makePathArray(obj) {
  return flattenDeep(obj).join('.').replace(/\[/g, '.').replace(/\]/g, '').split('.');
}

function flattenDeep(arr) {
  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!isArray(arr)) {
    newArr.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], newArr);
    }
  }
  return newArr;
}

function splitProps(_ref2) {
  var className = _ref2.className,
      style = _ref2.style,
      rest = _objectWithoutProperties(_ref2, ['className', 'style']);

  return {
    className: className,
    style: style,
    rest: rest || {}
  };
}

function compactObject(obj) {
  var newObj = {};
  if (obj) {
    Object.keys(obj).map(function (key) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && obj[key] !== undefined && typeof obj[key] !== 'undefined') {
        newObj[key] = obj[key];
      }
      return true;
    });
  }
  return newObj;
}

function isSortingDesc(d) {
  return !!(d.sort === 'desc' || d.desc === true || d.asc === false);
}

function normalizeComponent(Comp, props) {
  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Comp;

  if (react_is["isElement"](Comp) || typeof Comp === 'string') {
    return Comp;
  } else if (react_is["isValidElementType"](Comp)) {
    return react_default.a.createElement(Comp, props);
  }

  return fallback;
}

// CONCATENATED MODULE: ./node_modules/react-table/es/lifecycle.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* harmony default export */ var lifecycle = (function (Base) {
  return function (_Base) {
    _inherits(_class, _Base);

    function _class(props) {
      _classCallCheck(this, _class);

      var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

      var defaultState = {
        page: props.defaultPage,
        pageSize: props.defaultPageSize,
        sorted: props.defaultSorted,
        expanded: props.defaultExpanded,
        filtered: props.defaultFiltered,
        resized: props.defaultResized,
        currentlyResizing: false,
        skipNextSort: false
      };
      var resolvedState = _this.getResolvedState(props, defaultState);
      var dataModel = _this.getDataModel(resolvedState, true);

      _this.state = _this.calculateNewResolvedState(dataModel);
      return _this;
    }

    _createClass(_class, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.fireFetchData();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var oldState = this.getResolvedState(prevProps, prevState);
        var newState = this.getResolvedState(this.props, this.state);

        // Do a deep compare of new and old `defaultOption` and
        // if they are different reset `option = defaultOption`
        var defaultableOptions = ['sorted', 'filtered', 'resized', 'expanded'];
        defaultableOptions.forEach(function (x) {
          var defaultName = 'default' + (x.charAt(0).toUpperCase() + x.slice(1));
          if (JSON.stringify(oldState[defaultName]) !== JSON.stringify(newState[defaultName])) {
            newState[x] = newState[defaultName];
          }
        });

        // If they change these table options, we need to reset defaults
        // or else we could get into a state where the user has changed the UI
        // and then disabled the ability to change it back.
        // e.g. If `filterable` has changed, set `filtered = defaultFiltered`
        var resettableOptions = ['sortable', 'filterable', 'resizable'];
        resettableOptions.forEach(function (x) {
          if (oldState[x] !== newState[x]) {
            var baseName = x.replace('able', '');
            var optionName = baseName + 'ed';
            var defaultName = 'default' + (optionName.charAt(0).toUpperCase() + optionName.slice(1));
            newState[optionName] = newState[defaultName];
          }
        });

        // Props that trigger a data update
        if (oldState.data !== newState.data || oldState.columns !== newState.columns || oldState.pivotBy !== newState.pivotBy || oldState.sorted !== newState.sorted || oldState.filtered !== newState.filtered) {
          this.setStateWithData(this.getDataModel(newState, oldState.data !== newState.data));
        }
      }
    }, {
      key: 'calculateNewResolvedState',
      value: function calculateNewResolvedState(dataModel) {
        var oldState = this.getResolvedState();
        var newResolvedState = this.getResolvedState({}, dataModel);
        var freezeWhenExpanded = newResolvedState.freezeWhenExpanded;

        // Default to unfrozen state

        newResolvedState.frozen = false;

        // If freezeWhenExpanded is set, check for frozen conditions
        if (freezeWhenExpanded) {
          // if any rows are expanded, freeze the existing data and sorting
          var keys = Object.keys(newResolvedState.expanded);
          for (var i = 0; i < keys.length; i += 1) {
            if (newResolvedState.expanded[keys[i]]) {
              newResolvedState.frozen = true;
              break;
            }
          }
        }

        // If the data isn't frozen and either the data or
        // sorting model has changed, update the data
        if (oldState.frozen && !newResolvedState.frozen || oldState.sorted !== newResolvedState.sorted || oldState.filtered !== newResolvedState.filtered || oldState.showFilters !== newResolvedState.showFilters || !newResolvedState.frozen && oldState.resolvedData !== newResolvedState.resolvedData) {
          // Handle collapseOnsortedChange & collapseOnDataChange
          if (oldState.sorted !== newResolvedState.sorted && this.props.collapseOnSortingChange || oldState.filtered !== newResolvedState.filtered || oldState.showFilters !== newResolvedState.showFilters || oldState.sortedData && !newResolvedState.frozen && oldState.resolvedData !== newResolvedState.resolvedData && this.props.collapseOnDataChange) {
            newResolvedState.expanded = {};
          }

          Object.assign(newResolvedState, this.getSortedData(newResolvedState));
        }

        // Set page to 0 if filters change
        if (oldState.filtered !== newResolvedState.filtered) {
          newResolvedState.page = 0;
        }

        // Calculate pageSize all the time
        if (newResolvedState.sortedData) {
          newResolvedState.pages = newResolvedState.manual ? newResolvedState.pages : Math.ceil(newResolvedState.sortedData.length / newResolvedState.pageSize);
          newResolvedState.page = newResolvedState.manual ? newResolvedState.page : Math.max(newResolvedState.page >= newResolvedState.pages ? newResolvedState.pages - 1 : newResolvedState.page, 0);
        }

        return newResolvedState;
      }
    }, {
      key: 'setStateWithData',
      value: function setStateWithData(dataModel, cb) {
        var _this2 = this;

        var oldState = this.getResolvedState();
        var newResolvedState = this.calculateNewResolvedState(dataModel);

        return this.setState(newResolvedState, function () {
          if (cb) {
            cb();
          }
          if (oldState.page !== newResolvedState.page || oldState.pageSize !== newResolvedState.pageSize || oldState.sorted !== newResolvedState.sorted || oldState.filtered !== newResolvedState.filtered) {
            _this2.fireFetchData();
          }
        });
      }
    }]);

    return _class;
  }(Base);
});

// CONCATENATED MODULE: ./node_modules/react-table/es/methods.js
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var methods_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var methods_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function methods_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function methods_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function methods_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/* harmony default export */ var methods = (function (Base) {
  return function (_Base) {
    methods_inherits(_class, _Base);

    function _class() {
      methods_classCallCheck(this, _class);

      return methods_possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    methods_createClass(_class, [{
      key: 'getResolvedState',
      value: function getResolvedState(props, state) {
        var resolvedState = methods_extends({}, utils.compactObject(this.state), utils.compactObject(this.props), utils.compactObject(state), utils.compactObject(props));
        return resolvedState;
      }
    }, {
      key: 'getDataModel',
      value: function getDataModel(newState, dataChanged) {
        var _this2 = this;

        var columns = newState.columns,
            _newState$pivotBy = newState.pivotBy,
            pivotBy = _newState$pivotBy === undefined ? [] : _newState$pivotBy,
            data = newState.data,
            resolveData = newState.resolveData,
            pivotIDKey = newState.pivotIDKey,
            pivotValKey = newState.pivotValKey,
            subRowsKey = newState.subRowsKey,
            aggregatedKey = newState.aggregatedKey,
            nestingLevelKey = newState.nestingLevelKey,
            originalKey = newState.originalKey,
            indexKey = newState.indexKey,
            groupedByPivotKey = newState.groupedByPivotKey,
            SubComponent = newState.SubComponent;

        // Determine Header Groups

        var hasHeaderGroups = false;
        columns.forEach(function (column) {
          if (column.columns) {
            hasHeaderGroups = true;
          }
        });

        var columnsWithExpander = [].concat(_toConsumableArray(columns));

        var expanderColumn = columns.find(function (col) {
          return col.expander || col.columns && col.columns.some(function (col2) {
            return col2.expander;
          });
        });
        // The actual expander might be in the columns field of a group column
        if (expanderColumn && !expanderColumn.expander) {
          expanderColumn = expanderColumn.columns.find(function (col) {
            return col.expander;
          });
        }

        // If we have SubComponent's we need to make sure we have an expander column
        if (SubComponent && !expanderColumn) {
          expanderColumn = { expander: true };
          columnsWithExpander = [expanderColumn].concat(_toConsumableArray(columnsWithExpander));
        }

        var makeDecoratedColumn = function makeDecoratedColumn(column, parentColumn) {
          var dcol = void 0;
          if (column.expander) {
            dcol = methods_extends({}, _this2.props.column, _this2.props.expanderDefaults, column);
          } else {
            dcol = methods_extends({}, _this2.props.column, column);
          }

          // Ensure minWidth is not greater than maxWidth if set
          if (dcol.maxWidth < dcol.minWidth) {
            dcol.minWidth = dcol.maxWidth;
          }

          if (parentColumn) {
            dcol.parentColumn = parentColumn;
          }

          // First check for string accessor
          if (typeof dcol.accessor === 'string') {
            dcol.id = dcol.id || dcol.accessor;
            var accessorString = dcol.accessor;
            dcol.accessor = function (row) {
              return utils.get(row, accessorString);
            };
            return dcol;
          }

          // Fall back to functional accessor (but require an ID)
          if (dcol.accessor && !dcol.id) {
            console.warn(dcol);
            throw new Error('A column id is required if using a non-string accessor for column above.');
          }

          // Fall back to an undefined accessor
          if (!dcol.accessor) {
            dcol.accessor = function () {
              return undefined;
            };
          }

          return dcol;
        };

        var allDecoratedColumns = [];

        // Decorate the columns
        var decorateAndAddToAll = function decorateAndAddToAll(column, parentColumn) {
          var decoratedColumn = makeDecoratedColumn(column, parentColumn);
          allDecoratedColumns.push(decoratedColumn);
          return decoratedColumn;
        };

        var decoratedColumns = columnsWithExpander.map(function (column) {
          if (column.columns) {
            return methods_extends({}, column, {
              columns: column.columns.map(function (d) {
                return decorateAndAddToAll(d, column);
              })
            });
          }
          return decorateAndAddToAll(column);
        });

        // Build the visible columns, headers and flat column list
        var visibleColumns = decoratedColumns.slice();
        var allVisibleColumns = [];

        visibleColumns = visibleColumns.map(function (column) {
          if (column.columns) {
            var visibleSubColumns = column.columns.filter(function (d) {
              return pivotBy.indexOf(d.id) > -1 ? false : utils.getFirstDefined(d.show, true);
            });
            return methods_extends({}, column, {
              columns: visibleSubColumns
            });
          }
          return column;
        });

        visibleColumns = visibleColumns.filter(function (column) {
          return column.columns ? column.columns.length : pivotBy.indexOf(column.id) > -1 ? false : utils.getFirstDefined(column.show, true);
        });

        // Find any custom pivot location
        var pivotIndex = visibleColumns.findIndex(function (col) {
          return col.pivot;
        });

        // Handle Pivot Columns
        if (pivotBy.length) {
          // Retrieve the pivot columns in the correct pivot order
          var pivotColumns = [];
          pivotBy.forEach(function (pivotID) {
            var found = allDecoratedColumns.find(function (d) {
              return d.id === pivotID;
            });
            if (found) {
              pivotColumns.push(found);
            }
          });

          var PivotParentColumn = pivotColumns.reduce(function (prev, current) {
            return prev && prev === current.parentColumn && current.parentColumn;
          }, pivotColumns[0].parentColumn);

          var PivotGroupHeader = hasHeaderGroups && PivotParentColumn.Header;
          PivotGroupHeader = PivotGroupHeader || function () {
            return react_default.a.createElement(
              'strong',
              null,
              'Pivoted'
            );
          };

          var pivotColumnGroup = {
            Header: PivotGroupHeader,
            columns: pivotColumns.map(function (col) {
              return methods_extends({}, _this2.props.pivotDefaults, col, {
                pivoted: true
              });
            })

            // Place the pivotColumns back into the visibleColumns
          };if (pivotIndex >= 0) {
            pivotColumnGroup = methods_extends({}, visibleColumns[pivotIndex], pivotColumnGroup);
            visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);
          } else {
            visibleColumns.unshift(pivotColumnGroup);
          }
        }

        // Build Header Groups
        var headerGroups = [];
        var currentSpan = [];

        // A convenience function to add a header and reset the currentSpan
        var addHeader = function addHeader(columns, column) {
          headerGroups.push(methods_extends({}, _this2.props.column, column, {
            columns: columns
          }));
          currentSpan = [];
        };

        // Build flast list of allVisibleColumns and HeaderGroups
        visibleColumns.forEach(function (column) {
          if (column.columns) {
            allVisibleColumns = allVisibleColumns.concat(column.columns);
            if (currentSpan.length > 0) {
              addHeader(currentSpan);
            }
            addHeader(column.columns, column);
            return;
          }
          allVisibleColumns.push(column);
          currentSpan.push(column);
        });
        if (hasHeaderGroups && currentSpan.length > 0) {
          addHeader(currentSpan);
        }

        // Access the data
        var accessRow = function accessRow(d, i) {
          var _row;

          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          var row = (_row = {}, _defineProperty(_row, originalKey, d), _defineProperty(_row, indexKey, i), _defineProperty(_row, subRowsKey, d[subRowsKey]), _defineProperty(_row, nestingLevelKey, level), _row);
          allDecoratedColumns.forEach(function (column) {
            if (column.expander) return;
            row[column.id] = column.accessor(d);
          });
          if (row[subRowsKey]) {
            row[subRowsKey] = row[subRowsKey].map(function (d, i) {
              return accessRow(d, i, level + 1);
            });
          }
          return row;
        };

        // // If the data hasn't changed, just use the cached data
        var resolvedData = this.resolvedData;
        // If the data has changed, run the data resolver and cache the result
        if (!this.resolvedData || dataChanged) {
          resolvedData = resolveData(data);
          this.resolvedData = resolvedData;
        }
        // Use the resolved data
        resolvedData = resolvedData.map(function (d, i) {
          return accessRow(d, i);
        });

        // TODO: Make it possible to fabricate nested rows without pivoting
        var aggregatingColumns = allVisibleColumns.filter(function (d) {
          return !d.expander && d.aggregate;
        });

        // If pivoting, recursively group the data
        var aggregate = function aggregate(rows) {
          var aggregationValues = {};
          aggregatingColumns.forEach(function (column) {
            var values = rows.map(function (d) {
              return d[column.id];
            });
            aggregationValues[column.id] = column.aggregate(values, rows);
          });
          return aggregationValues;
        };
        if (pivotBy.length) {
          var groupRecursively = function groupRecursively(rows, keys) {
            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            // This is the last level, just return the rows
            if (i === keys.length) {
              return rows;
            }
            // Group the rows together for this level
            var groupedRows = Object.entries(utils.groupBy(rows, keys[i])).map(function (_ref) {
              var _ref3;

              var _ref2 = _slicedToArray(_ref, 2),
                  key = _ref2[0],
                  value = _ref2[1];

              return _ref3 = {}, _defineProperty(_ref3, pivotIDKey, keys[i]), _defineProperty(_ref3, pivotValKey, key), _defineProperty(_ref3, keys[i], key), _defineProperty(_ref3, subRowsKey, value), _defineProperty(_ref3, nestingLevelKey, i), _defineProperty(_ref3, groupedByPivotKey, true), _ref3;
            });
            // Recurse into the subRows
            groupedRows = groupedRows.map(function (rowGroup) {
              var _extends2;

              var subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);
              return methods_extends({}, rowGroup, (_extends2 = {}, _defineProperty(_extends2, subRowsKey, subRows), _defineProperty(_extends2, aggregatedKey, true), _extends2), aggregate(subRows));
            });
            return groupedRows;
          };
          resolvedData = groupRecursively(resolvedData, pivotBy);
        }

        return methods_extends({}, newState, {
          resolvedData: resolvedData,
          allVisibleColumns: allVisibleColumns,
          headerGroups: headerGroups,
          allDecoratedColumns: allDecoratedColumns,
          hasHeaderGroups: hasHeaderGroups
        });
      }
    }, {
      key: 'getSortedData',
      value: function getSortedData(resolvedState) {
        var manual = resolvedState.manual,
            sorted = resolvedState.sorted,
            filtered = resolvedState.filtered,
            defaultFilterMethod = resolvedState.defaultFilterMethod,
            resolvedData = resolvedState.resolvedData,
            allDecoratedColumns = resolvedState.allDecoratedColumns;


        var sortMethodsByColumnID = {};

        allDecoratedColumns.filter(function (col) {
          return col.sortMethod;
        }).forEach(function (col) {
          sortMethodsByColumnID[col.id] = col.sortMethod;
        });

        // Resolve the data from either manual data or sorted data
        return {
          sortedData: manual ? resolvedData : this.sortData(this.filterData(resolvedData, filtered, defaultFilterMethod, allDecoratedColumns), sorted, sortMethodsByColumnID)
        };
      }
    }, {
      key: 'fireFetchData',
      value: function fireFetchData() {
        // determine the current state, preferring certain state values over props
        var currentState = methods_extends({}, this.getResolvedState(), {
          page: this.getStateOrProp('page'),
          pageSize: this.getStateOrProp('pageSize'),
          filtered: this.getStateOrProp('filtered')
        });

        this.props.onFetchData(currentState, this);
      }
    }, {
      key: 'getPropOrState',
      value: function getPropOrState(key) {
        return utils.getFirstDefined(this.props[key], this.state[key]);
      }
    }, {
      key: 'getStateOrProp',
      value: function getStateOrProp(key) {
        return utils.getFirstDefined(this.state[key], this.props[key]);
      }
    }, {
      key: 'filterData',
      value: function filterData(data, filtered, defaultFilterMethod, allVisibleColumns) {
        var _this3 = this;

        var filteredData = data;

        if (filtered.length) {
          filteredData = filtered.reduce(function (filteredSoFar, nextFilter) {
            var column = allVisibleColumns.find(function (x) {
              return x.id === nextFilter.id;
            });

            // Don't filter hidden columns or columns that have had their filters disabled
            if (!column || column.filterable === false) {
              return filteredSoFar;
            }

            var filterMethod = column.filterMethod || defaultFilterMethod;

            // If 'filterAll' is set to true, pass the entire dataset to the filter method
            if (column.filterAll) {
              return filterMethod(nextFilter, filteredSoFar, column);
            }
            return filteredSoFar.filter(function (row) {
              return filterMethod(nextFilter, row, column);
            });
          }, filteredData);

          // Apply the filter to the subrows if we are pivoting, and then
          // filter any rows without subcolumns because it would be strange to show
          filteredData = filteredData.map(function (row) {
            if (!row[_this3.props.subRowsKey]) {
              return row;
            }
            return methods_extends({}, row, _defineProperty({}, _this3.props.subRowsKey, _this3.filterData(row[_this3.props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns)));
          }).filter(function (row) {
            if (!row[_this3.props.subRowsKey]) {
              return true;
            }
            return row[_this3.props.subRowsKey].length > 0;
          });
        }

        return filteredData;
      }
    }, {
      key: 'sortData',
      value: function sortData(data, sorted) {
        var _this4 = this;

        var sortMethodsByColumnID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (!sorted.length) {
          return data;
        }

        var sortedData = (this.props.orderByMethod || utils.orderBy)(data, sorted.map(function (sort) {
          // Support custom sorting methods for each column
          if (sortMethodsByColumnID[sort.id]) {
            return function (a, b) {
              return sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);
            };
          }
          return function (a, b) {
            return _this4.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);
          };
        }), sorted.map(function (d) {
          return !d.desc;
        }), this.props.indexKey);

        sortedData.forEach(function (row) {
          if (!row[_this4.props.subRowsKey]) {
            return;
          }
          row[_this4.props.subRowsKey] = _this4.sortData(row[_this4.props.subRowsKey], sorted, sortMethodsByColumnID);
        });

        return sortedData;
      }
    }, {
      key: 'getMinRows',
      value: function getMinRows() {
        return utils.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'));
      }

      // User actions

    }, {
      key: 'onPageChange',
      value: function onPageChange(page) {
        var _props = this.props,
            onPageChange = _props.onPageChange,
            collapseOnPageChange = _props.collapseOnPageChange;


        var newState = { page: page };
        if (collapseOnPageChange) {
          newState.expanded = {};
        }
        this.setStateWithData(newState, function () {
          return onPageChange && onPageChange(page);
        });
      }
    }, {
      key: 'onPageSizeChange',
      value: function onPageSizeChange(newPageSize) {
        var onPageSizeChange = this.props.onPageSizeChange;

        var _getResolvedState = this.getResolvedState(),
            pageSize = _getResolvedState.pageSize,
            page = _getResolvedState.page;

        // Normalize the page to display


        var currentRow = pageSize * page;
        var newPage = Math.floor(currentRow / newPageSize);

        this.setStateWithData({
          pageSize: newPageSize,
          page: newPage
        }, function () {
          return onPageSizeChange && onPageSizeChange(newPageSize, newPage);
        });
      }
    }, {
      key: 'sortColumn',
      value: function sortColumn(column, additive) {
        var _getResolvedState2 = this.getResolvedState(),
            sorted = _getResolvedState2.sorted,
            skipNextSort = _getResolvedState2.skipNextSort,
            defaultSortDesc = _getResolvedState2.defaultSortDesc;

        var firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc') ? column.defaultSortDesc : defaultSortDesc;
        var secondSortDirection = !firstSortDirection;

        // we can't stop event propagation from the column resize move handlers
        // attached to the document because of react's synthetic events
        // so we have to prevent the sort function from actually sorting
        // if we click on the column resize element within a header.
        if (skipNextSort) {
          this.setStateWithData({
            skipNextSort: false
          });
          return;
        }

        var onSortedChange = this.props.onSortedChange;


        var newSorted = utils.clone(sorted || []).map(function (d) {
          d.desc = utils.isSortingDesc(d);
          return d;
        });
        if (!utils.isArray(column)) {
          // Single-Sort
          var existingIndex = newSorted.findIndex(function (d) {
            return d.id === column.id;
          });
          if (existingIndex > -1) {
            var existing = newSorted[existingIndex];
            if (existing.desc === secondSortDirection) {
              if (additive) {
                newSorted.splice(existingIndex, 1);
              } else {
                existing.desc = firstSortDirection;
                newSorted = [existing];
              }
            } else {
              existing.desc = secondSortDirection;
              if (!additive) {
                newSorted = [existing];
              }
            }
          } else if (additive) {
            newSorted.push({
              id: column.id,
              desc: firstSortDirection
            });
          } else {
            newSorted = [{
              id: column.id,
              desc: firstSortDirection
            }];
          }
        } else {
          // Multi-Sort
          var _existingIndex = newSorted.findIndex(function (d) {
            return d.id === column[0].id;
          });
          // Existing Sorted Column
          if (_existingIndex > -1) {
            var _existing = newSorted[_existingIndex];
            if (_existing.desc === secondSortDirection) {
              if (additive) {
                newSorted.splice(_existingIndex, column.length);
              } else {
                column.forEach(function (d, i) {
                  newSorted[_existingIndex + i].desc = firstSortDirection;
                });
              }
            } else {
              column.forEach(function (d, i) {
                newSorted[_existingIndex + i].desc = secondSortDirection;
              });
            }
            if (!additive) {
              newSorted = newSorted.slice(_existingIndex, column.length);
            }
            // New Sort Column
          } else if (additive) {
            newSorted = newSorted.concat(column.map(function (d) {
              return {
                id: d.id,
                desc: firstSortDirection
              };
            }));
          } else {
            newSorted = column.map(function (d) {
              return {
                id: d.id,
                desc: firstSortDirection
              };
            });
          }
        }

        this.setStateWithData({
          page: !sorted.length && newSorted.length || !additive ? 0 : this.state.page,
          sorted: newSorted
        }, function () {
          return onSortedChange && onSortedChange(newSorted, column, additive);
        });
      }
    }, {
      key: 'filterColumn',
      value: function filterColumn(column, value) {
        var _getResolvedState3 = this.getResolvedState(),
            filtered = _getResolvedState3.filtered;

        var onFilteredChange = this.props.onFilteredChange;

        // Remove old filter first if it exists

        var newFiltering = (filtered || []).filter(function (x) {
          return x.id !== column.id;
        });

        if (value !== '') {
          newFiltering.push({
            id: column.id,
            value: value
          });
        }

        this.setStateWithData({
          filtered: newFiltering
        }, function () {
          return onFilteredChange && onFilteredChange(newFiltering, column, value);
        });
      }
    }, {
      key: 'resizeColumnStart',
      value: function resizeColumnStart(event, column, isTouch) {
        var _this5 = this;

        event.stopPropagation();
        var parentWidth = event.target.parentElement.getBoundingClientRect().width;

        var pageX = void 0;
        if (isTouch) {
          pageX = event.changedTouches[0].pageX;
        } else {
          pageX = event.pageX;
        }

        this.trapEvents = true;
        this.setStateWithData({
          currentlyResizing: {
            id: column.id,
            startX: pageX,
            parentWidth: parentWidth
          }
        }, function () {
          if (isTouch) {
            document.addEventListener('touchmove', _this5.resizeColumnMoving);
            document.addEventListener('touchcancel', _this5.resizeColumnEnd);
            document.addEventListener('touchend', _this5.resizeColumnEnd);
          } else {
            document.addEventListener('mousemove', _this5.resizeColumnMoving);
            document.addEventListener('mouseup', _this5.resizeColumnEnd);
            document.addEventListener('mouseleave', _this5.resizeColumnEnd);
          }
        });
      }
    }, {
      key: 'resizeColumnMoving',
      value: function resizeColumnMoving(event) {
        event.stopPropagation();
        var _props2 = this.props,
            onResizedChange = _props2.onResizedChange,
            column = _props2.column;

        var _getResolvedState4 = this.getResolvedState(),
            resized = _getResolvedState4.resized,
            currentlyResizing = _getResolvedState4.currentlyResizing,
            columns = _getResolvedState4.columns;

        var currentColumn = columns.find(function (c) {
          return c.accessor === currentlyResizing.id || c.id === currentlyResizing.id;
        });
        var minResizeWidth = currentColumn && currentColumn.minResizeWidth != null ? currentColumn.minResizeWidth : column.minResizeWidth;

        // Delete old value
        var newResized = resized.filter(function (x) {
          return x.id !== currentlyResizing.id;
        });

        var pageX = void 0;

        if (event.type === 'touchmove') {
          pageX = event.changedTouches[0].pageX;
        } else if (event.type === 'mousemove') {
          pageX = event.pageX;
        }

        var newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, minResizeWidth);

        newResized.push({
          id: currentlyResizing.id,
          value: newWidth
        });

        this.setStateWithData({
          resized: newResized
        }, function () {
          return onResizedChange && onResizedChange(newResized, event);
        });
      }
    }, {
      key: 'resizeColumnEnd',
      value: function resizeColumnEnd(event) {
        event.stopPropagation();
        var isTouch = event.type === 'touchend' || event.type === 'touchcancel';

        if (isTouch) {
          document.removeEventListener('touchmove', this.resizeColumnMoving);
          document.removeEventListener('touchcancel', this.resizeColumnEnd);
          document.removeEventListener('touchend', this.resizeColumnEnd);
        }

        // If its a touch event clear the mouse one's as well because sometimes
        // the mouseDown event gets called as well, but the mouseUp event doesn't
        document.removeEventListener('mousemove', this.resizeColumnMoving);
        document.removeEventListener('mouseup', this.resizeColumnEnd);
        document.removeEventListener('mouseleave', this.resizeColumnEnd);

        // The touch events don't propagate up to the sorting's onMouseDown event so
        // no need to prevent it from happening or else the first click after a touch
        // event resize will not sort the column.
        if (!isTouch) {
          this.setStateWithData({
            skipNextSort: true,
            currentlyResizing: false
          });
        }
      }
    }]);

    return _class;
  }(Base);
});

// CONCATENATED MODULE: ./node_modules/react-table/es/pagination.js
var pagination_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var pagination_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function pagination_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pagination_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function pagination_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var pagination_defaultButton = function defaultButton(props) {
  return react_default.a.createElement(
    'button',
    pagination_extends({ type: 'button' }, props, { className: '-btn' }),
    props.children
  );
};

var pagination_ReactTablePagination = function (_Component) {
  pagination_inherits(ReactTablePagination, _Component);

  function ReactTablePagination(props) {
    pagination_classCallCheck(this, ReactTablePagination);

    var _this = pagination_possibleConstructorReturn(this, (ReactTablePagination.__proto__ || Object.getPrototypeOf(ReactTablePagination)).call(this, props));

    _this.getSafePage = _this.getSafePage.bind(_this);
    _this.changePage = _this.changePage.bind(_this);
    _this.applyPage = _this.applyPage.bind(_this);

    _this.state = {
      page: props.page
    };
    return _this;
  }

  pagination_createClass(ReactTablePagination, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevProps.page !== this.props.page && prevState.page !== this.state.page) {
        // this is probably safe because we only update when old/new state.page are different
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          page: this.props.page
        });
      }
    }
  }, {
    key: 'getSafePage',
    value: function getSafePage(page) {
      if (Number.isNaN(page)) {
        page = this.props.page;
      }
      return Math.min(Math.max(page, 0), this.props.pages - 1);
    }
  }, {
    key: 'changePage',
    value: function changePage(page) {
      page = this.getSafePage(page);
      this.setState({ page: page });
      if (this.props.page !== page) {
        this.props.onPageChange(page);
      }
    }
  }, {
    key: 'applyPage',
    value: function applyPage(e) {
      if (e) {
        e.preventDefault();
      }
      var page = this.state.page;
      this.changePage(page === '' ? this.props.page : page);
    }
  }, {
    key: 'getPageJumpProperties',
    value: function getPageJumpProperties() {
      var _this2 = this;

      return {
        onKeyPress: function onKeyPress(e) {
          if (e.which === 13 || e.keyCode === 13) {
            _this2.applyPage();
          }
        },
        onBlur: this.applyPage,
        value: this.state.page === '' ? '' : this.state.page + 1,
        onChange: function onChange(e) {
          var val = e.target.value;
          var page = val - 1;
          if (val === '') {
            return _this2.setState({ page: val });
          }
          _this2.setState({ page: _this2.getSafePage(page) });
        },
        inputType: this.state.page === '' ? 'text' : 'number',
        pageJumpText: this.props.pageJumpText
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          pages = _props.pages,
          page = _props.page,
          showPageSizeOptions = _props.showPageSizeOptions,
          pageSizeOptions = _props.pageSizeOptions,
          pageSize = _props.pageSize,
          showPageJump = _props.showPageJump,
          canPrevious = _props.canPrevious,
          canNext = _props.canNext,
          onPageSizeChange = _props.onPageSizeChange,
          className = _props.className,
          PreviousComponent = _props.PreviousComponent,
          NextComponent = _props.NextComponent,
          renderPageJump = _props.renderPageJump,
          renderCurrentPage = _props.renderCurrentPage,
          renderTotalPagesCount = _props.renderTotalPagesCount,
          renderPageSizeOptions = _props.renderPageSizeOptions;


      return react_default.a.createElement(
        'div',
        { className: classnames_default()(className, '-pagination'), style: this.props.style },
        react_default.a.createElement(
          'div',
          { className: '-previous' },
          react_default.a.createElement(
            PreviousComponent,
            {
              onClick: function onClick() {
                if (!canPrevious) return;
                _this3.changePage(page - 1);
              },
              disabled: !canPrevious
            },
            this.props.previousText
          )
        ),
        react_default.a.createElement(
          'div',
          { className: '-center' },
          react_default.a.createElement(
            'span',
            { className: '-pageInfo' },
            this.props.pageText,
            ' ',
            showPageJump ? renderPageJump(this.getPageJumpProperties()) : renderCurrentPage(page),
            ' ',
            this.props.ofText,
            ' ',
            renderTotalPagesCount(pages)
          ),
          showPageSizeOptions && renderPageSizeOptions({
            pageSize: pageSize,
            rowsSelectorText: this.props.rowsSelectorText,
            pageSizeOptions: pageSizeOptions,
            onPageSizeChange: onPageSizeChange,
            rowsText: this.props.rowsText
          })
        ),
        react_default.a.createElement(
          'div',
          { className: '-next' },
          react_default.a.createElement(
            NextComponent,
            {
              onClick: function onClick() {
                if (!canNext) return;
                _this3.changePage(page + 1);
              },
              disabled: !canNext
            },
            this.props.nextText
          )
        )
      );
    }
  }]);

  return ReactTablePagination;
}(react["Component"]);

pagination_ReactTablePagination.defaultProps = {
  PreviousComponent: pagination_defaultButton,
  NextComponent: pagination_defaultButton,
  renderPageJump: function renderPageJump(_ref) {
    var onChange = _ref.onChange,
        value = _ref.value,
        onBlur = _ref.onBlur,
        onKeyPress = _ref.onKeyPress,
        inputType = _ref.inputType,
        pageJumpText = _ref.pageJumpText;
    return react_default.a.createElement(
      'div',
      { className: '-pageJump' },
      react_default.a.createElement('input', {
        'aria-label': pageJumpText,
        type: inputType,
        onChange: onChange,
        value: value,
        onBlur: onBlur,
        onKeyPress: onKeyPress
      })
    );
  },
  renderCurrentPage: function renderCurrentPage(page) {
    return react_default.a.createElement(
      'span',
      { className: '-currentPage' },
      page + 1
    );
  },
  renderTotalPagesCount: function renderTotalPagesCount(pages) {
    return react_default.a.createElement(
      'span',
      { className: '-totalPages' },
      pages || 1
    );
  },
  renderPageSizeOptions: function renderPageSizeOptions(_ref2) {
    var pageSize = _ref2.pageSize,
        pageSizeOptions = _ref2.pageSizeOptions,
        rowsSelectorText = _ref2.rowsSelectorText,
        onPageSizeChange = _ref2.onPageSizeChange,
        rowsText = _ref2.rowsText;
    return react_default.a.createElement(
      'span',
      { className: 'select-wrap -pageSizeOptions' },
      react_default.a.createElement(
        'select',
        {
          'aria-label': rowsSelectorText,
          onChange: function onChange(e) {
            return onPageSizeChange(Number(e.target.value));
          },
          value: pageSize
        },
        pageSizeOptions.map(function (option, i) {
          return (
            // eslint-disable-next-line react/no-array-index-key
            react_default.a.createElement(
              'option',
              { key: i, value: option },
              option + ' ' + rowsText
            )
          );
        })
      )
    );
  }
};
/* harmony default export */ var pagination = (pagination_ReactTablePagination);

// CONCATENATED MODULE: ./node_modules/react-table/es/defaultProps.js
var defaultProps_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function defaultProps_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }



//



var emptyObj = function emptyObj() {
  return {};
};

/* harmony default export */ var defaultProps = ({
  // General
  data: [],
  resolveData: function resolveData(data) {
    return data;
  },
  loading: false,
  showPagination: true,
  showPaginationTop: false,
  showPaginationBottom: true,
  showPageSizeOptions: true,
  pageSizeOptions: [5, 10, 20, 25, 50, 100],
  defaultPage: 0,
  defaultPageSize: 20,
  showPageJump: true,
  collapseOnSortingChange: true,
  collapseOnPageChange: true,
  collapseOnDataChange: true,
  freezeWhenExpanded: false,
  sortable: true,
  multiSort: true,
  resizable: true,
  filterable: false,
  defaultSortDesc: false,
  defaultSorted: [],
  defaultFiltered: [],
  defaultResized: [],
  defaultExpanded: {},
  // eslint-disable-next-line no-unused-vars
  defaultFilterMethod: function defaultFilterMethod(filter, row, column) {
    var id = filter.pivotId || filter.id;
    return row[id] !== undefined ? String(row[id]).startsWith(filter.value) : true;
  },
  // eslint-disable-next-line no-unused-vars
  defaultSortMethod: function defaultSortMethod(a, b, desc) {
    // force null and undefined to the bottom
    a = a === null || a === undefined ? '' : a;
    b = b === null || b === undefined ? '' : b;
    // force any string values to lowercase
    a = typeof a === 'string' ? a.toLowerCase() : a;
    b = typeof b === 'string' ? b.toLowerCase() : b;
    // Return either 1 or -1 to indicate a sort priority
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    // returning 0, undefined or any falsey value will use subsequent sorts or
    // the index as a tiebreaker
    return 0;
  },

  // Controlled State Props
  // page: undefined,
  // pageSize: undefined,
  // sorted: [],
  // filtered: [],
  // resized: [],
  // expanded: {},

  // Controlled State Callbacks
  onPageChange: undefined,
  onPageSizeChange: undefined,
  onSortedChange: undefined,
  onFilteredChange: undefined,
  onResizedChange: undefined,
  onExpandedChange: undefined,

  // Pivoting
  pivotBy: undefined,

  // Key Constants
  pivotValKey: '_pivotVal',
  pivotIDKey: '_pivotID',
  subRowsKey: '_subRows',
  aggregatedKey: '_aggregated',
  nestingLevelKey: '_nestingLevel',
  originalKey: '_original',
  indexKey: '_index',
  groupedByPivotKey: '_groupedByPivot',

  // Server-side Callbacks
  onFetchData: function onFetchData() {
    return null;
  },

  // Classes
  className: '',
  style: {},

  // Component decorators
  getProps: emptyObj,
  getTableProps: emptyObj,
  getTheadGroupProps: emptyObj,
  getTheadGroupTrProps: emptyObj,
  getTheadGroupThProps: emptyObj,
  getTheadProps: emptyObj,
  getTheadTrProps: emptyObj,
  getTheadThProps: emptyObj,
  getTheadFilterProps: emptyObj,
  getTheadFilterTrProps: emptyObj,
  getTheadFilterThProps: emptyObj,
  getTbodyProps: emptyObj,
  getTrGroupProps: emptyObj,
  getTrProps: emptyObj,
  getTdProps: emptyObj,
  getTfootProps: emptyObj,
  getTfootTrProps: emptyObj,
  getTfootTdProps: emptyObj,
  getPaginationProps: emptyObj,
  getLoadingProps: emptyObj,
  getNoDataProps: emptyObj,
  getResizerProps: emptyObj,

  // Global Column Defaults
  column: {
    // Renderers
    Cell: undefined,
    Header: undefined,
    Footer: undefined,
    Aggregated: undefined,
    Pivot: undefined,
    PivotValue: undefined,
    Expander: undefined,
    Filter: undefined,
    Placeholder: undefined,
    // All Columns
    sortable: undefined, // use table default
    resizable: undefined, // use table default
    filterable: undefined, // use table default
    show: true,
    minWidth: 100,
    minResizeWidth: 11,
    // Cells only
    className: '',
    style: {},
    getProps: emptyObj,
    // Pivot only
    aggregate: undefined,
    // Headers only
    headerClassName: '',
    headerStyle: {},
    getHeaderProps: emptyObj,
    // Footers only
    footerClassName: '',
    footerStyle: {},
    getFooterProps: emptyObj,
    filterMethod: undefined,
    filterAll: false,
    sortMethod: undefined
  },

  // Global Expander Column Defaults
  expanderDefaults: {
    sortable: false,
    resizable: false,
    filterable: false,
    width: 35
  },

  pivotDefaults: {
    // extend the defaults for pivoted columns here
  },

  // Text
  previousText: 'Previous',
  nextText: 'Next',
  loadingText: 'Loading...',
  noDataText: 'No rows found',
  pageText: 'Page',
  ofText: 'of',
  rowsText: 'rows',
  pageJumpText: 'jump to page',
  rowsSelectorText: 'rows per page',

  // Components
  TableComponent: function TableComponent(_ref) {
    var children = _ref.children,
        className = _ref.className,
        rest = defaultProps_objectWithoutProperties(_ref, ['children', 'className']);

    return react_default.a.createElement(
      'div',
      defaultProps_extends({
        className: classnames_default()('rt-table', className),
        role: 'grid'
        // tabIndex='0'
      }, rest),
      children
    );
  },
  TheadComponent: utils.makeTemplateComponent('rt-thead', 'Thead'),
  TbodyComponent: utils.makeTemplateComponent('rt-tbody', 'Tbody'),
  TrGroupComponent: function TrGroupComponent(_ref2) {
    var children = _ref2.children,
        className = _ref2.className,
        rest = defaultProps_objectWithoutProperties(_ref2, ['children', 'className']);

    return react_default.a.createElement(
      'div',
      defaultProps_extends({ className: classnames_default()('rt-tr-group', className), role: 'rowgroup' }, rest),
      children
    );
  },
  TrComponent: function TrComponent(_ref3) {
    var children = _ref3.children,
        className = _ref3.className,
        rest = defaultProps_objectWithoutProperties(_ref3, ['children', 'className']);

    return react_default.a.createElement(
      'div',
      defaultProps_extends({ className: classnames_default()('rt-tr', className), role: 'row' }, rest),
      children
    );
  },
  ThComponent: function ThComponent(_ref4) {
    var toggleSort = _ref4.toggleSort,
        className = _ref4.className,
        children = _ref4.children,
        rest = defaultProps_objectWithoutProperties(_ref4, ['toggleSort', 'className', 'children']);

    return (
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events
      react_default.a.createElement(
        'div',
        defaultProps_extends({
          className: classnames_default()('rt-th', className),
          onClick: function onClick(e) {
            return toggleSort && toggleSort(e);
          },
          role: 'columnheader',
          tabIndex: '-1' // Resolves eslint issues without implementing keyboard navigation incorrectly
        }, rest),
        children
      )
    );
  },
  TdComponent: function TdComponent(_ref5) {
    var toggleSort = _ref5.toggleSort,
        className = _ref5.className,
        children = _ref5.children,
        rest = defaultProps_objectWithoutProperties(_ref5, ['toggleSort', 'className', 'children']);

    return react_default.a.createElement(
      'div',
      defaultProps_extends({ className: classnames_default()('rt-td', className), role: 'gridcell' }, rest),
      children
    );
  },
  TfootComponent: utils.makeTemplateComponent('rt-tfoot', 'Tfoot'),
  FilterComponent: function FilterComponent(_ref6) {
    var filter = _ref6.filter,
        _onChange = _ref6.onChange,
        column = _ref6.column;
    return react_default.a.createElement('input', {
      type: 'text',
      style: {
        width: '100%'
      },
      placeholder: column.Placeholder,
      value: filter ? filter.value : '',
      onChange: function onChange(event) {
        return _onChange(event.target.value);
      }
    });
  },
  ExpanderComponent: function ExpanderComponent(_ref7) {
    var isExpanded = _ref7.isExpanded;
    return react_default.a.createElement(
      'div',
      { className: classnames_default()('rt-expander', isExpanded && '-open') },
      '\u2022'
    );
  },
  PivotValueComponent: function PivotValueComponent(_ref8) {
    var subRows = _ref8.subRows,
        value = _ref8.value;
    return react_default.a.createElement(
      'span',
      null,
      value,
      ' ',
      subRows && '(' + subRows.length + ')'
    );
  },
  AggregatedComponent: function AggregatedComponent(_ref9) {
    var subRows = _ref9.subRows,
        column = _ref9.column;

    var previewValues = subRows.filter(function (d) {
      return typeof d[column.id] !== 'undefined';
    }).map(function (row, i) {
      return (
        // eslint-disable-next-line react/no-array-index-key
        react_default.a.createElement(
          'span',
          { key: i },
          row[column.id],
          i < subRows.length - 1 ? ', ' : ''
        )
      );
    });
    return react_default.a.createElement(
      'span',
      null,
      previewValues
    );
  },
  PivotComponent: undefined, // this is a computed default generated using
  // the ExpanderComponent and PivotValueComponent at run-time in methods.js
  PaginationComponent: pagination,
  PreviousComponent: undefined,
  NextComponent: undefined,
  LoadingComponent: function LoadingComponent(_ref10) {
    var className = _ref10.className,
        loading = _ref10.loading,
        loadingText = _ref10.loadingText,
        rest = defaultProps_objectWithoutProperties(_ref10, ['className', 'loading', 'loadingText']);

    return react_default.a.createElement(
      'div',
      defaultProps_extends({ className: classnames_default()('-loading', { '-active': loading }, className) }, rest),
      react_default.a.createElement(
        'div',
        { className: '-loading-inner' },
        loadingText
      )
    );
  },
  NoDataComponent: utils.makeTemplateComponent('rt-noData', 'NoData'),
  ResizerComponent: utils.makeTemplateComponent('rt-resizer', 'Resizer'),
  PadRowComponent: function PadRowComponent() {
    return react_default.a.createElement(
      'span',
      null,
      '\xA0'
    );
  }
});

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ./node_modules/react-table/es/propTypes.js


/* harmony default export */ var propTypes = ({
  // General
  data: prop_types_default.a.any,
  loading: prop_types_default.a.bool,
  showPagination: prop_types_default.a.bool,
  showPaginationTop: prop_types_default.a.bool,
  showPaginationBottom: prop_types_default.a.bool,
  showPageSizeOptions: prop_types_default.a.bool,
  pageSizeOptions: prop_types_default.a.array,
  defaultPageSize: prop_types_default.a.number,
  showPageJump: prop_types_default.a.bool,
  collapseOnSortingChange: prop_types_default.a.bool,
  collapseOnPageChange: prop_types_default.a.bool,
  collapseOnDataChange: prop_types_default.a.bool,
  freezeWhenExpanded: prop_types_default.a.bool,
  sortable: prop_types_default.a.bool,
  resizable: prop_types_default.a.bool,
  filterable: prop_types_default.a.bool,
  defaultSortDesc: prop_types_default.a.bool,
  defaultSorted: prop_types_default.a.array,
  defaultFiltered: prop_types_default.a.array,
  defaultResized: prop_types_default.a.array,
  defaultExpanded: prop_types_default.a.object,
  defaultFilterMethod: prop_types_default.a.func,
  defaultSortMethod: prop_types_default.a.func,

  // Controlled State Callbacks
  onPageChange: prop_types_default.a.func,
  onPageSizeChange: prop_types_default.a.func,
  onSortedChange: prop_types_default.a.func,
  onFilteredChange: prop_types_default.a.func,
  onResizedChange: prop_types_default.a.func,
  onExpandedChange: prop_types_default.a.func,

  // Pivoting
  pivotBy: prop_types_default.a.array,

  // Key Constants
  pivotValKey: prop_types_default.a.string,
  pivotIDKey: prop_types_default.a.string,
  subRowsKey: prop_types_default.a.string,
  aggregatedKey: prop_types_default.a.string,
  nestingLevelKey: prop_types_default.a.string,
  originalKey: prop_types_default.a.string,
  indexKey: prop_types_default.a.string,
  groupedByPivotKey: prop_types_default.a.string,

  // Server-side Callbacks
  onFetchData: prop_types_default.a.func,

  // Classes
  className: prop_types_default.a.string,
  style: prop_types_default.a.object,

  // Component decorators
  getProps: prop_types_default.a.func,
  getTableProps: prop_types_default.a.func,
  getTheadGroupProps: prop_types_default.a.func,
  getTheadGroupTrProps: prop_types_default.a.func,
  getTheadGroupThProps: prop_types_default.a.func,
  getTheadProps: prop_types_default.a.func,
  getTheadTrProps: prop_types_default.a.func,
  getTheadThProps: prop_types_default.a.func,
  getTheadFilterProps: prop_types_default.a.func,
  getTheadFilterTrProps: prop_types_default.a.func,
  getTheadFilterThProps: prop_types_default.a.func,
  getTbodyProps: prop_types_default.a.func,
  getTrGroupProps: prop_types_default.a.func,
  getTrProps: prop_types_default.a.func,
  getTdProps: prop_types_default.a.func,
  getTfootProps: prop_types_default.a.func,
  getTfootTrProps: prop_types_default.a.func,
  getTfootTdProps: prop_types_default.a.func,
  getPaginationProps: prop_types_default.a.func,
  getLoadingProps: prop_types_default.a.func,
  getNoDataProps: prop_types_default.a.func,
  getResizerProps: prop_types_default.a.func,

  // Global Column Defaults
  columns: prop_types_default.a.arrayOf(prop_types_default.a.shape({
    // Renderers
    Cell: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Header: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Footer: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Aggregated: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Pivot: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    PivotValue: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Expander: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.string, prop_types_default.a.elementType]),
    Filter: prop_types_default.a.oneOfType([prop_types_default.a.element, prop_types_default.a.elementType]),

    // All Columns
    sortable: prop_types_default.a.bool, // use table default
    resizable: prop_types_default.a.bool, // use table default
    filterable: prop_types_default.a.bool, // use table default
    show: prop_types_default.a.bool,
    minWidth: prop_types_default.a.number,
    minResizeWidth: prop_types_default.a.number,

    // Cells only
    className: prop_types_default.a.string,
    style: prop_types_default.a.object,
    getProps: prop_types_default.a.func,

    // Pivot only
    aggregate: prop_types_default.a.func,

    // Headers only
    headerClassName: prop_types_default.a.string,
    headerStyle: prop_types_default.a.object,
    getHeaderProps: prop_types_default.a.func,

    // Footers only
    footerClassName: prop_types_default.a.string,
    footerStyle: prop_types_default.a.object,
    getFooterProps: prop_types_default.a.func,
    filterMethod: prop_types_default.a.func,
    filterAll: prop_types_default.a.bool,
    sortMethod: prop_types_default.a.func
  })),

  // Global Expander Column Defaults
  expanderDefaults: prop_types_default.a.shape({
    sortable: prop_types_default.a.bool,
    resizable: prop_types_default.a.bool,
    filterable: prop_types_default.a.bool,
    width: prop_types_default.a.number
  }),

  pivotDefaults: prop_types_default.a.object,

  // Text
  previousText: prop_types_default.a.node,
  nextText: prop_types_default.a.node,
  loadingText: prop_types_default.a.node,
  noDataText: prop_types_default.a.node,
  pageText: prop_types_default.a.node,
  ofText: prop_types_default.a.node,
  rowsText: prop_types_default.a.node,
  pageJumpText: prop_types_default.a.node,
  rowsSelectorText: prop_types_default.a.node,

  // Components
  TableComponent: prop_types_default.a.elementType,
  TheadComponent: prop_types_default.a.elementType,
  TbodyComponent: prop_types_default.a.elementType,
  TrGroupComponent: prop_types_default.a.elementType,
  TrComponent: prop_types_default.a.elementType,
  ThComponent: prop_types_default.a.elementType,
  TdComponent: prop_types_default.a.elementType,
  TfootComponent: prop_types_default.a.elementType,
  FilterComponent: prop_types_default.a.elementType,
  ExpanderComponent: prop_types_default.a.elementType,
  PivotValueComponent: prop_types_default.a.elementType,
  AggregatedComponent: prop_types_default.a.elementType,
  // this is a computed default generated using
  PivotComponent: prop_types_default.a.elementType,
  // the ExpanderComponent and PivotValueComponent at run-time in methods.js
  PaginationComponent: prop_types_default.a.elementType,
  PreviousComponent: prop_types_default.a.elementType,
  NextComponent: prop_types_default.a.elementType,
  LoadingComponent: prop_types_default.a.elementType,
  NoDataComponent: prop_types_default.a.elementType,
  ResizerComponent: prop_types_default.a.elementType,
  PadRowComponent: prop_types_default.a.elementType
});

// CONCATENATED MODULE: ./node_modules/react-table/es/index.js
var es_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var es_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var es_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function es_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function es_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function es_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



//






var ReactTableDefaults = defaultProps;

var es_ReactTable = function (_Methods) {
  es_inherits(ReactTable, _Methods);

  function ReactTable(props) {
    es_classCallCheck(this, ReactTable);

    var _this = es_possibleConstructorReturn(this, (ReactTable.__proto__ || Object.getPrototypeOf(ReactTable)).call(this, props));

    _this.getResolvedState = _this.getResolvedState.bind(_this);
    _this.getDataModel = _this.getDataModel.bind(_this);
    _this.getSortedData = _this.getSortedData.bind(_this);
    _this.fireFetchData = _this.fireFetchData.bind(_this);
    _this.getPropOrState = _this.getPropOrState.bind(_this);
    _this.getStateOrProp = _this.getStateOrProp.bind(_this);
    _this.filterData = _this.filterData.bind(_this);
    _this.sortData = _this.sortData.bind(_this);
    _this.getMinRows = _this.getMinRows.bind(_this);
    _this.onPageChange = _this.onPageChange.bind(_this);
    _this.onPageSizeChange = _this.onPageSizeChange.bind(_this);
    _this.sortColumn = _this.sortColumn.bind(_this);
    _this.filterColumn = _this.filterColumn.bind(_this);
    _this.resizeColumnStart = _this.resizeColumnStart.bind(_this);
    _this.resizeColumnEnd = _this.resizeColumnEnd.bind(_this);
    _this.resizeColumnMoving = _this.resizeColumnMoving.bind(_this);
    return _this;
  }

  es_createClass(ReactTable, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var resolvedState = this.getResolvedState();
      var children = resolvedState.children,
          className = resolvedState.className,
          style = resolvedState.style,
          getProps = resolvedState.getProps,
          getTableProps = resolvedState.getTableProps,
          getTheadGroupProps = resolvedState.getTheadGroupProps,
          getTheadGroupTrProps = resolvedState.getTheadGroupTrProps,
          getTheadGroupThProps = resolvedState.getTheadGroupThProps,
          getTheadProps = resolvedState.getTheadProps,
          getTheadTrProps = resolvedState.getTheadTrProps,
          getTheadThProps = resolvedState.getTheadThProps,
          getTheadFilterProps = resolvedState.getTheadFilterProps,
          getTheadFilterTrProps = resolvedState.getTheadFilterTrProps,
          getTheadFilterThProps = resolvedState.getTheadFilterThProps,
          getTbodyProps = resolvedState.getTbodyProps,
          getTrGroupProps = resolvedState.getTrGroupProps,
          getTrProps = resolvedState.getTrProps,
          getTdProps = resolvedState.getTdProps,
          getTfootProps = resolvedState.getTfootProps,
          getTfootTrProps = resolvedState.getTfootTrProps,
          getTfootTdProps = resolvedState.getTfootTdProps,
          getPaginationProps = resolvedState.getPaginationProps,
          getLoadingProps = resolvedState.getLoadingProps,
          getNoDataProps = resolvedState.getNoDataProps,
          getResizerProps = resolvedState.getResizerProps,
          showPagination = resolvedState.showPagination,
          showPaginationTop = resolvedState.showPaginationTop,
          showPaginationBottom = resolvedState.showPaginationBottom,
          manual = resolvedState.manual,
          loadingText = resolvedState.loadingText,
          noDataText = resolvedState.noDataText,
          sortable = resolvedState.sortable,
          multiSort = resolvedState.multiSort,
          resizable = resolvedState.resizable,
          filterable = resolvedState.filterable,
          pivotIDKey = resolvedState.pivotIDKey,
          pivotValKey = resolvedState.pivotValKey,
          pivotBy = resolvedState.pivotBy,
          subRowsKey = resolvedState.subRowsKey,
          aggregatedKey = resolvedState.aggregatedKey,
          originalKey = resolvedState.originalKey,
          indexKey = resolvedState.indexKey,
          groupedByPivotKey = resolvedState.groupedByPivotKey,
          loading = resolvedState.loading,
          pageSize = resolvedState.pageSize,
          page = resolvedState.page,
          sorted = resolvedState.sorted,
          filtered = resolvedState.filtered,
          resized = resolvedState.resized,
          expanded = resolvedState.expanded,
          pages = resolvedState.pages,
          onExpandedChange = resolvedState.onExpandedChange,
          TableComponent = resolvedState.TableComponent,
          TheadComponent = resolvedState.TheadComponent,
          TbodyComponent = resolvedState.TbodyComponent,
          TrGroupComponent = resolvedState.TrGroupComponent,
          TrComponent = resolvedState.TrComponent,
          ThComponent = resolvedState.ThComponent,
          TdComponent = resolvedState.TdComponent,
          TfootComponent = resolvedState.TfootComponent,
          PaginationComponent = resolvedState.PaginationComponent,
          LoadingComponent = resolvedState.LoadingComponent,
          SubComponent = resolvedState.SubComponent,
          NoDataComponent = resolvedState.NoDataComponent,
          ResizerComponent = resolvedState.ResizerComponent,
          ExpanderComponent = resolvedState.ExpanderComponent,
          PivotValueComponent = resolvedState.PivotValueComponent,
          PivotComponent = resolvedState.PivotComponent,
          AggregatedComponent = resolvedState.AggregatedComponent,
          FilterComponent = resolvedState.FilterComponent,
          PadRowComponent = resolvedState.PadRowComponent,
          resolvedData = resolvedState.resolvedData,
          allVisibleColumns = resolvedState.allVisibleColumns,
          headerGroups = resolvedState.headerGroups,
          hasHeaderGroups = resolvedState.hasHeaderGroups,
          sortedData = resolvedState.sortedData,
          currentlyResizing = resolvedState.currentlyResizing;

      // Pagination

      var startRow = pageSize * page;
      var endRow = startRow + pageSize;
      var pageRows = manual ? resolvedData : sortedData.slice(startRow, endRow);
      var minRows = this.getMinRows();
      var padRows = utils.range(Math.max(minRows - pageRows.length, 0));

      var hasColumnFooter = allVisibleColumns.some(function (d) {
        return d.Footer;
      });
      var hasFilters = filterable || allVisibleColumns.some(function (d) {
        return d.filterable;
      });

      var recurseRowsViewIndex = function recurseRowsViewIndex(rows) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        return [rows.map(function (row, i) {
          index += 1;
          var rowWithViewIndex = es_extends({}, row, {
            _viewIndex: index
          });
          var newPath = path.concat([i]);
          if (rowWithViewIndex[subRowsKey] && utils.get(expanded, newPath)) {
            var _recurseRowsViewIndex = recurseRowsViewIndex(rowWithViewIndex[subRowsKey], newPath, index);

            var _recurseRowsViewIndex2 = es_slicedToArray(_recurseRowsViewIndex, 2);

            rowWithViewIndex[subRowsKey] = _recurseRowsViewIndex2[0];
            index = _recurseRowsViewIndex2[1];
          }
          return rowWithViewIndex;
        }), index];
      };

      var _recurseRowsViewIndex3 = recurseRowsViewIndex(pageRows);

      var _recurseRowsViewIndex4 = es_slicedToArray(_recurseRowsViewIndex3, 1);

      pageRows = _recurseRowsViewIndex4[0];


      var canPrevious = page > 0;
      var canNext = page + 1 < pages;

      var rowMinWidth = utils.sum(allVisibleColumns.map(function (d) {
        var resizedColumn = resized.find(function (x) {
          return x.id === d.id;
        }) || {};
        return utils.getFirstDefined(resizedColumn.value, d.width, d.minWidth);
      }));

      var rowIndex = -1;

      var finalState = es_extends({}, resolvedState, {
        startRow: startRow,
        endRow: endRow,
        pageRows: pageRows,
        minRows: minRows,
        padRows: padRows,
        hasColumnFooter: hasColumnFooter,
        canPrevious: canPrevious,
        canNext: canNext,
        rowMinWidth: rowMinWidth
      });

      var rootProps = utils.splitProps(getProps(finalState, undefined, undefined, this));
      var tableProps = utils.splitProps(getTableProps(finalState, undefined, undefined, this));
      var tBodyProps = utils.splitProps(getTbodyProps(finalState, undefined, undefined, this));
      var loadingProps = getLoadingProps(finalState, undefined, undefined, this);
      var noDataProps = getNoDataProps(finalState, undefined, undefined, this);

      // Visual Components

      var makeHeaderGroup = function makeHeaderGroup(column, i) {
        var resizedValue = function resizedValue(col) {
          return (resized.find(function (x) {
            return x.id === col.id;
          }) || {}).value;
        };
        var flex = utils.sum(column.columns.map(function (col) {
          return col.width || resizedValue(col) ? 0 : col.minWidth;
        }));
        var width = utils.sum(column.columns.map(function (col) {
          return utils.getFirstDefined(resizedValue(col), col.width, col.minWidth);
        }));
        var maxWidth = utils.sum(column.columns.map(function (col) {
          return utils.getFirstDefined(resizedValue(col), col.width, col.maxWidth);
        }));

        var theadGroupThProps = utils.splitProps(getTheadGroupThProps(finalState, undefined, column, _this2));
        var columnHeaderProps = utils.splitProps(column.getHeaderProps(finalState, undefined, column, _this2));

        var classes = [column.headerClassName, theadGroupThProps.className, columnHeaderProps.className];

        var styles = es_extends({}, column.headerStyle, theadGroupThProps.style, columnHeaderProps.style);

        var rest = es_extends({}, theadGroupThProps.rest, columnHeaderProps.rest);

        var flexStyles = {
          flex: flex + ' 0 auto',
          width: utils.asPx(width),
          maxWidth: utils.asPx(maxWidth)
        };

        return react_default.a.createElement(
          ThComponent,
          es_extends({
            key: i + '-' + column.id,
            className: classnames_default()(classes),
            style: es_extends({}, styles, flexStyles)
          }, rest),
          utils.normalizeComponent(column.Header, {
            data: sortedData,
            column: column
          })
        );
      };

      var makeHeaderGroups = function makeHeaderGroups() {
        var theadGroupProps = utils.splitProps(getTheadGroupProps(finalState, undefined, undefined, _this2));
        var theadGroupTrProps = utils.splitProps(getTheadGroupTrProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(
          TheadComponent,
          es_extends({
            className: classnames_default()('-headerGroups', theadGroupProps.className),
            style: es_extends({}, theadGroupProps.style, {
              minWidth: rowMinWidth + 'px'
            })
          }, theadGroupProps.rest),
          react_default.a.createElement(
            TrComponent,
            es_extends({
              className: theadGroupTrProps.className,
              style: theadGroupTrProps.style
            }, theadGroupTrProps.rest),
            headerGroups.map(makeHeaderGroup)
          )
        );
      };

      var makeHeader = function makeHeader(column, i) {
        var resizedCol = resized.find(function (x) {
          return x.id === column.id;
        }) || {};
        var sort = sorted.find(function (d) {
          return d.id === column.id;
        });
        var show = typeof column.show === 'function' ? column.show() : column.show;
        var width = utils.getFirstDefined(resizedCol.value, column.width, column.minWidth);
        var maxWidth = utils.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
        var theadThProps = utils.splitProps(getTheadThProps(finalState, undefined, column, _this2));
        var columnHeaderProps = utils.splitProps(column.getHeaderProps(finalState, undefined, column, _this2));

        var classes = [column.headerClassName, theadThProps.className, columnHeaderProps.className];

        var styles = es_extends({}, column.headerStyle, theadThProps.style, columnHeaderProps.style);

        var rest = es_extends({}, theadThProps.rest, columnHeaderProps.rest);

        var isResizable = utils.getFirstDefined(column.resizable, resizable, false);
        var resizer = isResizable ? react_default.a.createElement(ResizerComponent, es_extends({
          onMouseDown: function onMouseDown(e) {
            return _this2.resizeColumnStart(e, column, false);
          },
          onTouchStart: function onTouchStart(e) {
            return _this2.resizeColumnStart(e, column, true);
          }
        }, getResizerProps('finalState', undefined, column, _this2))) : null;

        var isSortable = utils.getFirstDefined(column.sortable, sortable, false);

        return react_default.a.createElement(
          ThComponent,
          es_extends({
            key: i + '-' + column.id,
            className: classnames_default()(classes, isResizable && 'rt-resizable-header', sort ? sort.desc ? '-sort-desc' : '-sort-asc' : '', isSortable && '-cursor-pointer', !show && '-hidden', pivotBy && pivotBy.slice(0, -1).includes(column.id) && 'rt-header-pivot'),
            style: es_extends({}, styles, {
              flex: width + ' 0 auto',
              width: utils.asPx(width),
              maxWidth: utils.asPx(maxWidth)
            }),
            toggleSort: function toggleSort(e) {
              if (isSortable) _this2.sortColumn(column, multiSort ? e.shiftKey : false);
            }
          }, rest),
          react_default.a.createElement(
            'div',
            { className: classnames_default()(isResizable && 'rt-resizable-header-content') },
            utils.normalizeComponent(column.Header, {
              data: sortedData,
              column: column
            })
          ),
          resizer
        );
      };

      var makeHeaders = function makeHeaders() {
        var theadProps = utils.splitProps(getTheadProps(finalState, undefined, undefined, _this2));
        var theadTrProps = utils.splitProps(getTheadTrProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(
          TheadComponent,
          es_extends({
            className: classnames_default()('-header', theadProps.className),
            style: es_extends({}, theadProps.style, {
              minWidth: rowMinWidth + 'px'
            })
          }, theadProps.rest),
          react_default.a.createElement(
            TrComponent,
            es_extends({
              className: theadTrProps.className,
              style: theadTrProps.style
            }, theadTrProps.rest),
            allVisibleColumns.map(makeHeader)
          )
        );
      };

      var makeFilter = function makeFilter(column, i) {
        var resizedCol = resized.find(function (x) {
          return x.id === column.id;
        }) || {};
        var width = utils.getFirstDefined(resizedCol.value, column.width, column.minWidth);
        var maxWidth = utils.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
        var theadFilterThProps = utils.splitProps(getTheadFilterThProps(finalState, undefined, column, _this2));
        var columnHeaderProps = utils.splitProps(column.getHeaderProps(finalState, undefined, column, _this2));

        var classes = [column.headerClassName, theadFilterThProps.className, columnHeaderProps.className];

        var styles = es_extends({}, column.headerStyle, theadFilterThProps.style, columnHeaderProps.style);

        var rest = es_extends({}, theadFilterThProps.rest, columnHeaderProps.rest);

        var filter = filtered.find(function (filter) {
          return filter.id === column.id;
        });

        var ResolvedFilterComponent = column.Filter || FilterComponent;

        var isFilterable = utils.getFirstDefined(column.filterable, filterable, false);

        return react_default.a.createElement(
          ThComponent,
          es_extends({
            key: i + '-' + column.id,
            className: classnames_default()(classes),
            style: es_extends({}, styles, {
              flex: width + ' 0 auto',
              width: utils.asPx(width),
              maxWidth: utils.asPx(maxWidth)
            })
          }, rest),
          isFilterable ? utils.normalizeComponent(ResolvedFilterComponent, {
            column: column,
            filter: filter,
            onChange: function onChange(value) {
              return _this2.filterColumn(column, value);
            }
          }, defaultProps.column.Filter) : null
        );
      };

      var makeFilters = function makeFilters() {
        var theadFilterProps = utils.splitProps(getTheadFilterProps(finalState, undefined, undefined, _this2));
        var theadFilterTrProps = utils.splitProps(getTheadFilterTrProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(
          TheadComponent,
          es_extends({
            className: classnames_default()('-filters', theadFilterProps.className),
            style: es_extends({}, theadFilterProps.style, {
              minWidth: rowMinWidth + 'px'
            })
          }, theadFilterProps.rest),
          react_default.a.createElement(
            TrComponent,
            es_extends({
              className: theadFilterTrProps.className,
              style: theadFilterTrProps.style
            }, theadFilterTrProps.rest),
            allVisibleColumns.map(makeFilter)
          )
        );
      };

      var makePageRow = function makePageRow(row, i) {
        var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        var rowInfo = {
          original: row[originalKey],
          row: row,
          index: row[indexKey],
          viewIndex: rowIndex += 1,
          pageSize: pageSize,
          page: page,
          level: path.length,
          nestingPath: path.concat([i]),
          aggregated: row[aggregatedKey],
          groupedByPivot: row[groupedByPivotKey],
          subRows: row[subRowsKey]
        };
        var isExpanded = utils.get(expanded, rowInfo.nestingPath);
        var trGroupProps = getTrGroupProps(finalState, rowInfo, undefined, _this2);
        var trProps = utils.splitProps(getTrProps(finalState, rowInfo, undefined, _this2));
        return react_default.a.createElement(
          TrGroupComponent,
          es_extends({ key: rowInfo.nestingPath.join('_') }, trGroupProps),
          react_default.a.createElement(
            TrComponent,
            es_extends({
              className: classnames_default()(trProps.className, row._viewIndex % 2 ? '-even' : '-odd'),
              style: trProps.style
            }, trProps.rest),
            allVisibleColumns.map(function (column, i2) {
              var resizedCol = resized.find(function (x) {
                return x.id === column.id;
              }) || {};
              var show = typeof column.show === 'function' ? column.show() : column.show;
              var width = utils.getFirstDefined(resizedCol.value, column.width, column.minWidth);
              var maxWidth = utils.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
              var tdProps = utils.splitProps(getTdProps(finalState, rowInfo, column, _this2));
              var columnProps = utils.splitProps(column.getProps(finalState, rowInfo, column, _this2));

              var classes = [tdProps.className, column.className, columnProps.className];

              var styles = es_extends({}, tdProps.style, column.style, columnProps.style);

              var cellInfo = es_extends({}, rowInfo, {
                isExpanded: isExpanded,
                column: es_extends({}, column),
                value: rowInfo.row[column.id],
                pivoted: column.pivoted,
                expander: column.expander,
                resized: resized,
                show: show,
                width: width,
                maxWidth: maxWidth,
                tdProps: tdProps,
                columnProps: columnProps,
                classes: classes,
                styles: styles
              });

              var value = cellInfo.value;

              var useOnExpanderClick = void 0;
              var isBranch = void 0;
              var isPreview = void 0;

              var onExpanderClick = function onExpanderClick(e) {
                var newExpanded = utils.clone(expanded);
                if (isExpanded) {
                  newExpanded = utils.set(newExpanded, cellInfo.nestingPath, false);
                } else {
                  newExpanded = utils.set(newExpanded, cellInfo.nestingPath, {});
                }

                return _this2.setStateWithData({
                  expanded: newExpanded
                }, function () {
                  return onExpandedChange && onExpandedChange(newExpanded, cellInfo.nestingPath, e, cellInfo);
                });
              };

              // Default to a standard cell
              var resolvedCell = utils.normalizeComponent(column.Cell, cellInfo, value);

              // Resolve Renderers
              var ResolvedAggregatedComponent = column.Aggregated || (!column.aggregate ? AggregatedComponent : column.Cell);
              var ResolvedExpanderComponent = column.Expander || ExpanderComponent;
              var ResolvedPivotValueComponent = column.PivotValue || PivotValueComponent;
              var DefaultResolvedPivotComponent = PivotComponent || function (props) {
                return react_default.a.createElement(
                  'div',
                  null,
                  react_default.a.createElement(ResolvedExpanderComponent, props),
                  react_default.a.createElement(ResolvedPivotValueComponent, props)
                );
              };
              var ResolvedPivotComponent = column.Pivot || DefaultResolvedPivotComponent;

              // Is this cell expandable?
              if (cellInfo.pivoted || cellInfo.expander) {
                // Make it expandable by defualt
                cellInfo.expandable = true;
                useOnExpanderClick = true;
                // If pivoted, has no subRows, and does not have a subComponent,
                // do not make expandable
                if (cellInfo.pivoted && !cellInfo.subRows && !SubComponent) {
                  cellInfo.expandable = false;
                }
              }

              if (cellInfo.pivoted) {
                // Is this column a branch?
                isBranch = rowInfo.row[pivotIDKey] === column.id && cellInfo.subRows;
                // Should this column be blank?
                isPreview = pivotBy.indexOf(column.id) > pivotBy.indexOf(rowInfo.row[pivotIDKey]) && cellInfo.subRows;
                // Pivot Cell Render Override
                if (isBranch) {
                  // isPivot
                  resolvedCell = utils.normalizeComponent(ResolvedPivotComponent, es_extends({}, cellInfo, {
                    value: row[pivotValKey]
                  }), row[pivotValKey]);
                } else if (isPreview) {
                  // Show the pivot preview
                  resolvedCell = utils.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                } else {
                  resolvedCell = null;
                }
              } else if (cellInfo.aggregated) {
                resolvedCell = utils.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
              }

              if (cellInfo.expander) {
                resolvedCell = utils.normalizeComponent(ResolvedExpanderComponent, cellInfo, row[pivotValKey]);
                if (pivotBy) {
                  if (cellInfo.groupedByPivot) {
                    resolvedCell = null;
                  }
                  if (!cellInfo.subRows && !SubComponent) {
                    resolvedCell = null;
                  }
                }
              }

              var resolvedOnExpanderClick = useOnExpanderClick ? onExpanderClick : function () {};

              // If there are multiple onClick events, make sure they don't
              // override eachother. This should maybe be expanded to handle all
              // function attributes
              var interactionProps = {
                onClick: resolvedOnExpanderClick
              };

              if (tdProps.rest.onClick) {
                interactionProps.onClick = function (e) {
                  tdProps.rest.onClick(e, function () {
                    return resolvedOnExpanderClick(e);
                  });
                };
              }

              if (columnProps.rest.onClick) {
                interactionProps.onClick = function (e) {
                  columnProps.rest.onClick(e, function () {
                    return resolvedOnExpanderClick(e);
                  });
                };
              }

              // Return the cell
              return react_default.a.createElement(
                TdComponent
                // eslint-disable-next-line react/no-array-index-key
                ,
                es_extends({ key: i2 + '-' + column.id,
                  className: classnames_default()(classes, !cellInfo.expandable && !show && 'hidden', cellInfo.expandable && 'rt-expandable', (isBranch || isPreview) && 'rt-pivot'),
                  style: es_extends({}, styles, {
                    flex: width + ' 0 auto',
                    width: utils.asPx(width),
                    maxWidth: utils.asPx(maxWidth)
                  })
                }, tdProps.rest, columnProps.rest, interactionProps),
                resolvedCell
              );
            })
          ),
          rowInfo.subRows && isExpanded && rowInfo.subRows.map(function (d, i) {
            return makePageRow(d, i, rowInfo.nestingPath);
          }),
          SubComponent && !rowInfo.subRows && isExpanded && SubComponent(rowInfo, function () {
            var newExpanded = utils.clone(expanded);

            utils.set(newExpanded, rowInfo.nestingPath, false);
          })
        );
      };

      var makePadColumn = function makePadColumn(column, i) {
        var resizedCol = resized.find(function (x) {
          return x.id === column.id;
        }) || {};
        var show = typeof column.show === 'function' ? column.show() : column.show;
        var width = utils.getFirstDefined(resizedCol.value, column.width, column.minWidth);
        var flex = width;
        var maxWidth = utils.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
        var tdProps = utils.splitProps(getTdProps(finalState, undefined, column, _this2));
        var columnProps = utils.splitProps(column.getProps(finalState, undefined, column, _this2));

        var classes = [tdProps.className, column.className, columnProps.className];

        var styles = es_extends({}, tdProps.style, column.style, columnProps.style);

        return react_default.a.createElement(
          TdComponent,
          es_extends({
            key: i + '-' + column.id,
            className: classnames_default()(classes, !show && 'hidden'),
            style: es_extends({}, styles, {
              flex: flex + ' 0 auto',
              width: utils.asPx(width),
              maxWidth: utils.asPx(maxWidth)
            })
          }, tdProps.rest),
          utils.normalizeComponent(PadRowComponent)
        );
      };

      var makePadRow = function makePadRow(row, i) {
        var trGroupProps = getTrGroupProps(finalState, undefined, undefined, _this2);
        var trProps = utils.splitProps(getTrProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(
          TrGroupComponent,
          es_extends({ key: 'pad-' + i }, trGroupProps),
          react_default.a.createElement(
            TrComponent,
            {
              className: classnames_default()('-padRow', (pageRows.length + i) % 2 ? '-even' : '-odd', trProps.className),
              style: trProps.style || {}
            },
            allVisibleColumns.map(makePadColumn)
          )
        );
      };

      var makeColumnFooter = function makeColumnFooter(column, i) {
        var resizedCol = resized.find(function (x) {
          return x.id === column.id;
        }) || {};
        var show = typeof column.show === 'function' ? column.show() : column.show;
        var width = utils.getFirstDefined(resizedCol.value, column.width, column.minWidth);
        var maxWidth = utils.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
        var tFootTdProps = utils.splitProps(getTfootTdProps(finalState, undefined, column, _this2));
        var columnProps = utils.splitProps(column.getProps(finalState, undefined, column, _this2));
        var columnFooterProps = utils.splitProps(column.getFooterProps(finalState, undefined, column, _this2));

        var classes = [tFootTdProps.className, column.className, columnProps.className, columnFooterProps.className];

        var styles = es_extends({}, tFootTdProps.style, column.style, columnProps.style, columnFooterProps.style);

        return react_default.a.createElement(
          TdComponent,
          es_extends({
            key: i + '-' + column.id,
            className: classnames_default()(classes, !show && 'hidden'),
            style: es_extends({}, styles, {
              flex: width + ' 0 auto',
              width: utils.asPx(width),
              maxWidth: utils.asPx(maxWidth)
            })
          }, columnProps.rest, tFootTdProps.rest, columnFooterProps.rest),
          utils.normalizeComponent(column.Footer, {
            data: sortedData,
            column: column
          })
        );
      };

      var makeColumnFooters = function makeColumnFooters() {
        var tFootProps = utils.splitProps(getTfootProps(finalState, undefined, undefined, _this2));
        var tFootTrProps = utils.splitProps(getTfootTrProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(
          TfootComponent,
          es_extends({
            className: tFootProps.className,
            style: es_extends({}, tFootProps.style, {
              minWidth: rowMinWidth + 'px'
            })
          }, tFootProps.rest),
          react_default.a.createElement(
            TrComponent,
            es_extends({
              className: classnames_default()(tFootTrProps.className),
              style: tFootTrProps.style
            }, tFootTrProps.rest),
            allVisibleColumns.map(makeColumnFooter)
          )
        );
      };

      var makePagination = function makePagination(isTop) {
        var paginationProps = utils.splitProps(getPaginationProps(finalState, undefined, undefined, _this2));
        return react_default.a.createElement(PaginationComponent, es_extends({}, resolvedState, {
          pages: pages,
          canPrevious: canPrevious,
          canNext: canNext,
          onPageChange: _this2.onPageChange,
          onPageSizeChange: _this2.onPageSizeChange,
          className: paginationProps.className,
          style: paginationProps.style,
          isTop: isTop
        }, paginationProps.rest));
      };

      var makeTable = function makeTable() {
        return react_default.a.createElement(
          'div',
          es_extends({
            className: classnames_default()('ReactTable', className, rootProps.className),
            style: es_extends({}, style, rootProps.style)
          }, rootProps.rest),
          showPagination && showPaginationTop ? react_default.a.createElement(
            'div',
            { className: 'pagination-top' },
            makePagination(true)
          ) : null,
          react_default.a.createElement(
            TableComponent,
            es_extends({
              className: classnames_default()(tableProps.className, currentlyResizing ? 'rt-resizing' : ''),
              style: tableProps.style
            }, tableProps.rest),
            hasHeaderGroups ? makeHeaderGroups() : null,
            makeHeaders(),
            hasFilters ? makeFilters() : null,
            react_default.a.createElement(
              TbodyComponent,
              es_extends({
                className: classnames_default()(tBodyProps.className),
                style: es_extends({}, tBodyProps.style, {
                  minWidth: rowMinWidth + 'px'
                })
              }, tBodyProps.rest),
              pageRows.map(function (d, i) {
                return makePageRow(d, i);
              }),
              padRows.map(makePadRow)
            ),
            hasColumnFooter ? makeColumnFooters() : null
          ),
          showPagination && showPaginationBottom ? react_default.a.createElement(
            'div',
            { className: 'pagination-bottom' },
            makePagination(false)
          ) : null,
          !pageRows.length && react_default.a.createElement(
            NoDataComponent,
            noDataProps,
            utils.normalizeComponent(noDataText)
          ),
          react_default.a.createElement(LoadingComponent, es_extends({ loading: loading, loadingText: loadingText }, loadingProps))
        );
      };

      // childProps are optionally passed to a function-as-a-child
      return children ? children(finalState, makeTable, this) : makeTable();
    }
  }]);

  return ReactTable;
}(methods(lifecycle(react["Component"])));

es_ReactTable.propTypes = propTypes;
es_ReactTable.defaultProps = defaultProps;
/* harmony default export */ var es = __webpack_exports__["default"] = (es_ReactTable);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ interpolateTransformCss; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ interpolateTransformSvg; });

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/number.js
var number = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ var decompose = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/parse.js


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(number["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(number["a" /* default */])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(number["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(number["a" /* default */])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(number["a" /* default */])(xa, xb)}, {i: i - 2, x: Object(number["a" /* default */])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

!function(e){ true?module.exports=e(null):undefined}(function e(a){"use strict";var r=/^\0+/g,c=/[\0\r\f]/g,s=/: */g,t=/zoo|gra/,i=/([,: ])(transform)/g,f=/,+\s*(?![^(]*[)])/g,n=/ +\s*(?![^(]*[)])/g,l=/ *[\0] */g,o=/,\r+?/g,h=/([\t\r\n ])*\f?&/g,u=/:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g,d=/\W+/g,b=/@(k\w+)\s*(\S*)\s*/,p=/::(place)/g,k=/:(read-only)/g,g=/\s+(?=[{\];=:>])/g,A=/([[}=:>])\s+/g,C=/(\{[^{]+?);(?=\})/g,w=/\s{2,}/g,v=/([^\(])(:+) */g,m=/[svh]\w+-[tblr]{2}/,x=/\(\s*(.*)\s*\)/g,$=/([\s\S]*?);/g,y=/-self|flex-/g,O=/[^]*?(:[rp][el]a[\w-]+)[^]*/,j=/stretch|:\s*\w+\-(?:conte|avail)/,z=/([^-])(image-set\()/,N="-webkit-",S="-moz-",F="-ms-",W=59,q=125,B=123,D=40,E=41,G=91,H=93,I=10,J=13,K=9,L=64,M=32,P=38,Q=45,R=95,T=42,U=44,V=58,X=39,Y=34,Z=47,_=62,ee=43,ae=126,re=0,ce=12,se=11,te=107,ie=109,fe=115,ne=112,le=111,oe=105,he=99,ue=100,de=112,be=1,pe=1,ke=0,ge=1,Ae=1,Ce=1,we=0,ve=0,me=0,xe=[],$e=[],ye=0,Oe=null,je=-2,ze=-1,Ne=0,Se=1,Fe=2,We=3,qe=0,Be=1,De="",Ee="",Ge="";function He(e,a,s,t,i){for(var f,n,o=0,h=0,u=0,d=0,g=0,A=0,C=0,w=0,m=0,$=0,y=0,O=0,j=0,z=0,R=0,we=0,$e=0,Oe=0,je=0,ze=s.length,Je=ze-1,Re="",Te="",Ue="",Ve="",Xe="",Ye="";R<ze;){if(C=s.charCodeAt(R),R===Je)if(h+d+u+o!==0){if(0!==h)C=h===Z?I:Z;d=u=o=0,ze++,Je++}if(h+d+u+o===0){if(R===Je){if(we>0)Te=Te.replace(c,"");if(Te.trim().length>0){switch(C){case M:case K:case W:case J:case I:break;default:Te+=s.charAt(R)}C=W}}if(1===$e)switch(C){case B:case q:case W:case Y:case X:case D:case E:case U:$e=0;case K:case J:case I:case M:break;default:for($e=0,je=R,g=C,R--,C=W;je<ze;)switch(s.charCodeAt(je++)){case I:case J:case W:++R,C=g,je=ze;break;case V:if(we>0)++R,C=g;case B:je=ze}}switch(C){case B:for(g=(Te=Te.trim()).charCodeAt(0),y=1,je=++R;R<ze;){switch(C=s.charCodeAt(R)){case B:y++;break;case q:y--;break;case Z:switch(A=s.charCodeAt(R+1)){case T:case Z:R=Qe(A,R,Je,s)}break;case G:C++;case D:C++;case Y:case X:for(;R++<Je&&s.charCodeAt(R)!==C;);}if(0===y)break;R++}if(Ue=s.substring(je,R),g===re)g=(Te=Te.replace(r,"").trim()).charCodeAt(0);switch(g){case L:if(we>0)Te=Te.replace(c,"");switch(A=Te.charCodeAt(1)){case ue:case ie:case fe:case Q:f=a;break;default:f=xe}if(je=(Ue=He(a,f,Ue,A,i+1)).length,me>0&&0===je)je=Te.length;if(ye>0)if(f=Ie(xe,Te,Oe),n=Pe(We,Ue,f,a,pe,be,je,A,i,t),Te=f.join(""),void 0!==n)if(0===(je=(Ue=n.trim()).length))A=0,Ue="";if(je>0)switch(A){case fe:Te=Te.replace(x,Me);case ue:case ie:case Q:Ue=Te+"{"+Ue+"}";break;case te:if(Ue=(Te=Te.replace(b,"$1 $2"+(Be>0?De:"")))+"{"+Ue+"}",1===Ae||2===Ae&&Le("@"+Ue,3))Ue="@"+N+Ue+"@"+Ue;else Ue="@"+Ue;break;default:if(Ue=Te+Ue,t===de)Ve+=Ue,Ue=""}else Ue="";break;default:Ue=He(a,Ie(a,Te,Oe),Ue,t,i+1)}Xe+=Ue,O=0,$e=0,z=0,we=0,Oe=0,j=0,Te="",Ue="",C=s.charCodeAt(++R);break;case q:case W:if((je=(Te=(we>0?Te.replace(c,""):Te).trim()).length)>1){if(0===z)if((g=Te.charCodeAt(0))===Q||g>96&&g<123)je=(Te=Te.replace(" ",":")).length;if(ye>0)if(void 0!==(n=Pe(Se,Te,a,e,pe,be,Ve.length,t,i,t)))if(0===(je=(Te=n.trim()).length))Te="\0\0";switch(g=Te.charCodeAt(0),A=Te.charCodeAt(1),g){case re:break;case L:if(A===oe||A===he){Ye+=Te+s.charAt(R);break}default:if(Te.charCodeAt(je-1)===V)break;Ve+=Ke(Te,g,A,Te.charCodeAt(2))}}O=0,$e=0,z=0,we=0,Oe=0,Te="",C=s.charCodeAt(++R)}}switch(C){case J:case I:if(h+d+u+o+ve===0)switch($){case E:case X:case Y:case L:case ae:case _:case T:case ee:case Z:case Q:case V:case U:case W:case B:case q:break;default:if(z>0)$e=1}if(h===Z)h=0;else if(ge+O===0&&t!==te&&Te.length>0)we=1,Te+="\0";if(ye*qe>0)Pe(Ne,Te,a,e,pe,be,Ve.length,t,i,t);be=1,pe++;break;case W:case q:if(h+d+u+o===0){be++;break}default:switch(be++,Re=s.charAt(R),C){case K:case M:if(d+o+h===0)switch(w){case U:case V:case K:case M:Re="";break;default:if(C!==M)Re=" "}break;case re:Re="\\0";break;case ce:Re="\\f";break;case se:Re="\\v";break;case P:if(d+h+o===0&&ge>0)Oe=1,we=1,Re="\f"+Re;break;case 108:if(d+h+o+ke===0&&z>0)switch(R-z){case 2:if(w===ne&&s.charCodeAt(R-3)===V)ke=w;case 8:if(m===le)ke=m}break;case V:if(d+h+o===0)z=R;break;case U:if(h+u+d+o===0)we=1,Re+="\r";break;case Y:case X:if(0===h)d=d===C?0:0===d?C:d;break;case G:if(d+h+u===0)o++;break;case H:if(d+h+u===0)o--;break;case E:if(d+h+o===0)u--;break;case D:if(d+h+o===0){if(0===O)switch(2*w+3*m){case 533:break;default:y=0,O=1}u++}break;case L:if(h+u+d+o+z+j===0)j=1;break;case T:case Z:if(d+o+u>0)break;switch(h){case 0:switch(2*C+3*s.charCodeAt(R+1)){case 235:h=Z;break;case 220:je=R,h=T}break;case T:if(C===Z&&w===T&&je+2!==R){if(33===s.charCodeAt(je+2))Ve+=s.substring(je,R+1);Re="",h=0}}}if(0===h){if(ge+d+o+j===0&&t!==te&&C!==W)switch(C){case U:case ae:case _:case ee:case E:case D:if(0===O){switch(w){case K:case M:case I:case J:Re+="\0";break;default:Re="\0"+Re+(C===U?"":"\0")}we=1}else switch(C){case D:if(z+7===R&&108===w)z=0;O=++y;break;case E:if(0==(O=--y))we=1,Re+="\0"}break;case K:case M:switch(w){case re:case B:case q:case W:case U:case ce:case K:case M:case I:case J:break;default:if(0===O)we=1,Re+="\0"}}if(Te+=Re,C!==M&&C!==K)$=C}}m=w,w=C,R++}if(je=Ve.length,me>0)if(0===je&&0===Xe.length&&0===a[0].length==false)if(t!==ie||1===a.length&&(ge>0?Ee:Ge)===a[0])je=a.join(",").length+2;if(je>0){if(f=0===ge&&t!==te?function(e){for(var a,r,s=0,t=e.length,i=Array(t);s<t;++s){for(var f=e[s].split(l),n="",o=0,h=0,u=0,d=0,b=f.length;o<b;++o){if(0===(h=(r=f[o]).length)&&b>1)continue;if(u=n.charCodeAt(n.length-1),d=r.charCodeAt(0),a="",0!==o)switch(u){case T:case ae:case _:case ee:case M:case D:break;default:a=" "}switch(d){case P:r=a+Ee;case ae:case _:case ee:case M:case E:case D:break;case G:r=a+r+Ee;break;case V:switch(2*r.charCodeAt(1)+3*r.charCodeAt(2)){case 530:if(Ce>0){r=a+r.substring(8,h-1);break}default:if(o<1||f[o-1].length<1)r=a+Ee+r}break;case U:a="";default:if(h>1&&r.indexOf(":")>0)r=a+r.replace(v,"$1"+Ee+"$2");else r=a+r+Ee}n+=r}i[s]=n.replace(c,"").trim()}return i}(a):a,ye>0)if(void 0!==(n=Pe(Fe,Ve,f,e,pe,be,je,t,i,t))&&0===(Ve=n).length)return Ye+Ve+Xe;if(Ve=f.join(",")+"{"+Ve+"}",Ae*ke!=0){if(2===Ae&&!Le(Ve,2))ke=0;switch(ke){case le:Ve=Ve.replace(k,":"+S+"$1")+Ve;break;case ne:Ve=Ve.replace(p,"::"+N+"input-$1")+Ve.replace(p,"::"+S+"$1")+Ve.replace(p,":"+F+"input-$1")+Ve}ke=0}}return Ye+Ve+Xe}function Ie(e,a,r){var c=a.trim().split(o),s=c,t=c.length,i=e.length;switch(i){case 0:case 1:for(var f=0,n=0===i?"":e[0]+" ";f<t;++f)s[f]=Je(n,s[f],r,i).trim();break;default:f=0;var l=0;for(s=[];f<t;++f)for(var h=0;h<i;++h)s[l++]=Je(e[h]+" ",c[f],r,i).trim()}return s}function Je(e,a,r,c){var s=a,t=s.charCodeAt(0);if(t<33)t=(s=s.trim()).charCodeAt(0);switch(t){case P:switch(ge+c){case 0:case 1:if(0===e.trim().length)break;default:return s.replace(h,"$1"+e.trim())}break;case V:switch(s.charCodeAt(1)){case 103:if(Ce>0&&ge>0)return s.replace(u,"$1").replace(h,"$1"+Ge);break;default:return e.trim()+s.replace(h,"$1"+e.trim())}default:if(r*ge>0&&s.indexOf("\f")>0)return s.replace(h,(e.charCodeAt(0)===V?"":"$1")+e.trim())}return e+s}function Ke(e,a,r,c){var l,o=0,h=e+";",u=2*a+3*r+4*c;if(944===u)return function(e){var a=e.length,r=e.indexOf(":",9)+1,c=e.substring(0,r).trim(),s=e.substring(r,a-1).trim();switch(e.charCodeAt(9)*Be){case 0:break;case Q:if(110!==e.charCodeAt(10))break;default:for(var t=s.split((s="",f)),i=0,r=0,a=t.length;i<a;r=0,++i){for(var l=t[i],o=l.split(n);l=o[r];){var h=l.charCodeAt(0);if(1===Be&&(h>L&&h<90||h>96&&h<123||h===R||h===Q&&l.charCodeAt(1)!==Q))switch(isNaN(parseFloat(l))+(-1!==l.indexOf("("))){case 1:switch(l){case"infinite":case"alternate":case"backwards":case"running":case"normal":case"forwards":case"both":case"none":case"linear":case"ease":case"ease-in":case"ease-out":case"ease-in-out":case"paused":case"reverse":case"alternate-reverse":case"inherit":case"initial":case"unset":case"step-start":case"step-end":break;default:l+=De}}o[r++]=l}s+=(0===i?"":",")+o.join(" ")}}if(s=c+s+";",1===Ae||2===Ae&&Le(s,1))return N+s+s;return s}(h);else if(0===Ae||2===Ae&&!Le(h,1))return h;switch(u){case 1015:return 97===h.charCodeAt(10)?N+h+h:h;case 951:return 116===h.charCodeAt(3)?N+h+h:h;case 963:return 110===h.charCodeAt(5)?N+h+h:h;case 1009:if(100!==h.charCodeAt(4))break;case 969:case 942:return N+h+h;case 978:return N+h+S+h+h;case 1019:case 983:return N+h+S+h+F+h+h;case 883:if(h.charCodeAt(8)===Q)return N+h+h;if(h.indexOf("image-set(",11)>0)return h.replace(z,"$1"+N+"$2")+h;return h;case 932:if(h.charCodeAt(4)===Q)switch(h.charCodeAt(5)){case 103:return N+"box-"+h.replace("-grow","")+N+h+F+h.replace("grow","positive")+h;case 115:return N+h+F+h.replace("shrink","negative")+h;case 98:return N+h+F+h.replace("basis","preferred-size")+h}return N+h+F+h+h;case 964:return N+h+F+"flex-"+h+h;case 1023:if(99!==h.charCodeAt(8))break;return l=h.substring(h.indexOf(":",15)).replace("flex-","").replace("space-between","justify"),N+"box-pack"+l+N+h+F+"flex-pack"+l+h;case 1005:return t.test(h)?h.replace(s,":"+N)+h.replace(s,":"+S)+h:h;case 1e3:switch(o=(l=h.substring(13).trim()).indexOf("-")+1,l.charCodeAt(0)+l.charCodeAt(o)){case 226:l=h.replace(m,"tb");break;case 232:l=h.replace(m,"tb-rl");break;case 220:l=h.replace(m,"lr");break;default:return h}return N+h+F+l+h;case 1017:if(-1===h.indexOf("sticky",9))return h;case 975:switch(o=(h=e).length-10,u=(l=(33===h.charCodeAt(o)?h.substring(0,o):h).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|l.charCodeAt(7))){case 203:if(l.charCodeAt(8)<111)break;case 115:h=h.replace(l,N+l)+";"+h;break;case 207:case 102:h=h.replace(l,N+(u>102?"inline-":"")+"box")+";"+h.replace(l,N+l)+";"+h.replace(l,F+l+"box")+";"+h}return h+";";case 938:if(h.charCodeAt(5)===Q)switch(h.charCodeAt(6)){case 105:return l=h.replace("-items",""),N+h+N+"box-"+l+F+"flex-"+l+h;case 115:return N+h+F+"flex-item-"+h.replace(y,"")+h;default:return N+h+F+"flex-line-pack"+h.replace("align-content","").replace(y,"")+h}break;case 973:case 989:if(h.charCodeAt(3)!==Q||122===h.charCodeAt(4))break;case 931:case 953:if(true===j.test(e))if(115===(l=e.substring(e.indexOf(":")+1)).charCodeAt(0))return Ke(e.replace("stretch","fill-available"),a,r,c).replace(":fill-available",":stretch");else return h.replace(l,N+l)+h.replace(l,S+l.replace("fill-",""))+h;break;case 962:if(h=N+h+(102===h.charCodeAt(5)?F+h:"")+h,r+c===211&&105===h.charCodeAt(13)&&h.indexOf("transform",10)>0)return h.substring(0,h.indexOf(";",27)+1).replace(i,"$1"+N+"$2")+h}return h}function Le(e,a){var r=e.indexOf(1===a?":":"{"),c=e.substring(0,3!==a?r:10),s=e.substring(r+1,e.length-1);return Oe(2!==a?c:c.replace(O,"$1"),s,a)}function Me(e,a){var r=Ke(a,a.charCodeAt(0),a.charCodeAt(1),a.charCodeAt(2));return r!==a+";"?r.replace($," or ($1)").substring(4):"("+a+")"}function Pe(e,a,r,c,s,t,i,f,n,l){for(var o,h=0,u=a;h<ye;++h)switch(o=$e[h].call(Te,e,u,r,c,s,t,i,f,n,l)){case void 0:case false:case true:case null:break;default:u=o}if(u!==a)return u}function Qe(e,a,r,c){for(var s=a+1;s<r;++s)switch(c.charCodeAt(s)){case Z:if(e===T)if(c.charCodeAt(s-1)===T&&a+2!==s)return s+1;break;case I:if(e===Z)return s+1}return s}function Re(e){for(var a in e){var r=e[a];switch(a){case"keyframe":Be=0|r;break;case"global":Ce=0|r;break;case"cascade":ge=0|r;break;case"compress":we=0|r;break;case"semicolon":ve=0|r;break;case"preserve":me=0|r;break;case"prefix":if(Oe=null,!r)Ae=0;else if("function"!=typeof r)Ae=1;else Ae=2,Oe=r}}return Re}function Te(a,r){if(void 0!==this&&this.constructor===Te)return e(a);var s=a,t=s.charCodeAt(0);if(t<33)t=(s=s.trim()).charCodeAt(0);if(Be>0)De=s.replace(d,t===G?"":"-");if(t=1,1===ge)Ge=s;else Ee=s;var i,f=[Ge];if(ye>0)if(void 0!==(i=Pe(ze,r,f,f,pe,be,0,0,0,0))&&"string"==typeof i)r=i;var n=He(xe,f,r,0,0);if(ye>0)if(void 0!==(i=Pe(je,n,f,f,pe,be,n.length,0,0,0))&&"string"!=typeof(n=i))t=0;return De="",Ge="",Ee="",ke=0,pe=1,be=1,we*t==0?n:n.replace(c,"").replace(g,"").replace(A,"$1").replace(C,"$1").replace(w," ")}if(Te.use=function e(a){switch(a){case void 0:case null:ye=$e.length=0;break;default:if("function"==typeof a)$e[ye++]=a;else if("object"==typeof a)for(var r=0,c=a.length;r<c;++r)e(a[r]);else qe=0|!!a}return e},Te.set=Re,void 0!==a)Re(a);return Te});


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return formatSpecifier; });
/* unused harmony export FormatSpecifier */
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),
/* 153 */,
/* 154 */,
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* 
(The MIT License)
Copyright (c) 2014-2019 Halász Ádám <mail@adamhalasz.com>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//  Unique Hexatridecimal ID Generator
// ================================================

//  Dependencies
// ================================================
var pid = process && process.pid ? process.pid.toString(36) : '' ;
var address = '';
if(false){ var i, mac, networkInterfaces; } 

//  Exports
// ================================================
module.exports = module.exports.default = function(prefix, suffix){ return (prefix ? prefix : '') + address + pid + now().toString(36) + (suffix ? suffix : ''); }
module.exports.process = function(prefix, suffix){ return (prefix ? prefix : '') + pid + now().toString(36) + (suffix ? suffix : ''); }
module.exports.time    = function(prefix, suffix){ return (prefix ? prefix : '') + now().toString(36) + (suffix ? suffix : ''); }

//  Helpers
// ================================================
function now(){
    var time = Date.now();
    var last = now.last || time;
    return now.last = time > last ? time : last + 1;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(157)))

/***/ }),
/* 157 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// modules
var React = __importStar(__webpack_require__(0));
var annotationHandling_1 = __webpack_require__(254);
var Legend_1 = __importDefault(__webpack_require__(159));
var Annotation_1 = __importDefault(__webpack_require__(49));
var labella = __importStar(__webpack_require__(267));
var SpanOrDiv_1 = __webpack_require__(41);
function marginOffsetFn(orient, axisSettings, marginOffset) {
    if (typeof marginOffset === "number") {
        return marginOffset;
    }
    if (axisSettings && axisSettings.find(function (d) { return d.props.orient === orient; })) {
        return 50;
    }
    return 10;
}
function adjustedAnnotationKeyMapper(d) {
    var _a = d.props.noteData.note, note = _a === void 0 ? {} : _a;
    var label = note.label, title = note.title;
    var id = d.props.noteData.id || d.props.noteData.x + "-" + d.props.noteData.y;
    return id + "-" + label + "=" + title;
}
function noteDataWidth(noteData, charWidth, layoutNoteWidth) {
    if (charWidth === void 0) { charWidth = 8; }
    var _a = noteData.noteWidth, noteWidth = _a === void 0 ? layoutNoteWidth : _a;
    var noteWidthFn = noteWidth;
    if (typeof noteWidth === "number") {
        noteWidthFn = function () { return noteWidth; };
    }
    var wrap = (noteData.note && noteData.note.wrap) || 120;
    var noteText = noteData.note.label || noteData.note.label || "";
    var width = (noteWidth && noteWidthFn(noteData)) ||
        (React.isValidElement(noteData.note)
            ? 100
            : Math.min(wrap, noteText.length * charWidth));
    return width;
}
function noteDataHeight(noteData, charWidth, lineHeight, layoutNoteHeight) {
    if (charWidth === void 0) { charWidth = 8; }
    if (lineHeight === void 0) { lineHeight = 20; }
    var _a = noteData.noteHeight, noteHeight = _a === void 0 ? layoutNoteHeight : _a;
    var noteHeightFn = noteHeight;
    if (typeof noteHeight === "number") {
        noteHeightFn = function () { return noteHeight; };
    }
    var wrap = (noteData.note && noteData.note.wrap) || 120;
    var text = noteData.note.label || noteData.note.title || "";
    var height = (noteHeight && noteHeightFn(noteData)) ||
        (React.isValidElement(noteData.note)
            ? 30
            : Math.ceil((text.length * charWidth) / wrap) * lineHeight +
                (noteData.note.label && noteData.note.title ? lineHeight : 0));
    return height;
}
var processAnnotations = function (adjustableAnnotations, annotationProcessor, props) {
    var _a = annotationProcessor.layout, layout = _a === void 0 ? { type: false, noteHeight: undefined, noteWidth: undefined } : _a;
    if (layout.type === false) {
        return adjustableAnnotations;
    }
    var layoutNoteHeight = layout.noteWidth, layoutNoteWidth = layout.noteHeight;
    var _b = props.margin, margin = _b === void 0 ? { top: 0, bottom: 0, left: 0, right: 0 } : _b;
    var size = props.size, _c = props.axes, axes = _c === void 0 ? [] : _c;
    margin =
        typeof margin === "number"
            ? { top: margin, left: margin, right: margin, bottom: margin }
            : margin;
    if (layout.type === "bump") {
        var adjustedAnnotations = annotationHandling_1.bumpAnnotations(adjustableAnnotations, layout, size, props.pointSizeFunction, props.labelSizeFunction);
        return adjustedAnnotations;
    }
    else if (layout.type === "marginalia") {
        var marginOffset_1 = layout.marginOffset, _d = layout.orient, orient = _d === void 0 ? "nearest" : _d, _e = layout.characterWidth, characterWidth_1 = _e === void 0 ? 8 : _e, _f = layout.lineHeight, lineHeight_1 = _f === void 0 ? 20 : _f, _g = layout.padding, padding_1 = _g === void 0 ? 2 : _g, _h = layout.axisMarginOverride, axisMarginOverride = _h === void 0 ? {} : _h;
        var finalOrientation = orient === "nearest"
            ? ["left", "right", "top", "bottom"]
            : Array.isArray(orient)
                ? orient
                : [orient];
        var leftOn_1 = finalOrientation.find(function (d) { return d === "left"; });
        var rightOn_1 = finalOrientation.find(function (d) { return d === "right"; });
        var topOn_1 = finalOrientation.find(function (d) { return d === "top"; });
        var bottomOn_1 = finalOrientation.find(function (d) { return d === "bottom"; });
        var leftNodes_1 = [];
        var rightNodes_1 = [];
        var topNodes_1 = [];
        var bottomNodes_1 = [];
        adjustableAnnotations.forEach(function (aNote) {
            var noteData = aNote.props.noteData;
            var noteX = noteData.x[0] || noteData.x;
            var noteY = noteData.y[0] || noteData.y;
            var leftDist = leftOn_1 ? noteX : Infinity;
            var rightDist = rightOn_1 ? size[0] - noteX : Infinity;
            var topDist = topOn_1 ? noteY : Infinity;
            var bottomDist = bottomOn_1 ? size[1] - noteY : Infinity;
            var minDist = Math.min(leftDist, rightDist, topDist, bottomDist);
            if (leftDist === minDist) {
                leftNodes_1.push(aNote);
            }
            else if (rightDist === minDist) {
                rightNodes_1.push(aNote);
            }
            else if (topDist === minDist) {
                topNodes_1.push(aNote);
            }
            else {
                bottomNodes_1.push(aNote);
            }
        });
        //Adjust the margins based on which regions are active
        var leftForce = new labella.Force({
            minPos: axisMarginOverride.top !== undefined
                ? 0 + axisMarginOverride.top
                : 0 - margin.top,
            maxPos: axisMarginOverride.bottom !== undefined
                ? size[1] - axisMarginOverride.bottom
                : bottomOn_1
                    ? size[1]
                    : size[1] + margin.bottom
        })
            .nodes(leftNodes_1.map(function (d) {
            var noteY = d.props.noteData.y[0] || d.props.noteData.y;
            return new labella.Node(noteY, noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1, layoutNoteHeight) + padding_1);
        }))
            .compute();
        var rightForce = new labella.Force({
            minPos: axisMarginOverride.top !== undefined
                ? 0 + axisMarginOverride.top
                : topOn_1
                    ? 0
                    : 0 - margin.top,
            maxPos: axisMarginOverride.bottom !== undefined
                ? size[1] - axisMarginOverride.bottom
                : size[1] + margin.bottom
        })
            .nodes(rightNodes_1.map(function (d) {
            var noteY = d.props.noteData.y[0] || d.props.noteData.y;
            return new labella.Node(noteY, noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1, layoutNoteHeight) + padding_1);
        }))
            .compute();
        var topForce = new labella.Force({
            minPos: axisMarginOverride.left !== undefined
                ? 0 + axisMarginOverride.left
                : leftOn_1
                    ? 0
                    : 0 - margin.left,
            maxPos: axisMarginOverride.right !== undefined
                ? size[0] - axisMarginOverride.right
                : size[0] + margin.right
        })
            .nodes(topNodes_1.map(function (d) {
            var noteX = d.props.noteData.x[0] || d.props.noteData.x;
            return new labella.Node(noteX, noteDataWidth(d.props.noteData, characterWidth_1, layoutNoteWidth) +
                padding_1);
        }))
            .compute();
        var bottomForce = new labella.Force({
            minPos: axisMarginOverride.left !== undefined
                ? 0 + axisMarginOverride.left
                : 0 - margin.left,
            maxPos: axisMarginOverride.right !== undefined
                ? size[0] - axisMarginOverride.right
                : rightOn_1
                    ? size[0]
                    : size[0] + margin.right
        })
            .nodes(bottomNodes_1.map(function (d) {
            var noteX = d.props.noteData.x[0] || d.props.noteData.x;
            return new labella.Node(noteX, noteDataWidth(d.props.noteData, characterWidth_1, layoutNoteWidth) +
                padding_1);
        }))
            .compute();
        var bottomOffset_1 = Math.max.apply(Math, __spread(bottomNodes_1.map(function (d) {
            return noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1, layoutNoteHeight) + padding_1;
        })));
        var topOffset_1 = Math.max.apply(Math, __spread(topNodes_1.map(function (d) {
            return noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1, layoutNoteHeight) + padding_1;
        })));
        var leftOffset_1 = Math.max.apply(Math, __spread(leftNodes_1.map(function (d) {
            return noteDataWidth(d.props.noteData, characterWidth_1, layoutNoteWidth) +
                padding_1;
        })));
        var rightOffset_1 = Math.max.apply(Math, __spread(rightNodes_1.map(function (d) {
            return noteDataWidth(d.props.noteData, characterWidth_1, layoutNoteWidth) +
                padding_1;
        })));
        //      const nodeOffsetHeight = Math.max()
        var leftSortedNodes_1 = leftForce.nodes();
        var rightSortedNodes_1 = rightForce.nodes();
        var topSortedNodes_1 = topForce.nodes();
        var bottomSortedNodes_1 = bottomForce.nodes();
        leftNodes_1.forEach(function (note, i) {
            var x = 0 -
                leftSortedNodes_1[i].layerIndex * leftOffset_1 -
                marginOffsetFn("left", axes, marginOffset_1);
            var y = leftSortedNodes_1[i].currentPos;
            note.props.noteData.nx = x;
            note.props.noteData.ny = y;
            if (note.props.noteData.note && !React.isValidElement(note)) {
                note.props.noteData.note.orientation =
                    note.props.noteData.note.orientation || "leftRight";
                note.props.noteData.note.align =
                    note.props.noteData.note.align || "right";
            }
        });
        rightNodes_1.forEach(function (note, i) {
            var x = size[0] +
                rightSortedNodes_1[i].layerIndex * rightOffset_1 +
                marginOffsetFn("right", axes, marginOffset_1);
            var y = rightSortedNodes_1[i].currentPos;
            note.props.noteData.nx = x;
            note.props.noteData.ny = y;
            if (note.props.noteData.note && !React.isValidElement(note)) {
                note.props.noteData.note.orientation =
                    note.props.noteData.note.orientation || "leftRight";
                note.props.noteData.note.align =
                    note.props.noteData.note.align || "left";
            }
        });
        topNodes_1.forEach(function (note, i) {
            var x = topSortedNodes_1[i].currentPos;
            var y = 0 -
                topSortedNodes_1[i].layerIndex * topOffset_1 -
                marginOffsetFn("top", axes, marginOffset_1);
            note.props.noteData.nx = x;
            note.props.noteData.ny = y;
        });
        bottomNodes_1.forEach(function (note, i) {
            var x = bottomSortedNodes_1[i].currentPos;
            var y = size[1] +
                bottomSortedNodes_1[i].layerIndex * bottomOffset_1 +
                marginOffsetFn("bottom", axes, marginOffset_1);
            note.props.noteData.nx = x;
            note.props.noteData.ny = y;
        });
        return adjustableAnnotations;
    }
    return adjustableAnnotations;
};
var generateSVGAnnotations = function (props, annotations) {
    var renderedAnnotations = annotations
        .map(function (d, i) { return props.svgAnnotationRule(d, i, props); })
        .filter(function (d) { return d !== null && d !== undefined; });
    return renderedAnnotations;
};
var generateHTMLAnnotations = function (props, annotations) {
    var renderedAnnotations = annotations
        .map(function (d, i) { return props.htmlAnnotationRule(d, i, props); })
        .filter(function (d) { return d !== null && d !== undefined; });
    return renderedAnnotations;
};
var createAnnotations = function (props, state) {
    console.log(" in createAnnotations");
    var renderedSVGAnnotations = state.svgAnnotations, renderedHTMLAnnotations = [], adjustedAnnotations = state.adjustedAnnotations, adjustableAnnotationsKey = state.adjustedAnnotationsKey;
    var adjustedAnnotationsKey = state.adjustedAnnotationsKey, adjustedAnnotationsDataVersion = state.adjustedAnnotationsDataVersion;
    var annotations = props.annotations, _a = props.annotationHandling, annotationHandling = _a === void 0 ? false : _a, size = props.size, svgAnnotationRule = props.svgAnnotationRule, htmlAnnotationRule = props.htmlAnnotationRule;
    var annotationProcessor = typeof annotationHandling === "object"
        ? annotationHandling
        : { layout: { type: annotationHandling }, dataVersion: "" };
    var _b = annotationProcessor.dataVersion, dataVersion = _b === void 0 ? "" : _b;
    if (svgAnnotationRule) {
        var initialSVGAnnotations = generateSVGAnnotations(props, annotations);
        var adjustableAnnotations = initialSVGAnnotations.filter(function (d) { return d.props && d.props.noteData && !d.props.noteData.fixedPosition; });
        var fixedAnnotations = initialSVGAnnotations.filter(function (d) { return !d.props || !d.props.noteData || d.props.noteData.fixedPosition; });
        adjustableAnnotationsKey = "" + adjustableAnnotations
            .map(adjustedAnnotationKeyMapper)
            .join(",") + JSON.stringify(annotationProcessor) + size.join(",");
        if (annotationHandling === false) {
            adjustedAnnotations = adjustableAnnotations;
        }
        if (adjustedAnnotations.length !== adjustableAnnotations.length ||
            adjustedAnnotationsKey !== adjustableAnnotationsKey ||
            adjustedAnnotationsDataVersion !== dataVersion) {
            console.log("adjusted 1");
            adjustedAnnotations = processAnnotations(adjustableAnnotations, annotationProcessor, props);
        }
        else {
            //Handle when style or other attributes change
            console.log("adjusted 2");
            adjustedAnnotations = adjustableAnnotations.map(function (d, i) {
                var oldAnnotation = adjustedAnnotations[i];
                var newNoteData = __assign(__assign({}, oldAnnotation.props.noteData), d.props.noteData);
                return React.createElement(Annotation_1.default, { key: d.key, noteData: newNoteData });
            });
        }
        renderedSVGAnnotations = __spread(adjustedAnnotations, fixedAnnotations);
    }
    if (htmlAnnotationRule) {
        renderedHTMLAnnotations = generateHTMLAnnotations(props, annotations);
    }
    return {
        svgAnnotations: renderedSVGAnnotations,
        htmlAnnotations: renderedHTMLAnnotations,
        adjustedAnnotations: adjustedAnnotations,
        adjustedAnnotationsKey: adjustableAnnotationsKey,
        adjustedAnnotationsDataVersion: dataVersion
    };
};
var AnnotationLayer = /** @class */ (function (_super) {
    __extends(AnnotationLayer, _super);
    function AnnotationLayer(props) {
        var _this = _super.call(this, props) || this;
        var baseState = {
            svgAnnotations: [],
            htmlAnnotations: [],
            adjustedAnnotations: [],
            adjustedAnnotationsKey: "",
            adjustedAnnotationsDataVersion: "",
            SpanOrDiv: SpanOrDiv_1.HOCSpanOrDiv(props.useSpans)
        };
        _this.state = __assign(__assign({}, baseState), createAnnotations(props, baseState));
        return _this;
    }
    AnnotationLayer.getDerivedStateFromProps = function (nextProps, prevState) {
        return createAnnotations(nextProps, prevState);
    };
    AnnotationLayer.prototype.render = function () {
        var _a = this.state, svgAnnotations = _a.svgAnnotations, htmlAnnotations = _a.htmlAnnotations, SpanOrDiv = _a.SpanOrDiv;
        var _b = this.props, legendSettings = _b.legendSettings, margin = _b.margin, size = _b.size;
        var renderedLegend;
        if (legendSettings) {
            var positionHash = {
                left: [15, 15],
                right: [size[0] + 15, 15]
            };
            var _c = legendSettings.position, position = _c === void 0 ? "right" : _c, _d = legendSettings.title, title = _d === void 0 ? "Legend" : _d;
            var legendPosition = positionHash[position];
            renderedLegend = (React.createElement("g", { transform: "translate(" + legendPosition.join(",") + ")" },
                React.createElement(Legend_1.default, __assign({}, legendSettings, { title: title, position: position }))));
        }
        return (React.createElement(SpanOrDiv, { className: "annotation-layer", style: {
                position: "absolute",
                pointerEvents: "none",
                background: "none"
            } },
            React.createElement("svg", { className: "annotation-layer-svg", height: size[1], width: size[0], style: {
                    background: "none",
                    pointerEvents: "none",
                    position: "absolute",
                    left: margin.left + "px",
                    top: margin.top + "px",
                    overflow: "visible"
                } },
                React.createElement("g", null,
                    renderedLegend,
                    svgAnnotations)),
            React.createElement(SpanOrDiv, { className: "annotation-layer-html", style: {
                    background: "none",
                    pointerEvents: "none",
                    position: "absolute",
                    height: size[1] + "px",
                    width: size[0] + "px",
                    left: margin.left + "px",
                    top: margin.top + "px"
                } }, htmlAnnotations)));
    };
    return AnnotationLayer;
}(React.Component));
exports.default = AnnotationLayer;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var typeHash = {
    fill: function (style) { return React.createElement("rect", { style: style, width: 20, height: 20 }); },
    line: function (style) { return React.createElement("line", { style: style, x1: 0, y1: 0, x2: 20, y2: 20 }); }
};
function renderType(item, i, type, styleFn) {
    var renderedType;
    if (typeof type === "function") {
        renderedType = type(item);
    }
    else {
        var Type = typeHash[type];
        var style = styleFn(item, i);
        renderedType = Type(style);
    }
    return renderedType;
}
var Legend = /** @class */ (function (_super) {
    __extends(Legend, _super);
    function Legend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Legend.prototype.renderLegendGroup = function (legendGroup) {
        var _a = legendGroup.type, type = _a === void 0 ? "fill" : _a, styleFn = legendGroup.styleFn, items = legendGroup.items;
        var renderedItems = [];
        var itemOffset = 0;
        items.forEach(function (item, i) {
            var renderedType = renderType(item, i, type, styleFn);
            renderedItems.push(React.createElement("g", { key: "legend-item-" + i, transform: "translate(0," + itemOffset + ")" },
                renderedType,
                React.createElement("text", { y: 15, x: 30 }, item.label)));
            itemOffset += 25;
        });
        return renderedItems;
    };
    Legend.prototype.renderLegendGroupHorizontal = function (legendGroup) {
        var _a = legendGroup.type, type = _a === void 0 ? "fill" : _a, styleFn = legendGroup.styleFn, items = legendGroup.items;
        var renderedItems = [];
        var itemOffset = 0;
        items.forEach(function (item, i) {
            var renderedType = renderType(item, i, type, styleFn);
            renderedItems.push(React.createElement("g", { key: "legend-item-" + i, transform: "translate(" + itemOffset + ",0)" },
                renderedType,
                React.createElement("text", { y: 15, x: 25 }, item.label)));
            itemOffset += 35;
            itemOffset += item.label.length * 8;
        });
        return { items: renderedItems, offset: itemOffset };
    };
    Legend.prototype.renderGroup = function (_a) {
        var _this = this;
        var legendGroups = _a.legendGroups, width = _a.width;
        var offset = 30;
        var renderedGroups = [];
        legendGroups.forEach(function (l, i) {
            offset += 5;
            renderedGroups.push(React.createElement("line", { key: "legend-top-line legend-symbol-" + i, stroke: "gray", x1: 0, y1: offset, x2: width, y2: offset }));
            offset += 10;
            if (l.label) {
                offset += 20;
                renderedGroups.push(React.createElement("text", { key: "legend-text-" + i, y: offset, className: "legend-group-label" }, l.label));
                offset += 10;
            }
            renderedGroups.push(React.createElement("g", { key: "legend-group-" + i, className: "legend-item", transform: "translate(0," + offset + ")" }, _this.renderLegendGroup(l)));
            offset += l.items.length * 25 + 10;
        });
        return renderedGroups;
    };
    Legend.prototype.renderHorizontalGroup = function (_a) {
        var _this = this;
        var legendGroups = _a.legendGroups, title = _a.title, height = _a.height;
        var offset = 0;
        var renderedGroups = [];
        var verticalOffset = title === false ? 10 : 40;
        legendGroups.forEach(function (l, i) {
            if (l.label) {
                renderedGroups.push(React.createElement("text", { key: "legend-text-" + i, transform: "translate(" + offset + "," + verticalOffset + ") rotate(90)", textAnchor: "start", className: "legend-group-label" }, l.label));
                offset += 20;
            }
            var renderedItems = _this.renderLegendGroupHorizontal(l);
            renderedGroups.push(React.createElement("g", { key: "legend-group-" + i, className: "legend-item", transform: "translate(" + offset + "," + verticalOffset + ")" }, renderedItems.items));
            offset += renderedItems.offset + 5;
            if (legendGroups[i + 1]) {
                renderedGroups.push(React.createElement("line", { key: "legend-top-line legend-symbol-" + i, stroke: "gray", x1: offset, y1: verticalOffset - 10, x2: offset, y2: height + verticalOffset + 10 }));
            }
            offset += 15;
        });
        return (React.createElement("g", null,
            title !== false && (React.createElement("line", { x1: 0, x2: offset + 10, y1: verticalOffset - 10, y2: verticalOffset - 10, stroke: "gray", className: "title-neatline" })),
            renderedGroups));
    };
    Legend.prototype.render = function () {
        var _a = this.props, legendGroups = _a.legendGroups, _b = _a.title, title = _b === void 0 ? "Legend" : _b, _c = _a.width, width = _c === void 0 ? 100 : _c, _d = _a.height, height = _d === void 0 ? 20 : _d, _e = _a.orientation, orientation = _e === void 0 ? "vertical" : _e;
        var renderedGroups = orientation === "vertical"
            ? this.renderGroup({
                legendGroups: legendGroups,
                width: width
            })
            : this.renderHorizontalGroup({
                legendGroups: legendGroups,
                title: title,
                height: height
            });
        return (React.createElement("g", null,
            title !== undefined && (React.createElement("text", { className: "legend-title", y: 20, x: orientation === "horizontal" ? 0 : width / 2, textAnchor: orientation === "horizontal" ? "start" : "middle" }, title)),
            renderedGroups));
    };
    return Legend;
}(React.Component));
exports.default = Legend;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationLabel;

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

var _ConnectorLine = _interopRequireDefault(__webpack_require__(116));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationLabel(props) {
  var className = (0, _classnames.default)("label", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorLine.default, {
    align: "middle"
  });
}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Annotation =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Annotation, _React$Component);

  function Annotation() {
    _classCallCheck(this, Annotation);

    return _possibleConstructorReturn(this, _getPrototypeOf(Annotation).apply(this, arguments));
  }

  _createClass(Annotation, [{
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props = this.props,
          x = _this$props.x,
          y = _this$props.y,
          nx = _this$props.nx,
          ny = _this$props.ny,
          events = _this$props.events;
      var cleanedProps = Object.assign({}, this.props);
      delete cleanedProps.children;
      var cleanedWithoutEvents = Object.assign({}, cleanedProps);
      delete cleanedWithoutEvents.events;
      if (nx !== undefined) cleanedProps.dx = nx - x;
      if (ny !== undefined) cleanedProps.dy = ny - y;

      var childrenWithProps = _react.default.Children.toArray(this.props.children).map(function (child) {
        return _react.default.cloneElement(child, _objectSpread({}, typeof child.type === "string" ? cleanedWithoutEvents : cleanedProps, child.props));
      });

      var wrappedEvents = {};
      Object.keys(events).forEach(function (k) {
        wrappedEvents[k] = function (e) {
          events[k](_this.props, _this.state, e);
        };
      });
      return _react.default.createElement("g", _extends({
        className: (0, _classnames.default)("annotation", this.props.className),
        transform: "translate(".concat(x, ", ").concat(y, ")")
      }, wrappedEvents), childrenWithProps);
    }
  }]);

  return Annotation;
}(_react.default.Component);

exports.default = Annotation;
Annotation.defaultProps = {
  x: 0,
  y: 0,
  dx: 0,
  dy: 0,
  color: "grey",
  events: {}
};
Annotation.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  color: _propTypes.default.string,
  editMode: _propTypes.default.bool,
  events: _propTypes.default.object
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineSetup = undefined;

var _Builder = __webpack_require__(21);

var lineSetup = exports.lineSetup = function lineSetup(_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      radiusPadding = _ref.radiusPadding,
      width = _ref.width,
      height = _ref.height;

  var x1 = 0,
      x2 = dx,
      y1 = 0,
      y2 = dy;

  if (outerRadius || radius) {
    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    var angle = Math.asin(-y2 / h);
    var r = (outerRadius || radius) + (radiusPadding || 0);

    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
  }

  if (width && height) {
    if (width > 0 && dx > 0 || width < 0 && dx < 0) {
      if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && dy > 0 || height < 0 && dy < 0) {
      if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;
      y1 = y2;
    }
  }

  return [[x1, y1], [x2, y2]];
};

exports.default = function (connectorData) {
  var data = lineSetup(connectorData);
  return { components: [(0, _Builder.lineBuilder)({ data: data, className: "connector" })] };
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEnd =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ConnectorEnd, _React$Component);

  function ConnectorEnd() {
    _classCallCheck(this, ConnectorEnd);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEnd).apply(this, arguments));
  }

  _createClass(ConnectorEnd, [{
    key: "getComponents",
    value: function getComponents() {}
  }, {
    key: "render",
    value: function render() {
      var color = this.props.color;
      var d = this.getComponents(this.props) || [];
      var c = d.components[0];
      return _react.default.createElement(c.type, _extends({
        className: c.className
      }, c.attrs, {
        fill: color
      }));
    }
  }]);

  return ConnectorEnd;
}(_react.default.Component);

exports.default = ConnectorEnd;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _alignment4 = _interopRequireDefault(__webpack_require__(118));

var _Handle = _interopRequireDefault(__webpack_require__(66));

var _lineTypeVertical = _interopRequireDefault(__webpack_require__(264));

var _lineTypeHorizontal = _interopRequireDefault(__webpack_require__(265));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getOuterBBox = function getOuterBBox() {
  for (var _len = arguments.length, domNodes = new Array(_len), _key = 0; _key < _len; _key++) {
    domNodes[_key] = arguments[_key];
  }

  return domNodes.concat().reduce(function (p, c) {
    if (c) {
      var bbox = c.getBBox();
      p.x = Math.min(p.x, bbox.x);
      p.y = Math.min(p.y, bbox.y);
      p.width = Math.max(p.width, bbox.width);
      var yOffset = c && c.attributes && c.attributes.y;
      p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
    }

    return p;
  }, {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
};

var Note =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Note, _React$Component);

  function Note(props) {
    var _this;

    _classCallCheck(this, Note);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Note).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      translateX: 0,
      translateY: 0,
      labelOffset: 0,
      changed: 0,
      bbox: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      }
    });

    if (!props.noWrap) {
      _this.updateText = _this.updateText.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    }

    return _this;
  }

  _createClass(Note, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      !this.props.noWrap && this.updateText(this.props);
    }
  }, {
    key: "updateText",
    value: function updateText(_ref) {
      var _this2 = this;

      var orientation = _ref.orientation,
          padding = _ref.padding,
          align = _ref.align,
          lineType = _ref.lineType,
          label = _ref.label,
          title = _ref.title,
          wrap = _ref.wrap,
          wrapSplitter = _ref.wrapSplitter,
          dx = _ref.dx,
          dy = _ref.dy;
      var newState = {
        titleWrapped: null,
        labelWrapped: null
      };
      newState.changed = this.state.changed + 1;

      if (title) {
        newState.titleWrapped = this.title && this.wrapText(this.title, newState.changed, title, wrap, wrapSplitter);
      }

      if (label) newState.labelWrapped = this.label && this.wrapText(this.label, newState.changed, label, wrap, wrapSplitter);
      this.setState(newState, function () {
        var setLabel = function setLabel() {
          var bbox = getOuterBBox(_this2.title, _this2.label);
          var noteParams = {
            padding: padding,
            bbox: bbox,
            offset: {
              x: dx,
              y: dy
            },
            orientation: orientation,
            align: align
          };
          if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

          var _alignment = (0, _alignment4.default)(noteParams),
              x = _alignment.x,
              y = _alignment.y;

          _this2.setState({
            translateX: x,
            translateY: y,
            bbox: bbox
          });
        };

        _this2.setState({
          labelOffset: title && _this2.title.getBBox().height || 0
        }, setLabel);
      });
    }
  }, {
    key: "wrapText",
    value: function wrapText(textRef, key, text, width, wrapSplitter) {
      var initialAttrs = {
        x: 0,
        dy: "1.2em"
      };
      var words = text.split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
        return w !== "";
      });
      var word = words.pop(),
          line = [];
      var tspans = [];

      while (word) {
        line.push(word);
        textRef.lastChild.textContent = line.join(" ");
        var length = textRef.lastChild.getComputedTextLength();
        textRef.lastChild.textContent = "";

        if (length > width && line.length > 1) {
          line.pop();
          tspans.push(_react.default.createElement("tspan", _extends({
            key: tspans.length + text
          }, initialAttrs), line.join(" ")));
          line = [word];
        }

        word = words.pop();
      }

      if (line.length !== 0) {
        tspans.push(_react.default.createElement("tspan", _extends({
          key: tspans.length + text
        }, initialAttrs), line.join(" ")));
      }

      return _react.default.createElement("tspan", _extends({}, initialAttrs, {
        key: key + text
      }), tspans);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (!this.props.noWrap) return;

      if (prevProps.title !== this.props.title || prevProps.label !== this.props.label || prevProps.wrap !== this.props.wrap) {
        this.updateText(this.props);
      } // if (
      //   prevProps.editMode &&
      //   (prevProps.align === "dynamic" || !prevProps.align)
      // ) {
      //   this.updateText(this.props)
      // }


      var _this$props = this.props,
          orientation = _this$props.orientation,
          padding = _this$props.padding,
          align = _this$props.align,
          dx = _this$props.dx,
          dy = _this$props.dy,
          lineType = _this$props.lineType;

      if (this.state.bbox.width && (prevProps.dx !== this.props.dx || prevProps.dy !== this.props.dy) && (this.title || this.label)) {
        var bbox = getOuterBBox(this.title, this.label);
        var noteParams = {
          padding: padding,
          bbox: bbox,
          offset: {
            x: dx,
            y: dy
          },
          orientation: orientation,
          align: align
        };
        if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

        var _alignment2 = (0, _alignment4.default)(noteParams),
            x = _alignment2.x,
            y = _alignment2.y;

        var updates = {
          bbox: bbox
        };
        if (this.state.translateX !== x) updates.translateX = x;
        if (this.state.translateY !== y) updates.translateY = y;

        if (updates.translateX !== undefined || updates.translateY !== undefined) {
          this.setState(updates);
        }
      } else if (this.state.align !== prevProps.align || this.props.orientation !== prevProps.orientation || this.props.padding !== prevProps.padding) {
        var _noteParams = {
          padding: padding,
          bbox: this.state.bbox,
          offset: {
            x: dx,
            y: dy
          },
          orientation: orientation,
          align: align
        };
        if (lineType === "vertical") _noteParams.orientation = "leftRight";else if (lineType === "horizontal") _noteParams.orientation = "topBottom";

        var _alignment3 = (0, _alignment4.default)(_noteParams),
            _x = _alignment3.x,
            _y = _alignment3.y;

        var _updates = {};
        if (this.state.translateX !== _x) _updates.translateX = _x;
        if (this.state.translateY !== _y) _updates.translateY = _y;

        if (_updates.translateX !== undefined || _updates.translateY !== undefined) {
          this.setState(_updates);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          dx = _this$props2.dx,
          dy = _this$props2.dy,
          title = _this$props2.title,
          label = _this$props2.label,
          align = _this$props2.align,
          editMode = _this$props2.editMode,
          lineType = _this$props2.lineType,
          color = _this$props2.color,
          titleColor = _this$props2.titleColor,
          labelColor = _this$props2.labelColor,
          bgPadding = _this$props2.bgPadding,
          noWrap = _this$props2.noWrap;
      var bgPaddingFinal = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };

      if (typeof bgPadding === "number") {
        bgPaddingFinal = {
          top: bgPadding,
          bottom: bgPadding,
          left: bgPadding,
          right: bgPadding
        };
      } else if (bgPadding && _typeof(bgPadding) === "object") {
        bgPaddingFinal = Object.assign(bgPaddingFinal, bgPadding);
      }

      var noteTitle, noteText, noteLineType;

      if (title) {
        noteTitle = _react.default.createElement("text", {
          ref: !noWrap ? function (el) {
            return _this3.title = el;
          } : undefined,
          className: "annotation-note-title",
          fontWeight: "bold",
          key: "title",
          fill: titleColor || color
        }, !noWrap && this.state.titleWrapped || _react.default.createElement("tspan", {
          x: 0,
          dy: ".8em"
        }, title));
      }

      if (label) {
        noteText = _react.default.createElement("text", {
          ref: !noWrap ? function (el) {
            return _this3.label = el;
          } : undefined,
          className: "annotation-note-label",
          y: this.state.labelOffset * 1.1,
          key: "label",
          fill: labelColor || color
        }, !noWrap && this.state.labelWrapped || _react.default.createElement("tspan", {
          x: 0,
          dy: ".8em"
        }, label));
      }

      if (lineType && this.state.bbox.width) {
        var noteParams = {
          bbox: this.state.bbox,
          align: align,
          offset: {
            x: dx,
            y: dy
          }
        };
        var noteComponent = (lineType === "vertical" && (0, _lineTypeVertical.default)(noteParams) || lineType === "horizontal" && (0, _lineTypeHorizontal.default)(noteParams)).components[0];
        noteLineType = _react.default.createElement(noteComponent.type, _extends({
          className: noteComponent.className
        }, noteComponent.attrs, {
          stroke: color
        }));
      }

      var handle;

      if (editMode) {
        handle = _react.default.createElement(_Handle.default, {
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragNote
        });
      }

      return _react.default.createElement("g", _extends({
        transform: "translate(".concat(dx, ", ").concat(dy, ")"),
        className: "annotation-note"
      }, this.props.gProps), _react.default.createElement("g", {
        className: "annotation-note-content",
        transform: "translate(".concat(this.state.translateX, ",\n          ").concat(this.state.translateY, ")") // ref={el => (this.note = el)}

      }, _react.default.createElement("rect", {
        className: "annotation-note-bg",
        width: this.state.bbox.width + bgPaddingFinal.left + bgPaddingFinal.right,
        x: -bgPaddingFinal.left,
        y: -bgPaddingFinal.top,
        height: this.state.bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom,
        stroke: "none",
        fill: "white",
        fillOpacity: "0"
      }), noteTitle, noteText), noteLineType, handle);
    }
  }]);

  return Note;
}(_react.default.Component);

exports.default = Note;
Note.defaultProps = {
  wrap: 120,
  align: "dynamic",
  orientation: "topBottom",
  padding: 3
};
Note.propTypes = {
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  title: _propTypes.default.string,
  label: _propTypes.default.string,
  orientation: _propTypes.default.oneOf(["leftRight", "topBottom"]),
  padding: _propTypes.default.number,
  bgPadding: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.object]),
  align: _propTypes.default.oneOf(["left", "right", "middle", "top", "bottom", "dynamic"]),
  editMode: _propTypes.default.bool,
  lineType: _propTypes.default.oneOf(["vertical", "horizontal"]),
  color: _propTypes.default.string,
  titleColor: _propTypes.default.string,
  labelColor: _propTypes.default.string
};

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);



/* harmony default export */ __webpack_exports__["a"] = (function(node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node, event);
});


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);



/* harmony default export */ __webpack_exports__["a"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node, touch);
    }
  }

  return null;
});


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
});


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_brush_1 = __webpack_require__(515);
var d3_selection_1 = __webpack_require__(11);
// components
var Brush_1 = __importDefault(__webpack_require__(169));
var SpanOrDiv_1 = __webpack_require__(41);
var InteractionItems_1 = __webpack_require__(272);
var InteractionCanvas_1 = __importDefault(__webpack_require__(273));
var generateOMappingFn = function (projectedColumns) { return function (d) {
    if (d) {
        var columnValues = Object.values(projectedColumns);
        var foundColumns = columnValues.filter(function (c) {
            return d[1] >= c.x && d[0] <= c.x + c.width;
        });
        return foundColumns;
    }
    return null;
}; };
var generateOEndMappingFn = function (projectedColumns) { return function (d) {
    if (d &&
        d3_selection_1.event.sourceEvent &&
        d3_selection_1.event.sourceEvent.path &&
        d3_selection_1.event.sourceEvent.path[1] &&
        d3_selection_1.event.sourceEvent.path[1].classList.contains("xybrush") &&
        d3_selection_1.event.target.move) {
        var columnValues = Object.values(projectedColumns);
        var foundColumns = columnValues.filter(function (c) { return d[1] >= c.x && d[0] <= c.x + c.width; });
        var firstColumn = foundColumns[0] || {
            x: 0,
            width: 0
        };
        var lastColumn = foundColumns[foundColumns.length - 1] || {
            x: 0,
            width: 0
        };
        var columnPosition = [
            firstColumn.x + Math.min(5, firstColumn.width / 10),
            lastColumn.x + lastColumn.width - Math.min(5, lastColumn.width / 10)
        ];
        d3_selection_1.select(d3_selection_1.event.sourceEvent.path[1])
            .transition(750)
            .call(d3_selection_1.event.target.move, columnPosition);
        return foundColumns;
    }
    return null;
}; };
var InteractionLayer = /** @class */ (function (_super) {
    __extends(InteractionLayer, _super);
    function InteractionLayer(props) {
        var _this = _super.call(this, props) || this;
        _this.createBrush = function (interaction) {
            var semioticBrush, mappingFn, selectedExtent, endMappingFn;
            var _a = _this.props, xScale = _a.xScale, yScale = _a.yScale, size = _a.size, renderPipeline = _a.renderPipeline;
            var brushData = {};
            Object.entries(renderPipeline).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (value.data && value.data.length > 0) {
                    brushData[key] = value.data;
                }
            });
            var projection = interaction.projection, projectedColumns = interaction.projectedColumns;
            var actualBrush = interaction.brush === "oBrush"
                ? projection === "horizontal"
                    ? "yBrush"
                    : "xBrush"
                : interaction.brush;
            var _b = interaction.extent, extent = _b === void 0 ? actualBrush === "xyBrush"
                ? [
                    [xScale.invert(0), yScale.invert(0)],
                    [xScale.invert(size[0]), yScale.invert(size[1])]
                ]
                : actualBrush === "xBrush"
                    ? [xScale.invert(0), xScale.invert(size[0])]
                    : [yScale.invert(0), yScale.invert(size[1])] : _b;
            if (extent.indexOf && extent.indexOf(undefined) !== -1) {
                return React.createElement("g", null);
            }
            if (actualBrush === "xBrush") {
                var castExtent = extent;
                mappingFn = function (d) {
                    return !d ? null : [xScale.invert(d[0]), xScale.invert(d[1])];
                };
                semioticBrush = d3_brush_1.brushX();
                selectedExtent = castExtent.map(function (d) { return xScale(d); });
                endMappingFn = mappingFn;
            }
            else if (actualBrush === "yBrush") {
                var castExtent = extent;
                mappingFn = function (d) {
                    return !d
                        ? null
                        : [yScale.invert(d[0]), yScale.invert(d[1])].sort(function (a, b) { return a - b; });
                };
                semioticBrush = d3_brush_1.brushY();
                selectedExtent = castExtent.map(function (d) { return yScale(d); }).sort(function (a, b) { return a - b; });
                endMappingFn = mappingFn;
            }
            else {
                var castExtent = extent;
                if (castExtent.indexOf(undefined) !== -1 ||
                    castExtent[0].indexOf(undefined) !== -1 ||
                    castExtent[1].indexOf(undefined) !== -1) {
                    return React.createElement("g", null);
                }
                semioticBrush = d3_brush_1.brush();
                mappingFn = function (d) {
                    if (!d)
                        return null;
                    var yValues = [yScale.invert(d[0][1]), yScale.invert(d[1][1])].sort(function (a, b) { return a - b; });
                    return [
                        [xScale.invert(d[0][0]), yValues[0]],
                        [xScale.invert(d[1][0]), yValues[1]]
                    ];
                };
                var yValues_1 = [yScale(extent[0][1]), yScale(extent[1][1])].sort(function (a, b) { return a - b; });
                selectedExtent = castExtent.map(function (d, i) { return [xScale(d[0]), yValues_1[i]]; });
                endMappingFn = mappingFn;
            }
            if (interaction.brush === "oBrush") {
                selectedExtent = null;
                if (interaction.extent) {
                    var _c = __read(interaction.extent, 2), leftExtent = _c[0], rightExtent = _c[1];
                    if ((typeof leftExtent === "string" || typeof leftExtent === "number") &&
                        (typeof rightExtent === "string" || typeof rightExtent === "number")) {
                        selectedExtent = [
                            projectedColumns[leftExtent].x,
                            projectedColumns[rightExtent].x +
                                projectedColumns[rightExtent].width
                        ];
                    }
                }
                mappingFn = generateOMappingFn(projectedColumns);
                endMappingFn = generateOEndMappingFn(projectedColumns);
            }
            semioticBrush
                .extent([[0, 0], [size[0], size[1]]])
                .on("start", function () {
                InteractionItems_1.brushStart(mappingFn(d3_selection_1.event.selection), undefined, brushData, undefined, interaction);
            })
                .on("brush", function () {
                InteractionItems_1.brushing(mappingFn(d3_selection_1.event.selection), undefined, brushData, undefined, interaction);
            })
                .on("end", function () {
                InteractionItems_1.brushEnd(endMappingFn(d3_selection_1.event.selection), undefined, brushData, undefined, interaction);
            });
            return (React.createElement("g", { className: "brush" },
                React.createElement(Brush_1.default, { selectedExtent: selectedExtent, extent: extent, svgBrush: semioticBrush })));
        };
        _this.createColumnsBrush = function (interaction) {
            var _a = _this.props, projection = _a.projection, rScale = _a.rScale, oColumns = _a.oColumns, renderPipeline = _a.renderPipeline;
            if (!projection || !rScale || !oColumns)
                return;
            var brushData = {};
            Object.entries(renderPipeline).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (value.data && value.data.length > 0) {
                    brushData[key] = value.data;
                }
            });
            var semioticBrush, mappingFn;
            var rScaleReverse = rScale
                .copy()
                .domain(rScale.domain())
                .range(rScale.domain().reverse());
            if (projection && projection === "horizontal") {
                mappingFn = function (d) {
                    return !d ? null : [rScale.invert(d[0]), rScale.invert(d[1])];
                };
            }
            else
                mappingFn = function (d) {
                    return !d
                        ? null
                        : [
                            rScaleReverse(rScale.invert(d[1])),
                            rScaleReverse(rScale.invert(d[0]))
                        ];
                };
            var rRange = rScale.range();
            var columnHash = oColumns;
            var brushPosition, selectedExtent;
            var brushes = Object.keys(columnHash).map(function (c) {
                if (projection && projection === "horizontal") {
                    selectedExtent = interaction.extent[c]
                        ? interaction.extent[c].map(function (d) { return rScale(d); })
                        : interaction.startEmpty ? null : rRange;
                    brushPosition = [0, columnHash[c].x];
                    semioticBrush = d3_brush_1.brushX();
                    semioticBrush
                        .extent([[rRange[0], 0], [rRange[1], columnHash[c].width]])
                        .on("start", function () {
                        InteractionItems_1.brushStart(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    })
                        .on("brush", function () {
                        InteractionItems_1.brushing(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    })
                        .on("end", function () {
                        InteractionItems_1.brushEnd(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    });
                }
                else {
                    selectedExtent = interaction.extent[c]
                        ? interaction.extent[c].map(function (d) { return rRange[1] - rScale(d); }).reverse()
                        : interaction.startEmpty ? null : rRange;
                    brushPosition = [columnHash[c].x, 0];
                    semioticBrush = d3_brush_1.brushY();
                    semioticBrush
                        .extent([[0, rRange[0]], [columnHash[c].width, rRange[1]]])
                        .on("start", function () {
                        InteractionItems_1.brushStart(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    })
                        .on("brush", function () {
                        InteractionItems_1.brushing(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    })
                        .on("end", function () {
                        InteractionItems_1.brushEnd(mappingFn(d3_selection_1.event.selection), c, brushData, columnHash[c], interaction);
                    });
                }
                return (React.createElement("g", { key: "column-brush-" + c, className: "brush" },
                    React.createElement(Brush_1.default, { key: "orbrush" + c, selectedExtent: selectedExtent, svgBrush: semioticBrush, position: brushPosition })));
            });
            return brushes;
        };
        var canvasMap = new Map();
        var canvasRendering = props.canvasRendering, useSpans = props.useSpans, svgSize = props.svgSize, margin = props.margin, voronoiHover = props.voronoiHover;
        var initialOverlayRegions = InteractionItems_1.calculateOverlay(props);
        _this.state = {
            overlayRegions: initialOverlayRegions,
            canvasMap: canvasMap,
            interactionCanvas: canvasRendering && React.createElement(InteractionCanvas_1.default, { height: svgSize[1], width: svgSize[0], overlayRegions: initialOverlayRegions, margin: margin, voronoiHover: voronoiHover }),
            props: props,
            SpanOrDiv: SpanOrDiv_1.HOCSpanOrDiv(useSpans)
        };
        return _this;
    }
    InteractionLayer.getDerivedStateFromProps = function (nextProps, prevState) {
        var props = prevState.props;
        if (props.overlay !== nextProps.overlay ||
            nextProps.points !== props.points ||
            props.xScale !== nextProps.xScale ||
            props.yScale !== nextProps.yScale ||
            ((!props.hoverAnnotation && nextProps.hoverAnnotation) || (props.hoverAnnotation && !nextProps.hoverAnnotation)) ||
            ((!props.customClickBehavior && nextProps.customClickBehavior) || (props.customClickBehavior && !nextProps.customClickBehavior)) ||
            ((!props.customDoubleClickBehavior && nextProps.customDoubleClickBehavior) || (props.customDoubleClickBehavior && !nextProps.customDoubleClickBehavior)) ||
            ((!props.customHoverBehavior && nextProps.customHoverBehavior) || (props.customHoverBehavior && !nextProps.customHoverBehavior))) {
            var disableCanvasInteraction = nextProps.disableCanvasInteraction, canvasRendering = nextProps.canvasRendering, svgSize = nextProps.svgSize, margin = nextProps.margin, voronoiHover = nextProps.voronoiHover;
            var overlayRegions = prevState.overlayRegions;
            var nextOverlay = void 0, interactionCanvas = void 0;
            if (disableCanvasInteraction ||
                !overlayRegions) {
                nextOverlay = null;
                interactionCanvas = null;
            }
            else {
                nextOverlay = InteractionItems_1.calculateOverlay(nextProps);
                if (canvasRendering) {
                    interactionCanvas = React.createElement(InteractionCanvas_1.default, { height: svgSize[1], width: svgSize[0], overlayRegions: nextOverlay, margin: margin, voronoiHover: voronoiHover });
                }
            }
            return {
                overlayRegions: nextOverlay,
                props: nextProps,
                interactionCanvas: interactionCanvas
            };
        }
        return null;
    };
    InteractionLayer.prototype.render = function () {
        var semioticBrush = null;
        var _a = this.props, interaction = _a.interaction, svgSize = _a.svgSize, margin = _a.margin, _b = _a.useSpans, useSpans = _b === void 0 ? false : _b;
        var _c = this.state, overlayRegions = _c.overlayRegions, interactionCanvas = _c.interactionCanvas, SpanOrDiv = _c.SpanOrDiv;
        var enabled = this.props.enabled;
        if (interaction && interaction.brush) {
            enabled = true;
            semioticBrush = this.createBrush(interaction);
        }
        if (interaction && interaction.columnsBrush) {
            enabled = true;
            semioticBrush = this.createColumnsBrush(interaction);
        }
        if (!overlayRegions && !semioticBrush) {
            return null;
        }
        return (React.createElement(SpanOrDiv, { span: useSpans, className: "interaction-layer", style: {
                position: "absolute",
                background: "none",
                pointerEvents: "none"
            } }, interactionCanvas || (React.createElement("svg", { height: svgSize[1], width: svgSize[0], style: { background: "none", pointerEvents: "none" } },
            React.createElement("g", { className: "interaction-overlay", transform: "translate(" + margin.left + "," + margin.top + ")", style: { pointerEvents: enabled ? "all" : "none" } },
                React.createElement("g", { className: "interaction-regions" }, overlayRegions),
                semioticBrush)))));
    };
    InteractionLayer.defaultProps = {
        svgSize: [500, 500]
    };
    return InteractionLayer;
}(React.PureComponent));
exports.default = InteractionLayer;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_selection_1 = __webpack_require__(11);
var flatten = function (list) {
    return list.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b.sort(function (a, b) { return a - b; })) : b); }, []);
};
function flatShortArray(array) {
    if (!Array.isArray(array))
        return "not-array";
    if (!Array.isArray(array[0])) {
        array = array.sort(function (a, b) { return a - b; });
    }
    var flat = flatten(array);
    var stringifiedFlattened = flat
        .map(function (d) {
        return (d instanceof Date && d.toString()) ||
            (d !== undefined && d.toFixed && d.toFixed(2)) ||
            "empty";
    })
        .toString();
    return stringifiedFlattened;
}
var Brush = /** @class */ (function (_super) {
    __extends(Brush, _super);
    function Brush(props) {
        var _this = _super.call(this, props) || this;
        _this.node = null;
        _this.createBrush = _this.createBrush.bind(_this);
        return _this;
    }
    Brush.prototype.componentDidMount = function () {
        this.createBrush();
    };
    Brush.prototype.componentDidUpdate = function (lastProps) {
        var _a = this.props, extent = _a.extent, selectedExtent = _a.selectedExtent;
        if ((lastProps.extent &&
            extent &&
            flatShortArray(lastProps.extent) !== flatShortArray(extent)) ||
            (lastProps.selectedExtent &&
                selectedExtent &&
                flatShortArray(lastProps.selectedExtent) !==
                    flatShortArray(selectedExtent)) ||
            (!lastProps.selectedExtent && selectedExtent) ||
            (lastProps.selectedExtent && !selectedExtent)) {
            this.createBrush();
        }
    };
    Brush.prototype.createBrush = function () {
        var node = this.node;
        var _a = this.props, brush = _a.svgBrush, baseSelectedExtent = _a.selectedExtent;
        d3_selection_1.select(node).call(brush);
        if (baseSelectedExtent) {
            var selectedExtent = baseSelectedExtent;
            if (Array.isArray(baseSelectedExtent[0])) {
                var sortedY = [selectedExtent[0][1], selectedExtent[1][1]].sort(function (a, b) { return a - b; });
                selectedExtent = [
                    [selectedExtent[0][0], sortedY[0]],
                    [selectedExtent[1][0], sortedY[1]]
                ];
            }
            d3_selection_1.select(node).call(brush.move, selectedExtent);
        }
    };
    Brush.prototype.render = function () {
        var _this = this;
        var _a = this.props.position, position = _a === void 0 ? [0, 0] : _a;
        return (React.createElement("g", { transform: "translate(" + position + ")", ref: function (node) { return (_this.node = node); }, className: "xybrush" }));
    };
    return Brush;
}(React.Component));
exports.default = Brush;


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return piecewise; });
function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var renderQueue = function (func) {
    var _queue = [], // data to be rendered
    _rate = 1000, // number of calls per frame
    _invalidate = function () { }, // invalidate last render queue
    _clear = function () { }; // clearing function
    // type RenderQueueType = { (): (data: any) => void, render?: Function, invalidate?: Function, data?: Function}
    var rq = function (data) {
        if (data)
            rq.data(data);
        _invalidate();
        _clear();
        rq.render();
    };
    rq.render = function () {
        var valid = true;
        _invalidate = rq.invalidate = function () {
            valid = false;
        };
        function doFrame() {
            if (!valid)
                return true;
            var chunk = _queue.splice(0, _rate);
            chunk.map(func);
            timer_frame(doFrame);
        }
        doFrame();
    };
    rq.data = function (data) {
        _invalidate();
        _queue = data.slice(0); // creates a copy of the data
        return rq;
    };
    rq.add = function (data) {
        _queue = _queue.concat(data);
    };
    rq.rate = function (value) {
        if (!arguments.length)
            return _rate;
        _rate = value;
        return rq;
    };
    rq.remaining = function () {
        return _queue.length;
    };
    // clear the canvas
    rq.clear = function (func) {
        if (!arguments.length) {
            _clear();
            return rq;
        }
        _clear = func;
        return rq;
    };
    rq.invalidate = _invalidate;
    var timer_frame = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        function (callback) {
            setTimeout(callback, 17);
        };
    return rq;
};
var updateVisualizationLayer = function (props, handleKeyDown) {
    var xScale = props.xScale, yScale = props.yScale, dataVersion = props.dataVersion, projectedCoordinateNames = props.projectedCoordinateNames, _a = props.renderPipeline, renderPipeline = _a === void 0 ? {} : _a, _b = props.baseMarkProps, baseMarkProps = _b === void 0 ? {} : _b, _c = props.renderOrder, renderOrder = _c === void 0 ? [] : _c, sketchyRenderingEngine = props.sketchyRenderingEngine;
    var canvasDrawing = [];
    var piecesGroup = {};
    var renderedElements = [];
    var renderVizKeys = Object.keys(renderPipeline);
    var renderKeys = renderOrder.concat(renderVizKeys.filter(function (d) { return renderOrder.indexOf(d) === -1; }));
    renderKeys.forEach(function (k) {
        var pipe = renderPipeline[k];
        if (pipe &&
            ((pipe.data &&
                typeof pipe.data === "object" &&
                !Array.isArray(pipe.data)) ||
                (pipe.data && pipe.data.length > 0))) {
            var additionalMarkProps = {
                sketchyGenerator: sketchyRenderingEngine && sketchyRenderingEngine.generator,
                "aria-label": (pipe.ariaLabel && pipe.ariaLabel.items) || "dataviz-element",
                role: "img",
                tabIndex: -1
            };
            var renderedPipe = pipe.behavior(__assign({ xScale: xScale,
                yScale: yScale,
                canvasDrawing: canvasDrawing,
                projectedCoordinateNames: projectedCoordinateNames, baseMarkProps: __assign(__assign({}, baseMarkProps), additionalMarkProps) }, pipe));
            if (renderedPipe && renderedPipe.length > 0) {
                renderedElements.push(React.createElement("g", { key: k, className: k, role: "group", tabIndex: 0, "aria-label": (pipe.ariaLabel &&
                        renderedPipe.length + " " + pipe.ariaLabel.items + "s in a " + pipe.ariaLabel.chart) ||
                        k, onKeyDown: function (e) { return handleKeyDown(e, k); }, onBlur: function () {
                        props.voronoiHover(undefined);
                    }, ref: function (thisNode) { return thisNode && (piecesGroup[k] = thisNode.childNodes); } }, renderedPipe));
            }
        }
    });
    return {
        renderedElements: renderedElements,
        dataVersion: dataVersion,
        canvasDrawing: canvasDrawing,
        piecesGroup: piecesGroup
    };
};
var VisualizationLayer = /** @class */ (function (_super) {
    __extends(VisualizationLayer, _super);
    function VisualizationLayer(props) {
        var _this = _super.call(this, props) || this;
        _this.renderCanvas = function (context, margin, np, sketchyRenderingEngine, rc) { return function (piece) {
            var style = piece.styleFn
                ? piece.styleFn(__assign(__assign({}, piece.d), piece.d.data), piece.i) || {}
                : {
                    fill: "black",
                    stroke: "black",
                    opacity: 1,
                    fillOpacity: 1,
                    strokeOpacity: 1,
                    strokeWidth: 1
                };
            var fill = style.fill ? style.fill : "black";
            var stroke = style.stroke ? style.stroke : "black";
            context.setTransform(1, 0, 0, 1, margin.left, margin.top);
            context.translate.apply(context, __spread(np.position));
            context.translate(piece.tx, piece.ty);
            context.fillStyle = fill;
            context.strokeStyle = stroke;
            context.lineWidth = style.strokeWidth ? style.strokeWidth : 0;
            var rcSettings = {};
            var renderObject = piece.markProps.renderMode ||
                (piece.renderFn &&
                    piece.renderFn(__assign(__assign({}, piece.d), piece.d.data), piece.i));
            var actualRenderMode = (renderObject && renderObject.renderMode) || renderObject;
            if (actualRenderMode) {
                if (!sketchyRenderingEngine) {
                    console.error("You cannot render sketchy graphics without specifying a Rough.js-like library as the sketchyRenderingEngine prop of your frame");
                    actualRenderMode = undefined;
                }
                else {
                    var RoughCanvas = sketchyRenderingEngine.canvas;
                    if (!RoughCanvas) {
                        console.error("The sketchyRenderingEngine you specify does not expose a prop `RoughCanvas` and so cannot render sketchy HTML5 Canvas graphics");
                    }
                    else {
                        rc = rc || RoughCanvas(np.canvasContext);
                        var rcExtension = (typeof renderObject === "object" && renderObject) || {};
                        rcSettings = __assign({ fill: fill,
                            stroke: stroke, strokeWidth: context.lineWidth }, rcExtension);
                    }
                }
            }
            if (piece.markProps.markType === "circle" ||
                (piece.markProps.markType === "rect" && piece.markProps.rx > 0)) {
                var vizX = 0, vizY = 0, r = style.r || piece.markProps.r;
                if (piece.markProps.width) {
                    var halfWidth = piece.markProps.width / 2;
                    vizX = piece.markProps.x + halfWidth;
                    vizY = piece.markProps.y + halfWidth;
                    r = halfWidth;
                }
                if (actualRenderMode === "sketchy") {
                    if (context.globalAlpha !== 0)
                        rc.circle(vizX, vizY, r, rcSettings);
                }
                else {
                    context.beginPath();
                    context.arc(vizX, vizY, r, 0, 2 * Math.PI);
                    context.globalAlpha = style.fillOpacity || style.opacity || 1;
                    if (style.fill && style.fill !== "none" && context.globalAlpha !== 0)
                        context.fill();
                    context.globalAlpha = style.strokeOpacity || style.opacity || 1;
                    if (style.stroke &&
                        style.stroke !== "none" &&
                        context.globalAlpha !== 0)
                        context.stroke();
                }
            }
            else if (piece.markProps.markType === "rect") {
                if (actualRenderMode === "sketchy") {
                    context.globalAlpha = style.opacity || 1;
                    if (context.globalAlpha !== 0)
                        rc.rectangle(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height, rcSettings);
                }
                else {
                    context.globalAlpha = style.fillOpacity || style.opacity || 1;
                    if (style.fill && style.fill !== "none" && context.globalAlpha !== 0)
                        context.fillRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
                    context.globalAlpha = style.strokeOpacity || style.opacity || 1;
                    if (style.stroke &&
                        style.stroke !== "none" &&
                        context.globalAlpha !== 0)
                        context.strokeRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
                }
            }
            else if (piece.markProps.markType === "path") {
                if (actualRenderMode === "sketchy") {
                    context.globalAlpha = style.opacity || 1;
                    rc.path(piece.markProps.d, rcSettings);
                }
                else {
                    var p = new Path2D(piece.markProps.d);
                    context.globalAlpha = style.strokeOpacity || style.opacity || 1;
                    if (style.stroke &&
                        style.stroke !== "none" &&
                        context.globalAlpha !== 0)
                        context.stroke(p);
                    context.globalAlpha = style.fillOpacity || style.opacity || 1;
                    if (style.fill && style.fill !== "none" && context.globalAlpha !== 0)
                        context.fill(p);
                }
            }
            else {
                console.error("CURRENTLY UNSUPPORTED MARKTYPE FOR CANVAS RENDERING");
            }
        }; };
        _this.queuedCanvasRender = renderQueue(function () { });
        _this.handleKeyDown = function (e, vizgroup) {
            // If enter, focus on the first element
            var _a = _this.props, renderPipeline = _a.renderPipeline, voronoiHover = _a.voronoiHover;
            var pushed = e.keyCode;
            if (pushed !== 37 && pushed !== 39 && pushed !== 13)
                return;
            var newPieceIndex = 0;
            var vizGroupSetting = {};
            // If a user pressed enter, highlight the first one
            // Let a user move up and down in stacked bar by getting keys of bars?
            if (_this.state.focusedPieceIndex === null || pushed === 13) {
                vizGroupSetting.focusedVisualizationGroup = vizgroup;
            }
            else if (pushed === 37) {
                newPieceIndex = _this.state.focusedPieceIndex - 1;
            }
            else if (pushed === 39) {
                newPieceIndex = _this.state.focusedPieceIndex + 1;
            }
            newPieceIndex =
                newPieceIndex < 0
                    ? _this.state.piecesGroup[vizgroup].length + newPieceIndex
                    : newPieceIndex % _this.state.piecesGroup[vizgroup].length;
            var piece = renderPipeline[vizgroup].accessibleTransform(renderPipeline[vizgroup].data, newPieceIndex, _this.state.piecesGroup[vizgroup][newPieceIndex]);
            voronoiHover(piece);
            _this.setState(__assign({ focusedPieceIndex: newPieceIndex }, vizGroupSetting));
        };
        _this.state = __assign({ canvasDrawing: [], dataVersion: "", renderedElements: [], focusedPieceIndex: null, focusedVisualizationGroup: null, piecesGroup: {}, props: props, handleKeyDown: _this.handleKeyDown }, updateVisualizationLayer(props, _this.handleKeyDown));
        return _this;
    }
    VisualizationLayer.prototype.componentDidUpdate = function (lp) {
        var np = this.props;
        var propKeys = Object.keys(np);
        var update = false;
        propKeys.forEach(function (key) {
            if (key !== "title" && lp[key] !== np[key]) {
                update = true;
            }
        });
        if (update === false || np.disableContext || !np.canvasContext)
            return;
        var sketchyRenderingEngine = np.sketchyRenderingEngine, width = np.width, height = np.height, margin = np.margin;
        var size = [
            width + margin.left + margin.right,
            height + margin.top + margin.bottom
        ];
        var rc;
        var devicePixelRatio = window.devicePixelRatio || 1;
        np.canvasContext.width = size[0] * devicePixelRatio;
        np.canvasContext.height = size[1] * devicePixelRatio;
        np.canvasContext.style.width = size[0];
        np.canvasContext.style.height = size[1];
        var context = np.canvasContext.getContext("2d");
        context.scale(devicePixelRatio, devicePixelRatio);
        context.setTransform(1, 0, 0, 1, margin.left, margin.top);
        context.clearRect(-margin.left, -margin.top, size[0], size[1]);
        this.queuedCanvasRender.invalidate();
        this.queuedCanvasRender.clear();
        this.queuedCanvasRender = renderQueue(this.renderCanvas(context, margin, np, sketchyRenderingEngine, rc)).clear(function () {
            context.clearRect(-margin.left, -margin.top, size[0], size[1]);
        });
        this.queuedCanvasRender(this.state.canvasDrawing);
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.globalAlpha = 1;
        if (np.canvasPostProcess) {
            np.canvasPostProcess(np.canvasContext, context, size);
        }
        if (this.state.focusedVisualizationGroup !== null &&
            this.state.piecesGroup[this.state.focusedVisualizationGroup] &&
            this.state.focusedPieceIndex !== null) {
            var focusElParent = this.state.piecesGroup[this.state.focusedVisualizationGroup][this.state.focusedPieceIndex];
            var focusEl = (focusElParent &&
                __spread(focusElParent.childNodes).find(function (child) {
                    return child.getAttribute("aria-label");
                })) ||
                focusElParent;
            focusEl && focusEl.focus && focusEl.focus();
        }
    };
    VisualizationLayer.getDerivedStateFromProps = function (nextProps, prevState) {
        var props = prevState.props;
        var lp = props;
        var propKeys = Object.keys(nextProps);
        var update = false;
        propKeys.forEach(function (key) {
            if (key !== "title" && lp[key] !== nextProps[key]) {
                update = true;
            }
        });
        if (update ||
            (nextProps.dataVersion && nextProps.dataVersion !== prevState.dataVersion)) {
            return __assign(__assign({}, updateVisualizationLayer(nextProps, prevState.handleKeyDown)), { props: nextProps });
        }
        return null;
    };
    VisualizationLayer.prototype.render = function () {
        var _a;
        var _b = this.props, matte = _b.matte, matteClip = _b.matteClip, axes = _b.axes, _c = _b.frameKey, frameKey = _c === void 0 ? "" : _c, margin = _b.margin, title = _b.title, ariaTitle = _b.ariaTitle, axesTickLines = _b.axesTickLines, frameRenderOrder = _b.frameRenderOrder, additionalVizElements = _b.additionalVizElements;
        var renderedElements = this.state.renderedElements;
        var renderHash = __assign((_a = {}, _a["axes-tick-lines"] = axesTickLines && (React.createElement("g", { key: "visualization-tick-lines", className: "axis axis-tick-lines", "aria-hidden": true }, axesTickLines)), _a["axes-labels"] = axes && (React.createElement("g", { key: "visualization-axis-labels", className: "axis axis-labels" }, axes)), _a.matte = matte, _a["viz-layer"] = renderedElements && renderedElements.length > 0
            ? renderedElements
            : null, _a), additionalVizElements);
        var ariaLabel = "";
        var finalTitle = (title && ariaTitle) || title
            ? typeof title !== "string" &&
                title.props &&
                typeof title.props.children === "string"
                ? "titled " + title.props.children
                : "with a complex title"
            : "with no title";
        ariaLabel = "Visualization " + finalTitle + ". Use arrow keys to navigate elements.";
        var orderedElements = [];
        frameRenderOrder.forEach(function (r) {
            if (renderHash[r]) {
                orderedElements.push(renderHash[r]);
            }
        });
        var renderedDataVisualization = (orderedElements.length > 0 && (React.createElement("g", { className: "data-visualization", key: "visualization-clip-path", "aria-label": ariaLabel, role: "group", clipPath: matteClip && matte ? "url(#matte-clip" + frameKey + ")" : undefined, transform: "translate(" + margin.left + "," + margin.top + ")" }, orderedElements))) ||
            null;
        return renderedDataVisualization;
    };
    VisualizationLayer.defaultProps = {
        position: [0, 0],
        margin: { left: 0, top: 0, right: 0, bottom: 0 }
    };
    return VisualizationLayer;
}(React.PureComponent));
exports.default = VisualizationLayer;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutRect;

var _SubjectRect = _interopRequireDefault(__webpack_require__(277));

var _ConnectorElbow = _interopRequireDefault(__webpack_require__(67));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutRect(props) {
  var className = (0, _classnames.default)("callout rect", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectRect.default, {
    width: 100,
    height: 100
  });
}

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationXYThreshold;

var _SubjectThreshold = _interopRequireDefault(__webpack_require__(279));

var _ConnectorElbow = _interopRequireDefault(__webpack_require__(67));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationXYThreshold(props) {
  var className = (0, _classnames.default)("callout xythreshold", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectThreshold.default);
}

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = { 
  NORMAL:               0, 
  NON_CONTRIBUTING:     1, 
  SAME_TRANSITION:      2, 
  DIFFERENT_TRANSITION: 3
};


/***/ }),
/* 175 */
/***/ (function(module, exports) {


function TreeBase() {}

// removes all nodes from the tree
TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
};

// returns node data if found, null otherwise
TreeBase.prototype.find = function(data) {
    var res = this._root;

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            return res.data;
        }
        else {
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// returns iterator to node if found, null otherwise
TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();

    while(res !== null) {
        var c = this._comparator(data, res.data);
        if(c === 0) {
            iter._cursor = res;
            return iter;
        }
        else {
            iter._ancestors.push(res);
            res = res.get_child(c > 0);
        }
    }

    return null;
};

// Returns an iterator to the tree node at or immediately after the item
TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;

    while(cur !== null) {
        var c = cmp(item, cur.data);
        if(c === 0) {
            iter._cursor = cur;
            return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
    }

    for(var i=iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if(cmp(item, cur.data) < 0) {
            iter._cursor = cur;
            iter._ancestors.length = i;
            return iter;
        }
    }

    iter._ancestors.length = 0;
    return iter;
};

// Returns an iterator to the tree node immediately after the item
TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;

    while(iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
    }

    return iter;
};

// returns null if tree is empty
TreeBase.prototype.min = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.left !== null) {
        res = res.left;
    }

    return res.data;
};

// returns null if tree is empty
TreeBase.prototype.max = function() {
    var res = this._root;
    if(res === null) {
        return null;
    }

    while(res.right !== null) {
        res = res.right;
    }

    return res.data;
};

// returns a null iterator
// call next() or prev() to point to an element
TreeBase.prototype.iterator = function() {
    return new Iterator(this);
};

// calls cb on each node's data, in order
TreeBase.prototype.each = function(cb) {
    var it=this.iterator(), data;
    while((data = it.next()) !== null) {
        if(cb(data) === false) {
            return;
        }
    }
};

// calls cb on each node's data, in reverse order
TreeBase.prototype.reach = function(cb) {
    var it=this.iterator(), data;
    while((data = it.prev()) !== null) {
        if(cb(data) === false) {
            return;
        }
    }
};


function Iterator(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
}

Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns first node
// otherwise, returns next node
Iterator.prototype.next = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._minNode(root);
        }
    }
    else {
        if(this._cursor.right === null) {
            // no greater node in subtree, go up to parent
            // if coming from a right child, continue up the stack
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.right === save);
        }
        else {
            // get the next node from the subtree
            this._ancestors.push(this._cursor);
            this._minNode(this._cursor.right);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

// if null-iterator, returns last node
// otherwise, returns previous node
Iterator.prototype.prev = function() {
    if(this._cursor === null) {
        var root = this._tree._root;
        if(root !== null) {
            this._maxNode(root);
        }
    }
    else {
        if(this._cursor.left === null) {
            var save;
            do {
                save = this._cursor;
                if(this._ancestors.length) {
                    this._cursor = this._ancestors.pop();
                }
                else {
                    this._cursor = null;
                    break;
                }
            } while(this._cursor.left === save);
        }
        else {
            this._ancestors.push(this._cursor);
            this._maxNode(this._cursor.left);
        }
    }
    return this._cursor !== null ? this._cursor.data : null;
};

Iterator.prototype._minNode = function(start) {
    while(start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
    }
    this._cursor = start;
};

Iterator.prototype._maxNode = function(start) {
    while(start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
    }
    this._cursor = start;
};

module.exports = TreeBase;



/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var signedArea = __webpack_require__(126);
// var equals = require('./equals');

/**
 * @param  {SweepEvent} e1
 * @param  {SweepEvent} e2
 * @return {Number}
 */
module.exports = function sweepEventsComp(e1, e2) {
  var p1 = e1.point;
  var p2 = e2.point;

  // Different x-coordinate
  if (p1[0] > p2[0]) return 1;
  if (p1[0] < p2[0]) return -1;

  // Different points, but same x-coordinate
  // Event with lower y-coordinate is processed first
  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;

  return specialCases(e1, e2, p1, p2);
};


function specialCases(e1, e2, p1, p2) {
  // Same coordinates, but one is a left endpoint and the other is
  // a right endpoint. The right endpoint is processed first
  if (e1.left !== e2.left)
    return e1.left ? 1 : -1;

  // Same coordinates, both events
  // are left endpoints or right endpoints.
  // not collinear
  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
    // the event associate to the bottom segment is processed first
    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;
  }

  // uncomment this if you want to play with multipolygons
  // if (e1.isSubject === e2.isSubject) {
  //   if(equals(e1.point, e2.point) && e1.contourId === e2.contourId) {
  //     return 0;
  //   } else {
  //     return e1.contourId > e2.contourId ? 1 : -1;
  //   }
  // }

  return (!e1.isSubject && e2.isSubject) ? 1 : -1;
}


/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.extentValue = function (extent) {
    return (extent && extent.extent) || (Array.isArray(extent) && extent) || [];
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(307);

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// combine 2 matrixes
// m1, m2 - [a, b, c, d, e, g]
//
function combine(m1, m2) {
  return [
    m1[0] * m2[0] + m1[2] * m2[1],
    m1[1] * m2[0] + m1[3] * m2[1],
    m1[0] * m2[2] + m1[2] * m2[3],
    m1[1] * m2[2] + m1[3] * m2[3],
    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
  ];
}


function Matrix() {
  if (!(this instanceof Matrix)) { return new Matrix(); }
  this.queue = [];   // list of matrixes to apply
  this.cache = null; // combined matrix cache
}


Matrix.prototype.matrix = function (m) {
  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
    return this;
  }
  this.cache = null;
  this.queue.push(m);
  return this;
};


Matrix.prototype.translate = function (tx, ty) {
  if (tx !== 0 || ty !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, 0, 1, tx, ty ]);
  }
  return this;
};


Matrix.prototype.scale = function (sx, sy) {
  if (sx !== 1 || sy !== 1) {
    this.cache = null;
    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);
  }
  return this;
};


Matrix.prototype.rotate = function (angle, rx, ry) {
  var rad, cos, sin;

  if (angle !== 0) {
    this.translate(rx, ry);

    rad = angle * Math.PI / 180;
    cos = Math.cos(rad);
    sin = Math.sin(rad);

    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);
    this.cache = null;

    this.translate(-rx, -ry);
  }
  return this;
};


Matrix.prototype.skewX = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);
  }
  return this;
};


Matrix.prototype.skewY = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);
  }
  return this;
};


// Flatten queue
//
Matrix.prototype.toArray = function () {
  if (this.cache) {
    return this.cache;
  }

  if (!this.queue.length) {
    this.cache = [ 1, 0, 0, 1, 0, 0 ];
    return this.cache;
  }

  this.cache = this.queue[0];

  if (this.queue.length === 1) {
    return this.cache;
  }

  for (var i = 1; i < this.queue.length; i++) {
    this.cache = combine(this.cache, this.queue[i]);
  }

  return this.cache;
};


// Apply list of matrixes to (x,y) point.
// If `isRelative` set, `translate` component of matrix will be skipped
//
Matrix.prototype.calc = function (x, y, isRelative) {
  var m;

  // Don't change point on empty transforms queue
  if (!this.queue.length) { return [ x, y ]; }

  // Calculate final matrix, if not exists
  //
  // NB. if you deside to apply transforms to point one-by-one,
  // they should be taken in reverse order

  if (!this.cache) {
    this.cache = this.toArray();
  }

  m = this.cache;

  // Apply matrix to point
  return [
    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),
    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])
  ];
};


module.exports = Matrix;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
// components
var XYFrame_1 = __importDefault(__webpack_require__(70));
var MiniMap_1 = __importDefault(__webpack_require__(182));
var MinimapXYFrame = /** @class */ (function (_super) {
    __extends(MinimapXYFrame, _super);
    function MinimapXYFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.generateMinimap = _this.generateMinimap.bind(_this);
        return _this;
    }
    MinimapXYFrame.prototype.generateMinimap = function () {
        var _a = this.props, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor, points = _a.points, lines = _a.lines, minimap = _a.minimap, summaries = _a.summaries, size = _a.size, lineDataAccessor = _a.lineDataAccessor, lineType = _a.lineType, lineStyle = _a.lineStyle, summaryStyle = _a.summaryStyle, pointStyle = _a.pointStyle, lineClass = _a.lineClass, summaryClass = _a.summaryClass, pointClass = _a.pointClass, lineRenderMode = _a.lineRenderMode, pointRenderMode = _a.pointRenderMode, summaryRenderMode = _a.summaryRenderMode, canvasLines = _a.canvasLines, canvasPoints = _a.canvasPoints, canvasSummaries = _a.canvasSummaries, axes = _a.axes, margin = _a.margin, useSpans = _a.useSpans, name = _a.name, annotations = _a.annotations, summaryType = _a.summaryType, interactionSettings = _a.interactionSettings;
        var miniDefaults = {
            position: [0, 0],
            size: [size[0], size[1] * 0.25],
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            points: points,
            lines: lines,
            summaries: summaries,
            lineDataAccessor: lineDataAccessor,
            xBrushable: true,
            yBrushable: true,
            brushStart: function () { },
            brush: function () { },
            brushEnd: function () { },
            lineType: lineType,
            lineStyle: lineStyle,
            summaryStyle: summaryStyle,
            pointStyle: pointStyle,
            lineClass: lineClass,
            summaryClass: summaryClass,
            pointClass: pointClass,
            lineRenderMode: lineRenderMode,
            pointRenderMode: pointRenderMode,
            summaryRenderMode: summaryRenderMode,
            canvasLines: canvasLines,
            canvasPoints: canvasPoints,
            canvasSummaries: canvasSummaries,
            axes: axes,
            margin: margin,
            useSpans: useSpans,
            name: name,
            annotations: annotations,
            summaryType: summaryType,
            interactionSettings: interactionSettings
        };
        var combinedOptions = __assign(__assign(__assign({}, miniDefaults), minimap), { hoverAnnotation: false });
        return React.createElement(MiniMap_1.default, __assign({}, combinedOptions));
    };
    MinimapXYFrame.prototype.render = function () {
        var miniMap = this.generateMinimap();
        var options = {};
        var _a = this.props, minimap = _a.minimap, renderBefore = _a.renderBefore, rest = __rest(_a, ["minimap", "renderBefore"]);
        if (renderBefore) {
            options.beforeElements = miniMap;
        }
        else {
            options.afterElements = miniMap;
        }
        return React.createElement(XYFrame_1.default, __assign({}, rest, options));
    };
    MinimapXYFrame.displayName = "MinimapXYFrame";
    return MinimapXYFrame;
}(React.Component));
exports.default = MinimapXYFrame;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var XYFrame_1 = __importDefault(__webpack_require__(70));
var MiniMap = function (props) {
    var brushStart = props.brushStart, brush = props.brush, brushEnd = props.brushEnd, xBrushable = props.xBrushable, yBrushable = props.yBrushable, yBrushExtent = props.yBrushExtent, xBrushExtent = props.xBrushExtent, rest = __rest(props, ["brushStart", "brush", "brushEnd", "xBrushable", "yBrushable", "yBrushExtent", "xBrushExtent"]);
    var interactivity = {
        start: brushStart,
        during: brush,
        end: brushEnd
    };
    if (xBrushable && yBrushable) {
        interactivity.brush = "xyBrush";
        if (xBrushExtent || yBrushExtent) {
            interactivity.extent = [[0, 0], __spread(props.size)];
        }
        if (xBrushExtent) {
            interactivity.extent[0] = xBrushExtent;
        }
        if (yBrushExtent) {
            interactivity.extent[1] = yBrushExtent;
        }
    }
    else if (xBrushable) {
        interactivity.brush = "xBrush";
        if (xBrushExtent) {
            interactivity.extent = xBrushExtent;
        }
    }
    else if (yBrushable) {
        interactivity.brush = "yBrush";
        if (yBrushExtent) {
            interactivity.extent = yBrushExtent;
        }
    }
    return React.createElement(XYFrame_1.default, __assign({}, rest, { interaction: interactivity }));
};
exports.default = MiniMap;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_force_1 = __webpack_require__(226);
var d3_scale_1 = __webpack_require__(24);
var d3_array_1 = __webpack_require__(3);
var AnnotationLabel_1 = __importDefault(__webpack_require__(160));
var frameFunctions_1 = __webpack_require__(33);
var pieceDrawing_1 = __webpack_require__(84);
var svg_path_bounding_box_1 = __importDefault(__webpack_require__(179));
var dataFunctions_1 = __webpack_require__(52);
var networkDrawing_1 = __webpack_require__(318);
var d3_sankey_circular_1 = __webpack_require__(320);
var d3_chord_1 = __webpack_require__(513);
var d3_shape_1 = __webpack_require__(18);
var d3_hierarchy_1 = __webpack_require__(98);
var functions_1 = __webpack_require__(129);
function determineNodeIcon(baseCustomNodeIcon, networkSettings, size, nodes) {
    if (baseCustomNodeIcon)
        return baseCustomNodeIcon;
    var center = [size[0] / 2, size[1] / 2];
    switch (networkSettings.type) {
        case "sankey":
            return networkDrawing_1.sankeyNodeGenerator;
        case "partition":
            return networkSettings.projection === "radial"
                ? networkDrawing_1.radialRectNodeGenerator(size, center, networkSettings)
                : networkDrawing_1.hierarchicalRectNodeGenerator;
        case "treemap":
            return networkSettings.projection === "radial"
                ? networkDrawing_1.radialRectNodeGenerator(size, center, networkSettings)
                : networkDrawing_1.hierarchicalRectNodeGenerator;
        case "circlepack":
            return networkDrawing_1.circleNodeGenerator;
        case "chord":
            return networkDrawing_1.chordNodeGenerator(size);
        case "dagre":
            return networkDrawing_1.hierarchicalRectNodeGenerator;
        case "matrix":
            return networkDrawing_1.matrixNodeGenerator(size, nodes);
    }
    return networkDrawing_1.circleNodeGenerator;
}
function determineEdgeIcon(_a) {
    var baseCustomEdgeIcon = _a.baseCustomEdgeIcon, networkSettings = _a.networkSettings, size = _a.size, graph = _a.graph, nodes = _a.nodes;
    if (baseCustomEdgeIcon)
        return baseCustomEdgeIcon;
    switch (networkSettings.type) {
        case "partition":
            return function () { return null; };
        case "treemap":
            return function () { return null; };
        case "circlepack":
            return function () { return null; };
        case "chord":
            return networkDrawing_1.chordEdgeGenerator(size);
        case "matrix":
            return networkDrawing_1.matrixEdgeGenerator(size, nodes);
        case "arc":
            return networkDrawing_1.arcEdgeGenerator(size);
        case "dagre":
            if (graph)
                return networkDrawing_1.dagreEdgeGenerator(graph.graph().rankdir);
    }
    return undefined;
}
var basicMiddle = function (d) { return ({
    edge: d,
    x: (d.source.x + d.target.x) / 2,
    y: (d.source.y + d.target.y) / 2
}); };
var edgePointHash = {
    sankey: function (d) { return ({
        edge: d,
        x: (d.source.x1 + d.target.x0) / 2,
        y: d.circularPathData
            ? d.circularPathData.verticalFullExtent
            : ((d.y0 + d.y1) / 2 + (d.y0 + d.y1) / 2) / 2
    }); },
    force: basicMiddle,
    tree: basicMiddle,
    cluster: basicMiddle
};
var hierarchicalTypeHash = {
    dendrogram: d3_hierarchy_1.tree,
    tree: d3_hierarchy_1.tree,
    circlepack: d3_hierarchy_1.pack,
    cluster: d3_hierarchy_1.cluster,
    treemap: d3_hierarchy_1.treemap,
    partition: d3_hierarchy_1.partition
};
var hierarchicalProjectable = {
    partition: true,
    cluster: true,
    tree: true,
    dendrogram: true
};
var radialProjectable = {
    partition: true,
    cluster: true,
    tree: true,
    dendrogram: true
};
var sankeyOrientHash = {
    left: d3_sankey_circular_1.sankeyLeft,
    right: d3_sankey_circular_1.sankeyRight,
    center: d3_sankey_circular_1.sankeyCenter,
    justify: d3_sankey_circular_1.sankeyJustify
};
function breadthFirstCompontents(baseNodes, hash) {
    var componentHash = {
        "0": { componentNodes: [], componentEdges: [] }
    };
    var components = [componentHash["0"]];
    var componentID = 0;
    traverseNodesBF(baseNodes, true);
    function traverseNodesBF(nodes, top) {
        nodes.forEach(function (node) {
            var _a;
            var hashNode = hash.get(node);
            if (!hashNode) {
                componentHash["0"].componentNodes.push(node);
            }
            else if (hashNode.component === -99) {
                if (top === true) {
                    componentID++;
                    componentHash[componentID] = {
                        componentNodes: [],
                        componentEdges: []
                    };
                    components.push(componentHash[componentID]);
                }
                hashNode.component = componentID;
                componentHash[componentID].componentNodes.push(node);
                (_a = componentHash[componentID].componentEdges).push.apply(_a, __spread(hashNode.edges));
                var traversibleNodes = __spread(hashNode.connectedNodes);
                traverseNodesBF(traversibleNodes, hash);
            }
        });
    }
    return components.sort(function (a, b) { return b.componentNodes.length - a.componentNodes.length; });
}
var matrixify = function (_a) {
    var edgeHash = _a.edgeHash, nodes = _a.nodes, edgeWidthAccessor = _a.edgeWidthAccessor, nodeIDAccessor = _a.nodeIDAccessor;
    var matrix = [];
    nodes.forEach(function (nodeSource) {
        var nodeSourceID = nodeIDAccessor(nodeSource);
        var sourceRow = [];
        matrix.push(sourceRow);
        nodes.forEach(function (nodeTarget) {
            var nodeTargetID = nodeIDAccessor(nodeTarget);
            var theEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
            if (theEdge) {
                sourceRow.push(edgeWidthAccessor(theEdge));
            }
            else {
                sourceRow.push(0);
            }
        });
    });
    return matrix;
};
var emptyArray = [];
var baseNodeProps = {
    id: undefined,
    degree: 0,
    inDegree: 0,
    outDegree: 0,
    x: 0,
    y: 0,
    x1: 0,
    x0: 0,
    y1: 0,
    y0: 0,
    height: 0,
    width: 0,
    radius: 0,
    r: 0,
    direction: undefined,
    textHeight: 0,
    textWidth: 0,
    fontSize: 0,
    scale: 1,
    nodeSize: 0,
    component: -99,
    shapeNode: false
};
var baseNetworkSettings = {
    iterations: 500,
    hierarchicalNetwork: false
};
var baseGraphSettings = {
    nodeHash: new Map(),
    edgeHash: new Map(),
    nodes: [],
    edges: [],
    hierarchicalNetwork: false,
    type: "force"
};
function recursiveIDAccessor(idAccessor, node, accessorString) {
    if (node.parent) {
        accessorString = accessorString + "-" + recursiveIDAccessor(idAccessor, __assign(__assign({}, node.parent), node.parent.data), accessorString);
    }
    return accessorString + "-" + idAccessor(__assign(__assign({}, node), node.data));
}
exports.nodesEdgesFromHierarchy = function (baseRootNode, idAccessor) {
    if (idAccessor === void 0) { idAccessor = function (d) { return d.id || d.descendantIndex; }; }
    var edges = [];
    var nodes = [];
    var rootNode = baseRootNode.descendants
        ? baseRootNode
        : d3_hierarchy_1.hierarchy(baseRootNode);
    var descendants = rootNode.descendants();
    descendants.forEach(function (d, i) {
        d.descendantIndex = i;
    });
    descendants.forEach(function (node, i) {
        var generatedID = idAccessor(__assign(__assign({}, node), node.data)) + "-" + ((node.parent &&
            recursiveIDAccessor(idAccessor, __assign(__assign({}, node.parent), node.parent.data), "")) ||
            "root");
        var dataD = Object.assign(node, node.data || {}, {
            hierarchicalID: generatedID
        });
        nodes.push(dataD);
        if (node.parent !== null) {
            var dataParent = Object.assign(node.parent, node.parent.data || {});
            edges.push({
                source: dataParent,
                target: dataD,
                depth: node.depth,
                weight: 1,
                value: 1,
                _NWFEdgeKey: generatedID
            });
        }
    });
    return { edges: edges, nodes: nodes };
};
exports.calculateNetworkFrame = function (currentProps, prevState) {
    var graph = currentProps.graph, _a = currentProps.nodes, nodes = _a === void 0 ? Array.isArray(graph) || typeof graph === "function"
        ? emptyArray
        : (graph && graph.nodes) || emptyArray : _a, _b = currentProps.edges, edges = _b === void 0 ? typeof graph === "function"
        ? emptyArray
        : Array.isArray(graph)
            ? graph
            : (graph && graph.edges) || emptyArray : _b, networkType = currentProps.networkType, size = currentProps.size, nodeStyle = currentProps.nodeStyle, nodeClass = currentProps.nodeClass, canvasNodes = currentProps.canvasNodes, edgeStyle = currentProps.edgeStyle, edgeClass = currentProps.edgeClass, canvasEdges = currentProps.canvasEdges, nodeRenderMode = currentProps.nodeRenderMode, edgeRenderMode = currentProps.edgeRenderMode, nodeLabels = currentProps.nodeLabels, baseTitle = currentProps.title, baseMargin = currentProps.margin, hoverAnnotation = currentProps.hoverAnnotation, baseCustomNodeIcon = currentProps.customNodeIcon, baseCustomEdgeIcon = currentProps.customEdgeIcon, filterRenderedNodes = currentProps.filterRenderedNodes;
    var edgeType = currentProps.edgeType;
    var networkSettings;
    var nodeHierarchicalIDFill = {};
    var networkSettingsKeys = ["type"];
    if (typeof networkType === "string") {
        networkSettings = __assign(__assign({ type: networkType }, baseNetworkSettings), { graphSettings: baseGraphSettings });
    }
    else {
        if (networkType)
            networkSettingsKeys = Object.keys(networkType);
        networkSettings = __assign(__assign(__assign({ type: "force" }, baseNetworkSettings), networkType), { graphSettings: baseGraphSettings });
    }
    if (networkSettings.projection === "vertical" &&
        networkSettings.type === "sankey") {
        networkSettings.direction = "down";
    }
    networkSettingsKeys.push("height", "width");
    var title = typeof baseTitle === "object" &&
        !React.isValidElement(baseTitle) &&
        baseTitle !== null
        ? baseTitle
        : { title: baseTitle, orient: "top" };
    var margin = frameFunctions_1.calculateMargin({
        margin: baseMargin,
        title: title,
        size: size
    });
    var _c = frameFunctions_1.adjustedPositionSize({
        size: size,
        margin: margin
    }), adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize;
    networkSettings.graphSettings.nodes = nodes;
    networkSettings.graphSettings.edges = edges;
    networkSettings.graphSettings.filterRenderedNodes = filterRenderedNodes;
    var _d = networkSettings.graphSettings, edgeHash = _d.edgeHash, nodeHash = _d.nodeHash;
    var createPointLayer = networkSettings.type === "treemap" ||
        networkSettings.type === "partition" ||
        networkSettings.type === "sankey";
    var nodeIDAccessor = dataFunctions_1.stringToFn(currentProps.nodeIDAccessor, function (d) { return d.id; });
    var sourceAccessor = dataFunctions_1.stringToFn(currentProps.sourceAccessor, function (d) { return d.source; });
    var targetAccessor = dataFunctions_1.stringToFn(currentProps.targetAccessor, function (d) { return d.target; });
    var nodeSizeAccessor = typeof currentProps.nodeSizeAccessor === "number"
        ? functions_1.genericFunction(currentProps.nodeSizeAccessor)
        : dataFunctions_1.stringToFn(currentProps.nodeSizeAccessor, function (d) { return d.r || 5; });
    var edgeWidthAccessor = dataFunctions_1.stringToFn(currentProps.edgeWidthAccessor, function (d) { return d.weight || 1; });
    var nodeStyleFn = dataFunctions_1.stringToFn(nodeStyle, function () { return ({}); }, true);
    var nodeClassFn = dataFunctions_1.stringToFn(nodeClass, function () { return ""; }, true);
    var nodeRenderModeFn = dataFunctions_1.stringToFn(nodeRenderMode, undefined, true);
    var nodeCanvasRenderFn = canvasNodes && dataFunctions_1.stringToFn(canvasNodes, undefined, true);
    var projectedNodes = prevState.projectedNodes, projectedEdges = prevState.projectedEdges;
    var isHierarchical = typeof networkSettings.type === "string" &&
        hierarchicalTypeHash[networkSettings.type];
    var changedData = !prevState.projectedNodes ||
        !prevState.projectedEdges ||
        prevState.graphSettings.nodes !== nodes ||
        prevState.graphSettings.edges !== edges ||
        isHierarchical ||
        prevState.graphSettings.filterRenderedNodes !== filterRenderedNodes;
    if (networkSettings.type === "dagre") {
        var dagreGraph_1 = graph;
        var dagreNodeHash_1 = {};
        projectedNodes = dagreGraph_1.nodes().map(function (n) {
            var baseNode = dagreGraph_1.node(n);
            dagreNodeHash_1[n] = __assign(__assign({}, baseNode), { x0: baseNode.x - baseNode.width / 2, x1: baseNode.x + baseNode.width / 2, y0: baseNode.y - baseNode.height / 2, y1: baseNode.y + baseNode.height / 2, id: n, shapeNode: true, sourceLinks: [], targetLinks: [] });
            return dagreNodeHash_1[n];
        });
        projectedEdges = dagreGraph_1.edges().map(function (e) {
            var dagreEdge = dagreGraph_1.edge(e);
            var baseEdge = __assign(__assign({}, dagreEdge), { points: dagreEdge.points.map(function (d) { return (__assign({}, d)); }) });
            baseEdge.source = projectedNodes.find(function (p) { return p.id === e.v; });
            baseEdge.target = projectedNodes.find(function (p) { return p.id === e.w; });
            baseEdge.points.unshift({ x: baseEdge.source.x, y: baseEdge.source.y });
            baseEdge.points.push({ x: baseEdge.target.x, y: baseEdge.target.y });
            dagreNodeHash_1[e.v].targetLinks.push(baseEdge);
            dagreNodeHash_1[e.w].sourceLinks.push(baseEdge);
            return baseEdge;
        });
    }
    else if (changedData) {
        var previousNodes_1 = projectedNodes;
        edgeHash = new Map();
        nodeHash = new Map();
        networkSettings.graphSettings.edgeHash = edgeHash;
        networkSettings.graphSettings.nodeHash = nodeHash;
        projectedNodes = [];
        projectedEdges = [];
        var fixFunction_1 = typeof networkSettings.fixExistingNodes === "function" ? networkSettings.fixExistingNodes : networkSettings.fixExistingNodes ? function () { return true; } : false;
        nodes.forEach(function (node) {
            var projectedNode = __assign({}, node);
            var id = nodeIDAccessor(projectedNode);
            var existingNode = previousNodes_1.find(function (prevNode) { return prevNode.id === id; });
            var equivalentOldNode = existingNode || { x: undefined, y: undefined };
            nodeHash.set(id, projectedNode);
            nodeHash.set(node, projectedNode);
            projectedNodes.push(projectedNode);
            projectedNode.id = id;
            projectedNode.inDegree = 0;
            projectedNode.outDegree = 0;
            projectedNode.degree = 0;
            projectedNode.x = equivalentOldNode.x;
            projectedNode.y = equivalentOldNode.y;
            if (existingNode && fixFunction_1 && fixFunction_1(existingNode)) {
                projectedNode.fx = existingNode.x;
                projectedNode.fy = existingNode.y;
            }
        });
        var operationalEdges = edges;
        var baseEdges = edges;
        if (isHierarchical && Array.isArray(edges)) {
            var createdHierarchicalData = networkDrawing_1.softStack(edges, nodes, sourceAccessor, targetAccessor, nodeIDAccessor);
            if (createdHierarchicalData.isHierarchical) {
                baseEdges = createdHierarchicalData.hierarchy;
                projectedNodes = [];
            }
            else {
                console.error("You've sent an edge list that is not strictly hierarchical (there are nodes with multiple parents) defaulting to force-directed network layout");
                networkSettings.type = "force";
            }
        }
        if (!Array.isArray(baseEdges)) {
            networkSettings.hierarchicalNetwork = true;
            var rootNode = d3_hierarchy_1.hierarchy(baseEdges, networkSettings.hierarchyChildren);
            rootNode.sum(networkSettings.hierarchySum || (function (d) { return d.value; }));
            if (isHierarchical) {
                var layout = networkSettings.layout || isHierarchical;
                var hierarchicalLayout_1 = layout();
                var networkSettingKeys = Object.keys(networkSettings);
                if ((networkSettings.type === "dendrogram" ||
                    networkSettings.type === "tree" ||
                    networkSettings.type === "cluster") &&
                    hierarchicalLayout_1.separation) {
                    hierarchicalLayout_1.separation(function (a, b) {
                        return (nodeSizeAccessor(__assign(__assign({}, a), a.data)) || 1) +
                            (networkSettings.nodePadding || 0) +
                            (nodeSizeAccessor(__assign(__assign({}, b), b.data)) || 1);
                    });
                }
                networkSettingKeys.forEach(function (key) {
                    if (hierarchicalLayout_1[key]) {
                        hierarchicalLayout_1[key](networkSettings[key]);
                    }
                });
                var layoutSize = networkSettings.projection === "horizontal" && isHierarchical
                    ? [adjustedSize[1], adjustedSize[0]]
                    : adjustedSize;
                if (!networkSettings.nodeSize && hierarchicalLayout_1.size) {
                    hierarchicalLayout_1.size(layoutSize);
                }
                hierarchicalLayout_1(rootNode);
            }
            operationalEdges = exports.nodesEdgesFromHierarchy(rootNode, nodeIDAccessor)
                .edges;
        }
        baseNodeProps.shapeNode = createPointLayer;
        if (Array.isArray(operationalEdges)) {
            operationalEdges.forEach(function (edge) {
                var source = sourceAccessor(edge);
                var target = targetAccessor(edge);
                var sourceTarget = [source, target];
                sourceTarget.forEach(function (nodeDirection) {
                    if (!nodeHash.get(nodeDirection)) {
                        var nodeObject = typeof nodeDirection === "object"
                            ? __assign(__assign({}, baseNodeProps), nodeDirection) : __assign(__assign({}, baseNodeProps), { id: nodeDirection, createdByFrame: true });
                        var nodeIDValue = nodeObject.id || nodeIDAccessor(nodeObject);
                        nodeHierarchicalIDFill[nodeIDValue]
                            ? (nodeHierarchicalIDFill[nodeIDValue] += 1)
                            : (nodeHierarchicalIDFill[nodeIDValue] = 1);
                        if (!nodeObject.id) {
                            var nodeSuffix = nodeHierarchicalIDFill[nodeIDValue] === 1
                                ? ""
                                : "-" + nodeHierarchicalIDFill[nodeIDValue];
                            nodeObject.id = "" + nodeIDValue + nodeSuffix;
                        }
                        nodeHash.set(nodeDirection, nodeObject);
                        projectedNodes.push(nodeObject);
                    }
                });
                var edgeWeight = edge.weight || 1;
                var sourceNode = nodeHash.get(source);
                var targetNode = nodeHash.get(target);
                targetNode.inDegree += edgeWeight;
                sourceNode.outDegree += edgeWeight;
                targetNode.degree += edgeWeight;
                sourceNode.degree += edgeWeight;
                var edgeKey = (nodeIDAccessor(sourceNode) ||
                    source) + "|" + (nodeIDAccessor(targetNode) || target);
                var newEdge = Object.assign({}, edge, {
                    source: nodeHash.get(source),
                    target: nodeHash.get(target)
                });
                edgeHash.set(edgeKey, newEdge);
                projectedEdges.push(newEdge);
            });
        }
    }
    else {
        edgeHash = new Map();
        networkSettings.graphSettings.edgeHash = edgeHash;
        projectedEdges.forEach(function (edge) {
            var edgeSource = typeof edge.source === "string"
                ? edge.source
                : nodeIDAccessor(edge.source);
            var edgeTarget = typeof edge.target === "string"
                ? edge.target
                : nodeIDAccessor(edge.target);
            var edgeKey = edgeSource + "|" + edgeTarget;
            edgeHash.set(edgeKey, edge);
        });
    }
    var customNodeIcon = determineNodeIcon(baseCustomNodeIcon, networkSettings, adjustedSize, projectedNodes);
    var customEdgeIcon = determineEdgeIcon({
        baseCustomEdgeIcon: baseCustomEdgeIcon,
        networkSettings: networkSettings,
        size: adjustedSize,
        nodes: projectedNodes,
        graph: graph
    });
    if ((networkSettings.type === "sankey" ||
        networkSettings.type === "flowchart") &&
        networkDrawing_1.topologicalSort(projectedNodes, projectedEdges) === null) {
        networkSettings.customSankey = d3_sankey_circular_1.sankeyCircular;
    }
    networkSettings.width = size[0];
    networkSettings.height = size[1];
    var networkSettingsChanged = false;
    networkSettingsKeys.forEach(function (key) {
        if (key !== "edgeType" &&
            key !== "graphSettings" &&
            networkSettings[key] !== prevState.graphSettings[key]) {
            networkSettingsChanged = true;
        }
    });
    //Support bubble chart with circle pack and with force
    if (networkSettings.type === "sankey") {
        edgeType = function (d) {
            return d.circular
                ? networkDrawing_1.circularAreaLink(d)
                : edgeType === "angled"
                    ? networkDrawing_1.ribbonLink(d)
                    : networkDrawing_1.areaLink(d);
        };
    }
    else if (isHierarchical) {
        projectedNodes.forEach(function (node) {
            if (createPointLayer) {
                node.x = (node.x0 + node.x1) / 2;
                node.y = (node.y0 + node.y1) / 2;
            }
            if (typeof networkSettings.type === "string" &&
                hierarchicalProjectable[networkSettings.type] &&
                networkSettings.projection === "horizontal") {
                var ox = node.x;
                node.x = node.y;
                node.y = ox;
                if (createPointLayer) {
                    var ox0 = node.x0;
                    var ox1 = node.x1;
                    node.x0 = node.y0;
                    node.x1 = node.y1;
                    node.y0 = ox0;
                    node.y1 = ox1;
                }
            }
            else if (typeof networkSettings.type === "string" &&
                radialProjectable[networkSettings.type] &&
                networkSettings.projection === "radial") {
                var radialPoint = node.depth === 0
                    ? [adjustedSize[0] / 2, adjustedSize[1] / 2]
                    : pieceDrawing_1.pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], node.x / adjustedSize[0], node.y / 2);
                node.x = radialPoint[0];
                node.y = radialPoint[1];
            }
            else {
                node.x = node.x;
                node.y = node.y;
                if (createPointLayer) {
                    node.x0 = node.x0;
                    node.x1 = node.x1;
                    node.y0 = node.y0;
                    node.y1 = node.y1;
                }
            }
        });
    }
    if (networkSettings.type !== "static" &&
        (changedData || networkSettingsChanged)) {
        var components = [
            {
                componentNodes: projectedNodes,
                componentEdges: projectedEdges
            }
        ];
        if (networkSettings.type === "chord") {
            var radius = adjustedSize[1] / 2;
            var _e = networkSettings.groupWidth, groupWidth = _e === void 0 ? 20 : _e, _f = networkSettings.padAngle, padAngle = _f === void 0 ? 0.01 : _f, sortGroups = networkSettings.sortGroups;
            var arcGenerator_1 = d3_shape_1.arc()
                .innerRadius(radius - groupWidth)
                .outerRadius(radius);
            var ribbonGenerator_1 = d3_chord_1.ribbon().radius(radius - groupWidth);
            var matrixifiedNetwork = matrixify({
                edgeHash: edgeHash,
                nodes: projectedNodes,
                edgeWidthAccessor: edgeWidthAccessor,
                nodeIDAccessor: nodeIDAccessor
            });
            var chordLayout = d3_chord_1.chord().padAngle(padAngle);
            if (sortGroups) {
                chordLayout.sortGroups(sortGroups);
            }
            var chords = chordLayout(matrixifiedNetwork);
            var groups = chords.groups;
            groups.forEach(function (group) {
                var groupCentroid = arcGenerator_1.centroid(group);
                var groupD = arcGenerator_1(group);
                var groupNode = projectedNodes[group.index];
                groupNode.d = groupD;
                groupNode.index = group.index;
                groupNode.x = groupCentroid[0] + adjustedSize[0] / 2;
                groupNode.y = groupCentroid[1] + adjustedSize[1] / 2;
            });
            chords.forEach(function (generatedChord) {
                var chordD = ribbonGenerator_1(generatedChord);
                //this is incorrect should use edgeHash
                var nodeSourceID = nodeIDAccessor(projectedNodes[generatedChord.source.index]);
                var nodeTargetID = nodeIDAccessor(projectedNodes[generatedChord.target.index]);
                var chordEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
                chordEdge.d = chordD;
                var chordBounds = svg_path_bounding_box_1.default(chordD);
                chordEdge.x =
                    adjustedSize[0] / 2 + (chordBounds.x1 + chordBounds.x2) / 2;
                chordEdge.y =
                    adjustedSize[1] / 2 + (chordBounds.y1 + chordBounds.y2) / 2;
            });
        }
        else if (networkSettings.type === "sankey" ||
            networkSettings.type === "flowchart") {
            var _g = networkSettings.orient, orient = _g === void 0 ? "center" : _g, _h = networkSettings.iterations, iterations = _h === void 0 ? 100 : _h, nodePadding = networkSettings.nodePadding, _j = networkSettings.nodePaddingRatio, nodePaddingRatio = _j === void 0 ? nodePadding ? undefined : 0.5 : _j, _k = networkSettings.nodeWidth, nodeWidth = _k === void 0 ? networkSettings.type === "flowchart" ? 2 : 24 : _k, customSankey = networkSettings.customSankey, _l = networkSettings.direction, direction_1 = _l === void 0 ? "right" : _l;
            var sankeyOrient = sankeyOrientHash[orient];
            var actualSankey = customSankey || d3_sankey_circular_1.sankeyCircular;
            var frameExtent = [[0, 0], adjustedSize];
            if (networkSettings.direction === "up" ||
                networkSettings.direction === "down") {
                frameExtent = [[0, 0], [adjustedSize[1], adjustedSize[0]]];
            }
            var frameSankey = actualSankey()
                .extent(frameExtent)
                .links(projectedEdges)
                .nodes(projectedNodes)
                .nodeAlign(sankeyOrient)
                .nodeId(nodeIDAccessor)
                .nodeWidth(nodeWidth)
                .iterations(iterations);
            if (frameSankey.nodePaddingRatio && nodePaddingRatio) {
                frameSankey.nodePaddingRatio(nodePaddingRatio);
            }
            else if (nodePadding) {
                frameSankey.nodePadding(nodePadding);
            }
            frameSankey();
            projectedNodes.forEach(function (d) {
                d.height = d.y1 - d.y0;
                d.width = d.x1 - d.x0;
                d.x = d.x0 + d.width / 2;
                d.y = d.y0 + d.height / 2;
                d.radius = d.height / 2;
                d.direction = direction_1;
            });
            projectedEdges.forEach(function (d) {
                d.sankeyWidth = d.width;
                d.direction = direction_1;
                d.width = undefined;
            });
        }
        else if (networkSettings.type === "force") {
            var _m = networkSettings.iterations, iterations = _m === void 0 ? 500 : _m, _o = networkSettings.edgeStrength, edgeStrength_1 = _o === void 0 ? 0.1 : _o, _p = networkSettings.distanceMax, distanceMax = _p === void 0 ? Infinity : _p, edgeDistance = networkSettings.edgeDistance, _q = networkSettings.forceManyBody, nsForceMB = _q === void 0 ? (function (d) { return -25 * nodeSizeAccessor(d); }) : _q;
            var linkForce = d3_force_1.forceLink().strength(function (d) {
                return Math.min(2.5, d.weight ? d.weight * edgeStrength_1 : edgeStrength_1);
            });
            if (edgeDistance) {
                linkForce.distance(edgeDistance);
            }
            var simulation = networkSettings.simulation ||
                d3_force_1.forceSimulation().force("charge", d3_force_1.forceManyBody()
                    .distanceMax(distanceMax)
                    .strength(nsForceMB));
            //        simulation.force("link", linkForce).nodes(projectedNodes)
            simulation.nodes(projectedNodes);
            var forceMod = adjustedSize[1] / adjustedSize[0];
            if (!simulation.force("x")) {
                simulation.force("x", d3_force_1.forceX(adjustedSize[0] / 2).strength(forceMod * 0.1));
            }
            if (!simulation.force("y")) {
                simulation.force("y", d3_force_1.forceY(adjustedSize[1] / 2).strength(0.1));
            }
            if (projectedEdges.length !== 0 && !simulation.force("link")) {
                simulation.force("link", linkForce);
                simulation.force("link").links(projectedEdges);
            }
            //reset alpha if it's too cold
            if (simulation.alpha() < 0.1) {
                simulation.alpha(1);
            }
            simulation.stop();
            for (var i = 0; i < iterations; ++i) {
                simulation.tick();
            }
        }
        else if (networkSettings.type === "motifs") {
            var componentHash_1 = new Map();
            projectedEdges.forEach(function (edge) {
                ;
                [edge.source, edge.target].forEach(function (node) {
                    if (!componentHash_1.get(node)) {
                        componentHash_1.set(node, {
                            node: node,
                            component: -99,
                            connectedNodes: [],
                            edges: []
                        });
                    }
                });
                componentHash_1.get(edge.source).connectedNodes.push(edge.target);
                componentHash_1.get(edge.target).connectedNodes.push(edge.source);
                componentHash_1.get(edge.source).edges.push(edge);
            });
            components = breadthFirstCompontents(projectedNodes, componentHash_1);
            var largestComponent_1 = Math.max(projectedNodes.length / 3, components[0].componentNodes.length);
            var layoutSize_1 = size[0] > size[1] ? size[1] : size[0];
            var layoutDirection_1 = size[0] > size[1] ? "horizontal" : "vertical";
            var _r = networkSettings.iterations, iterations_1 = _r === void 0 ? 500 : _r, _s = networkSettings.edgeStrength, edgeStrength_2 = _s === void 0 ? 0.1 : _s, edgeDistance_1 = networkSettings.edgeDistance, _t = networkSettings.padding, padding_1 = _t === void 0 ? 0 : _t;
            var currentX_1 = padding_1;
            var currentY_1 = padding_1;
            components.forEach(function (_a) {
                var componentNodes = _a.componentNodes, componentEdges = _a.componentEdges;
                var linkForce = d3_force_1.forceLink().strength(function (d) {
                    return Math.min(2.5, d.weight ? d.weight * edgeStrength_2 : edgeStrength_2);
                });
                if (edgeDistance_1) {
                    linkForce.distance(edgeDistance_1);
                }
                var componentLayoutSize = Math.max(componentNodes.length / largestComponent_1, 0.2) * layoutSize_1;
                var xBound = componentLayoutSize + currentX_1;
                var yBound = componentLayoutSize + currentY_1;
                if (layoutDirection_1 === "horizontal") {
                    if (yBound > size[1]) {
                        currentX_1 = componentLayoutSize + currentX_1 + padding_1;
                        currentY_1 = componentLayoutSize + padding_1;
                    }
                    else {
                        currentY_1 = componentLayoutSize + currentY_1 + padding_1;
                    }
                }
                else {
                    if (xBound > size[0]) {
                        currentY_1 = componentLayoutSize + currentY_1 + padding_1;
                        currentX_1 = componentLayoutSize + padding_1;
                    }
                    else {
                        currentX_1 = componentLayoutSize + currentX_1 + padding_1;
                    }
                }
                var xCenter = currentX_1 - componentLayoutSize / 2;
                var yCenter = currentY_1 - componentLayoutSize / 2;
                var simulation = d3_force_1.forceSimulation()
                    .force("charge", d3_force_1.forceManyBody().strength(networkSettings.forceManyBody ||
                    (function (d) { return -25 * nodeSizeAccessor(d); })))
                    .force("link", linkForce);
                simulation
                    .force("x", d3_force_1.forceX(xCenter))
                    .force("y", d3_force_1.forceY(yCenter))
                    .nodes(componentNodes);
                simulation.force("link").links(componentEdges);
                simulation.stop();
                for (var i = 0; i < iterations_1; ++i)
                    simulation.tick();
                var maxX = d3_array_1.max(componentNodes.map(function (d) { return d.x; }));
                var maxY = d3_array_1.max(componentNodes.map(function (d) { return d.y; }));
                var minX = d3_array_1.min(componentNodes.map(function (d) { return d.x; }));
                var minY = d3_array_1.min(componentNodes.map(function (d) { return d.y; }));
                var resetX = d3_scale_1.scaleLinear()
                    .domain([minX, maxX])
                    .range([currentX_1 - componentLayoutSize, currentX_1 - 20]);
                var resetY = d3_scale_1.scaleLinear()
                    .domain([minY, maxY])
                    .range([currentY_1 - componentLayoutSize, currentY_1 - 20]);
                componentNodes.forEach(function (node) {
                    node.x = resetX(node.x);
                    node.y = resetY(node.y);
                });
            });
        }
        else if (networkSettings.type === "matrix") {
            if (networkSettings.sort) {
                projectedNodes = projectedNodes.sort(networkSettings.sort);
            }
            var gridSize = Math.min.apply(Math, __spread(adjustedSize));
            var stepSize_1 = gridSize / (projectedNodes.length + 1);
            projectedNodes.forEach(function (node, index) {
                node.x = 0;
                node.y = (index + 1) * stepSize_1;
            });
        }
        else if (networkSettings.type === "arc") {
            if (networkSettings.sort) {
                projectedNodes = projectedNodes.sort(networkSettings.sort);
            }
            var stepSize_2 = adjustedSize[0] / (projectedNodes.length + 2);
            projectedNodes.forEach(function (node, index) {
                node.x = (index + 1) * stepSize_2;
                node.y = adjustedSize[1] / 2;
            });
        }
        else if (typeof networkSettings.type === "function") {
            networkSettings.type({
                nodes: projectedNodes,
                edges: projectedEdges
            });
        }
        else {
            projectedNodes.forEach(function (node) {
                node.x = node.x === undefined ? (node.x0 + node.x1) / 2 : node.x;
                node.y = node.y === undefined ? node.y0 : node.y;
            });
        }
        prevState.graphSettings.nodes = currentProps.nodes;
        prevState.graphSettings.edges = currentProps.edges;
    }
    //filter out user-defined nodes
    projectedNodes = projectedNodes.filter(filterRenderedNodes);
    projectedEdges = projectedEdges.filter(function (d) {
        return projectedNodes.indexOf(d.target) !== -1 &&
            projectedNodes.indexOf(d.source) !== -1;
    });
    if (networkSettings.direction === "flip") {
        projectedNodes.forEach(function (node) {
            // const ox = node.x
            // const oy = node.y
            node.x = adjustedSize[0] - node.x;
            node.y = adjustedSize[1] - node.y;
        });
    }
    else if (networkSettings.direction === "up" ||
        networkSettings.direction === "down") {
        var mod_1 = networkSettings.direction === "up"
            ? function (value) { return adjustedSize[1] - value; }
            : function (value) { return value; };
        projectedNodes.forEach(function (node) {
            var ox = node.x;
            var ox0 = node.x0;
            var ox1 = node.x1;
            node.x = mod_1(node.y);
            node.x0 = mod_1(node.y0);
            node.x1 = mod_1(node.y1);
            node.y = ox;
            node.y0 = ox0;
            node.y1 = ox1;
        });
    }
    else if (networkSettings.direction === "left") {
        projectedNodes.forEach(function (node) {
            node.x = adjustedSize[0] - node.x;
            node.x0 = adjustedSize[0] - node.x0;
            node.x1 = adjustedSize[0] - node.x1;
        });
    }
    if (typeof networkSettings.zoom === "function") {
        networkSettings.zoom(projectedNodes, adjustedSize);
    }
    else if (networkSettings.zoom !== false &&
        networkSettings.type !== "matrix" &&
        networkSettings.type !== "chord" &&
        networkSettings.type !== "sankey" &&
        networkSettings.type !== "partition" &&
        networkSettings.type !== "treemap" &&
        networkSettings.type !== "circlepack" &&
        networkSettings.type !== "dagre") {
        // ZOOM SHOULD MAINTAIN ASPECT RATIO, ADD "stretch" to fill whole area
        var xMin = d3_array_1.min(projectedNodes.map(function (p) { return p.x - nodeSizeAccessor(p); }));
        var xMax = d3_array_1.max(projectedNodes.map(function (p) { return p.x + nodeSizeAccessor(p); }));
        var yMin = d3_array_1.min(projectedNodes.map(function (p) { return p.y - nodeSizeAccessor(p); }));
        var yMax = d3_array_1.max(projectedNodes.map(function (p) { return p.y + nodeSizeAccessor(p); }));
        var xSize = Math.abs(xMax - xMin);
        var ySize = Math.abs(yMax - yMin);
        var networkAspectRatio = xSize / ySize;
        var baseAspectRatio = adjustedSize[0] / adjustedSize[1];
        var yMod = void 0, xMod = void 0;
        if (networkSettings.zoom === "stretch") {
            yMod = 0;
            xMod = 0;
        }
        else if (xSize > ySize) {
            if (networkAspectRatio > baseAspectRatio) {
                xMod = 0;
                yMod = (adjustedSize[1] - (adjustedSize[0] / xSize) * ySize) / 2;
            }
            else {
                yMod = 0;
                xMod = (adjustedSize[0] - (adjustedSize[1] / ySize) * xSize) / 2;
            }
        }
        else {
            if (networkAspectRatio > baseAspectRatio) {
                xMod = 0;
                yMod = (adjustedSize[1] - (adjustedSize[0] / xSize) * ySize) / 2;
            }
            else {
                yMod = 0;
                xMod = (adjustedSize[0] - (adjustedSize[1] / ySize) * xSize) / 2;
            }
        }
        var projectionScaleX_1 = d3_scale_1.scaleLinear()
            .domain([xMin, xMax])
            .range([xMod, adjustedSize[0] - xMod]);
        var projectionScaleY_1 = d3_scale_1.scaleLinear()
            .domain([yMin, yMax])
            .range([yMod, adjustedSize[1] - yMod]);
        projectedNodes.forEach(function (node) {
            node.x = projectionScaleX_1(node.x);
            node.y = projectionScaleY_1(node.y);
        });
    }
    else if (networkSettings.zoom !== false &&
        networkSettings.projection !== "radial" &&
        (networkSettings.type === "partition" ||
            networkSettings.type === "treemap" ||
            networkSettings.type === "dagre")) {
        var xMin = d3_array_1.min(projectedNodes.map(function (p) { return p.x0; }));
        var xMax = d3_array_1.max(projectedNodes.map(function (p) { return p.x1; }));
        var yMin = d3_array_1.min(projectedNodes.map(function (p) { return p.y0; }));
        var yMax = d3_array_1.max(projectedNodes.map(function (p) { return p.y1; }));
        var projectionScaleX_2 = d3_scale_1.scaleLinear()
            .domain([xMin, xMax])
            .range([margin.left, adjustedSize[0] - margin.right]);
        var projectionScaleY_2 = d3_scale_1.scaleLinear()
            .domain([yMin, yMax])
            .range([margin.top, adjustedSize[1] - margin.bottom]);
        projectedNodes.forEach(function (node) {
            node.x = projectionScaleX_2(node.x);
            node.y = projectionScaleY_2(node.y);
            node.x0 = projectionScaleX_2(node.x0);
            node.y0 = projectionScaleY_2(node.y0);
            node.x1 = projectionScaleX_2(node.x1);
            node.y1 = projectionScaleY_2(node.y1);
            node.zoomedHeight = node.y1 - node.y0;
            node.zoomedWidth = node.x1 - node.x0;
        });
        projectedEdges.forEach(function (edge) {
            if (edge.points) {
                edge.points.forEach(function (p) {
                    p.x = projectionScaleX_2(p.x);
                    p.y = projectionScaleY_2(p.y);
                });
            }
        });
    }
    projectedNodes.forEach(function (node) {
        node.nodeSize = nodeSizeAccessor(node);
    });
    projectedEdges.forEach(function (edge) {
        edge.width = edgeWidthAccessor(edge);
    });
    var legendSettings;
    if (currentProps.legend) {
        legendSettings = currentProps.legend;
        if (!legendSettings.legendGroups) {
            ///Something auto for networks
            var legendGroups = [
                {
                    styleFn: currentProps.nodeStyle,
                    type: "fill",
                    items: []
                }
            ];
            legendSettings.legendGroups = legendGroups;
        }
    }
    var networkFrameRender = {
        edges: {
            accessibleTransform: function (data, i) {
                var edgeX = (data[i].source.x + data[i].target.x) / 2;
                var edgeY = (data[i].source.y + data[i].target.y) / 2;
                return __assign(__assign({ type: "frame-hover" }, data[i]), { x: edgeX, y: edgeY });
            },
            data: projectedEdges,
            styleFn: dataFunctions_1.stringToFn(edgeStyle, function () { return ({}); }, true),
            classFn: dataFunctions_1.stringToFn(edgeClass, function () { return ""; }, true),
            renderMode: dataFunctions_1.stringToFn(edgeRenderMode, undefined, true),
            canvasRenderFn: canvasEdges && dataFunctions_1.stringToFn(canvasEdges, undefined, true),
            renderKeyFn: currentProps.edgeRenderKey
                ? currentProps.edgeRenderKey
                : function (d) { return d._NWFEdgeKey || d.key || d.source.id + "-" + d.target.id; },
            behavior: networkDrawing_1.drawEdges,
            projection: networkSettings.projection,
            type: edgeType,
            customMark: customEdgeIcon,
            networkSettings: networkSettings
        },
        nodes: {
            accessibleTransform: function (data, i) { return (__assign(__assign({ type: "frame-hover" }, data[i]), (data[i].data || {}))); },
            data: projectedNodes,
            styleFn: nodeStyleFn,
            classFn: nodeClassFn,
            renderMode: nodeRenderModeFn,
            canvasRenderFn: nodeCanvasRenderFn,
            customMark: customNodeIcon,
            behavior: networkDrawing_1.drawNodes,
            renderKeyFn: currentProps.nodeRenderKey
        }
    };
    var nodeLabelAnnotations = [];
    if (currentProps.nodeLabels && projectedNodes) {
        projectedNodes.forEach(function (node, nodei) {
            var feasibleLabel = nodeLabels && nodeLabels !== true && nodeLabels(node);
            if (nodeLabels === true || feasibleLabel) {
                var actualLabel = networkSettings.projection === "radial" && node.depth !== 0
                    ? networkDrawing_1.radialLabelGenerator(node, nodei, nodeLabels === true ? nodeIDAccessor : nodeLabels, adjustedSize)
                    : nodeLabels === true
                        ? nodeIDAccessor(node, nodei)
                        : feasibleLabel;
                var nodeLabel = void 0;
                if (React.isValidElement(actualLabel)) {
                    nodeLabel = {
                        key: "node-label-" + nodei,
                        type: "basic-node-label",
                        x: node.x,
                        y: node.y,
                        element: actualLabel
                    };
                }
                else {
                    nodeLabel = {
                        key: "node-label-" + nodei,
                        className: "node-label",
                        dx: 0,
                        dy: 0,
                        x: node.x,
                        y: node.y,
                        note: { label: actualLabel },
                        connector: { end: "none" },
                        type: AnnotationLabel_1.default,
                        subject: { radius: nodeSizeAccessor(node) + 2 }
                    };
                }
                nodeLabelAnnotations.push(nodeLabel);
            }
        });
    }
    var projectedXYPoints;
    var overlay = [];
    var areaBasedTypes = ["circlepack", "treemap", "partition", "chord"];
    if ((hoverAnnotation &&
        areaBasedTypes.find(function (d) { return d === networkSettings.type; })) ||
        hoverAnnotation === "area") {
        if (hoverAnnotation !== "edge") {
            var renderedNodeOverlays = projectedNodes.map(function (d, i) { return (__assign({ overlayData: d }, customNodeIcon({
                d: d,
                i: i,
                transform: "translate(" + d.x + "," + d.y + ")",
                styleFn: function () { return ({ opacity: 0 }); }
            }).props)); });
            overlay.push.apply(overlay, __spread(renderedNodeOverlays));
        }
        if (hoverAnnotation !== "node") {
            projectedEdges.forEach(function (d, i) {
                var generatedIcon = customEdgeIcon({
                    d: d,
                    i: i,
                    transform: "translate(" + d.x + "," + d.y + ")",
                    styleFn: function () { return ({ opacity: 0 }); }
                });
                if (generatedIcon) {
                    overlay.push(__assign({ overlayData: __assign(__assign({}, d), { x: d.x || (d.source.x + d.target.x) / 2, y: d.y || (d.source.y + d.target.y) / 2, edge: true }) }, generatedIcon.props));
                }
            });
        }
    }
    else if (hoverAnnotation === "edge" &&
        typeof networkSettings.type === "string" &&
        edgePointHash[networkSettings.type]) {
        projectedXYPoints = projectedEdges.map(edgePointHash[networkSettings.type]);
    }
    else if (Array.isArray(hoverAnnotation) ||
        hoverAnnotation === true ||
        hoverAnnotation === "node") {
        projectedXYPoints = projectedNodes;
        if (changedData || networkSettingsChanged)
            projectedXYPoints = __spread(projectedNodes);
    }
    else if (hoverAnnotation === "all" &&
        typeof networkSettings.type === "string") {
        projectedXYPoints = __spread(projectedEdges.map(edgePointHash[networkSettings.type]), projectedNodes);
    }
    return {
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        title: title,
        renderNumber: prevState.renderNumber + 1,
        projectedNodes: projectedNodes,
        projectedEdges: projectedEdges,
        projectedXYPoints: projectedXYPoints,
        overlay: overlay,
        nodeIDAccessor: nodeIDAccessor,
        sourceAccessor: sourceAccessor,
        targetAccessor: targetAccessor,
        nodeSizeAccessor: nodeSizeAccessor,
        edgeWidthAccessor: edgeWidthAccessor,
        margin: margin,
        legendSettings: legendSettings,
        networkFrameRender: networkFrameRender,
        nodeLabelAnnotations: nodeLabelAnnotations,
        graphSettings: __assign(__assign({}, networkSettings.graphSettings), networkSettings),
        props: currentProps
    };
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.left = left;
exports.right = right;
exports.justify = justify;
exports.center = center;

var _d3Array = __webpack_require__(225);

// For a given link, return the target node's depth
function targetDepth(d) {
  return d.target.depth;
}

// The depth of a node when the nodeAlign (align) is set to 'left'
function left(node) {
  return node.depth;
}

// The depth of a node when the nodeAlign (align) is set to 'right'
function right(node, n) {
  return n - 1 - node.height;
}

// The depth of a node when the nodeAlign (align) is set to 'justify'
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}

// The depth of a node when the nodeAlign (align) is set to 'center'
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0, _d3Array.min)(node.sourceLinks, targetDepth) - 1 : 0;
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(338)))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(187),
    keys = __webpack_require__(74);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(341);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(342),
    isArguments = __webpack_require__(132),
    isArray = __webpack_require__(16),
    isBuffer = __webpack_require__(87),
    isIndex = __webpack_require__(134),
    isTypedArray = __webpack_require__(135);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 189 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(88);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    getPrototype = __webpack_require__(141),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 192 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 193 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(377),
    isObjectLike = __webpack_require__(25);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(378),
    arraySome = __webpack_require__(381),
    cacheHas = __webpack_require__(382);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(22);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(198),
    getSymbols = __webpack_require__(144),
    keys = __webpack_require__(74);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(199),
    isArray = __webpack_require__(16);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 199 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 200 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 202 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(204),
    toKey = __webpack_require__(96);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(16),
    isKey = __webpack_require__(145),
    stringToPath = __webpack_require__(395),
    toString = __webpack_require__(398);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(186),
    createBaseEach = __webpack_require__(407);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 206 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(146),
    eq = __webpack_require__(75);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(22);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(133)(module)))

/***/ }),
/* 210 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(199),
    getPrototype = __webpack_require__(141),
    getSymbols = __webpack_require__(144),
    stubArray = __webpack_require__(200);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(147);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(423),
    getPrototype = __webpack_require__(141),
    isPrototype = __webpack_require__(139);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(146),
    eq = __webpack_require__(75);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 215 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20),
    now = __webpack_require__(454),
    toNumber = __webpack_require__(455);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorWrap = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _debounce = __webpack_require__(216);

var _debounce2 = _interopRequireDefault(_debounce);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorWrap = exports.ColorWrap = function ColorWrap(Picker) {
  var ColorPicker = function (_ref) {
    _inherits(ColorPicker, _ref);

    function ColorPicker(props) {
      _classCallCheck(this, ColorPicker);

      var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));

      _this.handleChange = function (data, event) {
        var isValidColor = _color2.default.simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = _color2.default.toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };

      _this.handleSwatchHover = function (data, event) {
        var isValidColor = _color2.default.simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = _color2.default.toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };

      _this.state = _extends({}, _color2.default.toState(props.color, 0));

      _this.debounce = (0, _debounce2.default)(function (fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }

    _createClass(ColorPicker, [{
      key: 'render',
      value: function render() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }

        return _react2.default.createElement(Picker, _extends({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends({}, _color2.default.toState(nextProps.color, state.oldHue));
      }
    }]);

    return ColorPicker;
  }(_react.PureComponent || _react.Component);

  ColorPicker.propTypes = _extends({}, Picker.propTypes);

  ColorPicker.defaultProps = _extends({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.50,
      l: 0.20,
      a: 1
    }
  });

  return ColorPicker;
};

exports.default = ColorWrap;

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "red", function() { return red; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pink", function() { return pink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "purple", function() { return purple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepPurple", function() { return deepPurple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indigo", function() { return indigo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blue", function() { return blue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightBlue", function() { return lightBlue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyan", function() { return cyan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "teal", function() { return teal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "green", function() { return green; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightGreen", function() { return lightGreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lime", function() { return lime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yellow", function() { return yellow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "amber", function() { return amber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orange", function() { return orange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepOrange", function() { return deepOrange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brown", function() { return brown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grey", function() { return grey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blueGrey", function() { return blueGrey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darkText", function() { return darkText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightText", function() { return lightText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darkIcons", function() { return darkIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightIcons", function() { return lightIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "white", function() { return white; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "black", function() { return black; });
var red = {"50":"#ffebee","100":"#ffcdd2","200":"#ef9a9a","300":"#e57373","400":"#ef5350","500":"#f44336","600":"#e53935","700":"#d32f2f","800":"#c62828","900":"#b71c1c","a100":"#ff8a80","a200":"#ff5252","a400":"#ff1744","a700":"#d50000"};
var pink = {"50":"#fce4ec","100":"#f8bbd0","200":"#f48fb1","300":"#f06292","400":"#ec407a","500":"#e91e63","600":"#d81b60","700":"#c2185b","800":"#ad1457","900":"#880e4f","a100":"#ff80ab","a200":"#ff4081","a400":"#f50057","a700":"#c51162"};
var purple = {"50":"#f3e5f5","100":"#e1bee7","200":"#ce93d8","300":"#ba68c8","400":"#ab47bc","500":"#9c27b0","600":"#8e24aa","700":"#7b1fa2","800":"#6a1b9a","900":"#4a148c","a100":"#ea80fc","a200":"#e040fb","a400":"#d500f9","a700":"#aa00ff"};
var deepPurple = {"50":"#ede7f6","100":"#d1c4e9","200":"#b39ddb","300":"#9575cd","400":"#7e57c2","500":"#673ab7","600":"#5e35b1","700":"#512da8","800":"#4527a0","900":"#311b92","a100":"#b388ff","a200":"#7c4dff","a400":"#651fff","a700":"#6200ea"};
var indigo = {"50":"#e8eaf6","100":"#c5cae9","200":"#9fa8da","300":"#7986cb","400":"#5c6bc0","500":"#3f51b5","600":"#3949ab","700":"#303f9f","800":"#283593","900":"#1a237e","a100":"#8c9eff","a200":"#536dfe","a400":"#3d5afe","a700":"#304ffe"};
var blue = {"50":"#e3f2fd","100":"#bbdefb","200":"#90caf9","300":"#64b5f6","400":"#42a5f5","500":"#2196f3","600":"#1e88e5","700":"#1976d2","800":"#1565c0","900":"#0d47a1","a100":"#82b1ff","a200":"#448aff","a400":"#2979ff","a700":"#2962ff"};
var lightBlue = {"50":"#e1f5fe","100":"#b3e5fc","200":"#81d4fa","300":"#4fc3f7","400":"#29b6f6","500":"#03a9f4","600":"#039be5","700":"#0288d1","800":"#0277bd","900":"#01579b","a100":"#80d8ff","a200":"#40c4ff","a400":"#00b0ff","a700":"#0091ea"};
var cyan = {"50":"#e0f7fa","100":"#b2ebf2","200":"#80deea","300":"#4dd0e1","400":"#26c6da","500":"#00bcd4","600":"#00acc1","700":"#0097a7","800":"#00838f","900":"#006064","a100":"#84ffff","a200":"#18ffff","a400":"#00e5ff","a700":"#00b8d4"};
var teal = {"50":"#e0f2f1","100":"#b2dfdb","200":"#80cbc4","300":"#4db6ac","400":"#26a69a","500":"#009688","600":"#00897b","700":"#00796b","800":"#00695c","900":"#004d40","a100":"#a7ffeb","a200":"#64ffda","a400":"#1de9b6","a700":"#00bfa5"};
var green = {"50":"#e8f5e9","100":"#c8e6c9","200":"#a5d6a7","300":"#81c784","400":"#66bb6a","500":"#4caf50","600":"#43a047","700":"#388e3c","800":"#2e7d32","900":"#1b5e20","a100":"#b9f6ca","a200":"#69f0ae","a400":"#00e676","a700":"#00c853"};
var lightGreen = {"50":"#f1f8e9","100":"#dcedc8","200":"#c5e1a5","300":"#aed581","400":"#9ccc65","500":"#8bc34a","600":"#7cb342","700":"#689f38","800":"#558b2f","900":"#33691e","a100":"#ccff90","a200":"#b2ff59","a400":"#76ff03","a700":"#64dd17"};
var lime = {"50":"#f9fbe7","100":"#f0f4c3","200":"#e6ee9c","300":"#dce775","400":"#d4e157","500":"#cddc39","600":"#c0ca33","700":"#afb42b","800":"#9e9d24","900":"#827717","a100":"#f4ff81","a200":"#eeff41","a400":"#c6ff00","a700":"#aeea00"};
var yellow = {"50":"#fffde7","100":"#fff9c4","200":"#fff59d","300":"#fff176","400":"#ffee58","500":"#ffeb3b","600":"#fdd835","700":"#fbc02d","800":"#f9a825","900":"#f57f17","a100":"#ffff8d","a200":"#ffff00","a400":"#ffea00","a700":"#ffd600"};
var amber = {"50":"#fff8e1","100":"#ffecb3","200":"#ffe082","300":"#ffd54f","400":"#ffca28","500":"#ffc107","600":"#ffb300","700":"#ffa000","800":"#ff8f00","900":"#ff6f00","a100":"#ffe57f","a200":"#ffd740","a400":"#ffc400","a700":"#ffab00"};
var orange = {"50":"#fff3e0","100":"#ffe0b2","200":"#ffcc80","300":"#ffb74d","400":"#ffa726","500":"#ff9800","600":"#fb8c00","700":"#f57c00","800":"#ef6c00","900":"#e65100","a100":"#ffd180","a200":"#ffab40","a400":"#ff9100","a700":"#ff6d00"};
var deepOrange = {"50":"#fbe9e7","100":"#ffccbc","200":"#ffab91","300":"#ff8a65","400":"#ff7043","500":"#ff5722","600":"#f4511e","700":"#e64a19","800":"#d84315","900":"#bf360c","a100":"#ff9e80","a200":"#ff6e40","a400":"#ff3d00","a700":"#dd2c00"};
var brown = {"50":"#efebe9","100":"#d7ccc8","200":"#bcaaa4","300":"#a1887f","400":"#8d6e63","500":"#795548","600":"#6d4c41","700":"#5d4037","800":"#4e342e","900":"#3e2723"};
var grey = {"50":"#fafafa","100":"#f5f5f5","200":"#eeeeee","300":"#e0e0e0","400":"#bdbdbd","500":"#9e9e9e","600":"#757575","700":"#616161","800":"#424242","900":"#212121"};
var blueGrey = {"50":"#eceff1","100":"#cfd8dc","200":"#b0bec5","300":"#90a4ae","400":"#78909c","500":"#607d8b","600":"#546e7a","700":"#455a64","800":"#37474f","900":"#263238"};
var darkText = {"primary":"rgba(0, 0, 0, 0.87)","secondary":"rgba(0, 0, 0, 0.54)","disabled":"rgba(0, 0, 0, 0.38)","dividers":"rgba(0, 0, 0, 0.12)"};
var lightText = {"primary":"rgba(255, 255, 255, 1)","secondary":"rgba(255, 255, 255, 0.7)","disabled":"rgba(255, 255, 255, 0.5)","dividers":"rgba(255, 255, 255, 0.12)"};
var darkIcons = {"active":"rgba(0, 0, 0, 0.54)","inactive":"rgba(0, 0, 0, 0.38)"};
var lightIcons = {"active":"rgba(255, 255, 255, 1)","inactive":"rgba(255, 255, 255, 0.5)"};
var white = "#ffffff";
var black = "#000000";

/* harmony default export */ __webpack_exports__["default"] = ({
  red: red,
  pink: pink,
  purple: purple,
  deepPurple: deepPurple,
  indigo: indigo,
  blue: blue,
  lightBlue: lightBlue,
  cyan: cyan,
  teal: teal,
  green: green,
  lightGreen: lightGreen,
  lime: lime,
  yellow: yellow,
  amber: amber,
  orange: orange,
  deepOrange: deepOrange,
  brown: brown,
  grey: grey,
  blueGrey: blueGrey,
  darkText: darkText,
  lightText: lightText,
  darkIcons: darkIcons,
  lightIcons: lightIcons,
  white: white,
  black: black
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sortByOrdinalRange = void 0;
function stringOrFnAccessor(datapoint, accessor) {
    return typeof accessor === "function"
        ? accessor(datapoint)
        : datapoint[accessor];
}
exports.sortByOrdinalRange = (oAccessor, rAccessor, secondarySort, data) => {
    const subsortData = {};
    let subsortArrays = [];
    data.forEach(datapoint => {
        const ordinalValue = stringOrFnAccessor(datapoint, oAccessor);
        if (!subsortData[ordinalValue]) {
            subsortData[ordinalValue] = { array: [], value: 0, label: ordinalValue };
            subsortArrays.push(subsortData[ordinalValue]);
        }
        subsortData[ordinalValue].array.push(datapoint);
        subsortData[ordinalValue].value += stringOrFnAccessor(datapoint, rAccessor);
    });
    subsortArrays = subsortArrays.sort((ordinalAData, ordinalBData) => {
        if (ordinalBData.value === ordinalAData.value) {
            if (ordinalAData.label < ordinalBData.label) {
                return -1;
            }
            if (ordinalAData.label > ordinalBData.label) {
                return 1;
            }
            return 1;
        }
        return ordinalBData.value - ordinalAData.value;
    });
    if (secondarySort !== "none") {
        subsortArrays.forEach(ordinalData => {
            ordinalData.array = ordinalData.array.sort((ordinalAData, ordinalBData) => stringOrFnAccessor(ordinalBData, secondarySort) -
                stringOrFnAccessor(ordinalAData, secondarySort));
        });
    }
    return subsortArrays.reduce((combinedArray, ordinalData) => [
        ...combinedArray,
        ...ordinalData.array
    ], []);
};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.controlHelpText = exports.chartHelpText = void 0;
exports.chartHelpText = {
    line: "Line and stacked area charts for time series data where each row is a point and columns are data to be plotted.",
    bar: "Bar charts to compare individual and aggregate amounts.",
    scatter: "Scatterplot for comparing correlation between x and y values.",
    grid: "A table of data.",
    network: "Force-directed, adjacency matrix, arc diagram and sankey network visualization suitable for data that is an edge list where one dimension represents source and another dimension represents target.",
    summary: "Distribution plots such as boxplots and violin plots to compare.",
    hexbin: "Shows aggregate distribution of larger datasets across x and y metrics using hexbin, heatmap or contour plots.",
    parallel: "Parallel coordinates for comparing and filtering across different values in the dataset.",
    hierarchy: "Nest data by categorical values using treemap, dendrogram, sunburst or partition."
};
const hexScatterX = "Plot this metric along the X axis";
exports.controlHelpText = {
    metric1: {
        default: "Plot this metric",
        scatter: hexScatterX,
        hexbin: hexScatterX
    },
    metric2: {
        default: "Plot this metric along the Y axis"
    },
    metric3: {
        default: "Size the width of bars (Marimekko style) based on this metric",
        scatter: "Size the radius of points based on this metric"
    },
    metric4: "Error bars according to this value",
    dim1: {
        default: "Color items by this dimension",
        summary: "Group items into this category",
        network: "Use this dimension to determine the source node"
    },
    dim2: {
        default: "Label prominent datapoints using this dimension",
        network: "Use this dimension to determine the target node"
    },
    dim3: {
        default: "Split contours into separate groups based on this dimension"
    },
    networkType: "Represent network as a force-directed network (good for social networks) or as a sankey diagram (good for flow networks)",
    hierarchyType: "Represent your hierarchy as a tree (good for taxonomies) or a treemap (good for volumes) or partition (also good for volume where category volume is important)",
    timeseriesSort: "Sort line chart time series by its array position or by a specific metric or time",
    lineType: "Represent your data using a line chart, stacked area chart or ranked area chart",
    areaType: "Represent as a heatmap, hexbin or contour plot",
    lineDimensions: "Only plot the selected dimensions (or all if none are selected)",
    trendLine: "Select the kind of trend line you want to display on the chart",
    barGrouping: "Choose between a clustered or a stacked bar chart when there are multiple pieces in the same category",
    marginalGraphics: "Choose the kind of marginal summary you want to see for summarizing density along the axes"
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Viz = void 0;
const React = __importStar(__webpack_require__(0));
const styled_components_1 = __importDefault(__webpack_require__(19));
const FlexItem = styled_components_1.default.div `
  flex: 1;
  min-width: 0;
`;
function PlaceHolder() {
    return React.createElement("div", null, "This should be a display element!");
}
exports.Viz = ({ children, componentType }) => {
    // In the future, the Viz component might be used for things like error boundaries
    return React.createElement(FlexItem, null, children);
};
exports.Viz.defaultProps = { componentType: "viz", children: React.createElement(PlaceHolder, null) };
exports.Viz.displayName = "Viz";


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolbar = void 0;
const octicons_1 = __webpack_require__(223);
const React = __importStar(__webpack_require__(0));
const chart_docs_1 = __webpack_require__(220);
const icons_1 = __webpack_require__(509);
const IconButton_1 = __webpack_require__(510);
const styled_components_1 = __importDefault(__webpack_require__(19));
const ToolbarWrapper = styled_components_1.default.div `
  display: flex;
  flex-flow: column nowrap;
  z-index: 1;
  padding: 5px;
`;
Toolbar.defaultProps = {
    componentType: "toolbar",
    currentView: "",
    dimensions: [],
    setGrid: () => null,
    setView: () => null
};
function Toolbar({ dimensions, setGrid, setView, currentView, componentType, largeDataset }) {
    return (React.createElement(ToolbarWrapper, { className: "dx-button-bar" },
        React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.grid, onClick: setGrid, message: "Data Table", selected: false },
            React.createElement(octicons_1.DatabaseOcticon, null)),
        !largeDataset && dimensions.length > 0 && (React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.bar, onClick: () => setView("bar"), selected: currentView === "bar", message: "Bar Graph" },
            React.createElement(icons_1.BarChartIcon, null))),
        React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.summary, onClick: () => setView("summary"), selected: currentView === "summary", message: "Summary" },
            React.createElement(icons_1.BoxplotIcon, null)),
        React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.scatter, onClick: () => setView("scatter"), selected: currentView === "scatter", message: "Scatter Plot" },
            React.createElement(icons_1.ScatterplotIcon, null)),
        React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.hexbin, onClick: () => setView("hexbin"), selected: currentView === "hexbin", message: "Area Plot" },
            React.createElement(icons_1.HexbinIcon, null)),
        !largeDataset && dimensions.length > 1 && (React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.network, onClick: () => setView("network"), selected: currentView === "network", message: "Network" },
            React.createElement(icons_1.NetworkIcon, null))),
        !largeDataset && dimensions.length > 0 && (React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.hierarchy, onClick: () => setView("hierarchy"), selected: currentView === "hierarchy", message: "Hierarchy" },
            React.createElement(icons_1.TreeIcon, null))),
        dimensions.length > 0 && (React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.parallel, onClick: () => setView("parallel"), selected: currentView === "parallel", message: "Parallel Coordinates" },
            React.createElement(icons_1.ParallelCoordinatesIcon, null))),
        React.createElement(IconButton_1.IconButton, { title: chart_docs_1.chartHelpText.line, onClick: () => setView("line"), selected: currentView === "line", message: "Line Graph" },
            React.createElement(icons_1.LineChartIcon, null))));
}
exports.Toolbar = Toolbar;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
exports.SVGWrapper = (props) => {
    return (React.createElement("span", null,
        React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: props.width, height: props.height, viewBox: props.viewBox }, props.outerProps, { style: Object.assign({ fill: "currentColor", display: "inline-block", verticalAlign: "text-bottom" }, props.outerProps.style) }), props.children)));
};
exports.SVGWrapper.displayName = "SVGWrapper";
exports.MarkdownOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Create Text Cell"),
    React.createElement("path", { fillRule: "evenodd", d: "M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z" })));
exports.CodeOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 14, height: 16, viewBox: "0 0 14 16", outerProps: props },
    React.createElement("title", null, "Create Code Cell"),
    React.createElement("path", { fillRule: "evenodd", d: "M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z" })));
exports.DownArrowOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 10, height: 16, viewBox: "0 0 10 16", outerProps: props },
    React.createElement("title", null, "Merge Cells"),
    React.createElement("path", { fillRule: "evenodd", d: "M5 3L0 9h3v4h4V9h3z" })));
exports.PinOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Pin Cell to Top"),
    React.createElement("path", { fillRule: "evenodd", d: "M10 1.2V2l.5 1L6 6H2.2c-.44 0-.67.53-.34.86L5 10l-4 5 5-4 3.14 3.14a.5.5 0 0 0 .86-.34V10l3-4.5 1 .5h.8c.44 0 .67-.53.34-.86L10.86.86a.5.5 0 0 0-.86.34z" })));
exports.TrashOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 12, height: 16, viewBox: "0 0 12 16", outerProps: props },
    React.createElement("title", null, "Delete Cell"),
    React.createElement("path", { fillRule: "evenodd", d: "M11 2H9c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1H2c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1v9c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V5c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-1 12H3V5h1v8h1V5h1v8h1V5h1v8h1V5h1v9zm1-10H2V3h9v1z" })));
exports.TriangleRightOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 6, height: 16, viewBox: "0 0 6 16", outerProps: props },
    React.createElement("title", null, "Run Cell"),
    React.createElement("path", { fillRule: "evenodd", d: "M0 14l6-6-6-6z" })));
exports.ChevronDownOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 10, height: 16, viewBox: "0 0 10 16", outerProps: props },
    React.createElement("title", null, "Show Additional Actions"),
    React.createElement("path", { fillRule: "evenodd", d: "M5 11L0 6l1.5-1.5L5 8.25 8.5 4.5 10 6z" })));
exports.LinkExternalOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 12, height: 16, viewBox: "0 0 12 16", outerProps: props },
    React.createElement("title", null, "Cell Placeholder for Pinned Cell"),
    React.createElement("path", { fillRule: "evenodd", d: "M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z" })));
exports.GraphOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Display Bar Graph"),
    React.createElement("path", { fillRule: "evenodd", d: "M16 14v1H0V0h1v14h15zM5 13H3V8h2v5zm4 0H7V3h2v10zm4 0h-2V6h2v7z" })));
exports.PulseOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 14, height: 16, viewBox: "0 0 14 16", outerProps: props },
    React.createElement("title", null, "Display Line Graph"),
    React.createElement("path", { fillRule: "evenodd", d: "M11.5 8L8.8 5.4 6.6 8.5 5.5 1.6 2.38 8H0v2h3.6l.9-1.8.9 5.4L9 8.5l1.6 1.5H14V8z" })));
exports.DatabaseOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 12, height: 16, viewBox: "0 0 12 16", outerProps: props },
    React.createElement("title", null, "Display Data Table"),
    React.createElement("path", { fillRule: "evenodd", d: "M6 15c-3.31 0-6-.9-6-2v-2c0-.17.09-.34.21-.5.67.86 3 1.5 5.79 1.5s5.12-.64 5.79-1.5c.13.16.21.33.21.5v2c0 1.1-2.69 2-6 2zm0-4c-3.31 0-6-.9-6-2V7c0-.11.04-.21.09-.31.03-.06.07-.13.12-.19C.88 7.36 3.21 8 6 8s5.12-.64 5.79-1.5c.05.06.09.13.12.19.05.1.09.21.09.31v2c0 1.1-2.69 2-6 2zm0-4c-3.31 0-6-.9-6-2V3c0-1.1 2.69-2 6-2s6 .9 6 2v2c0 1.1-2.69 2-6 2zm0-5c-2.21 0-4 .45-4 1s1.79 1 4 1 4-.45 4-1-1.79-1-4-1z" })));
exports.TelescopeOcticon = (props) => (React.createElement(exports.SVGWrapper, { width: 14, height: 16, viewBox: "0 0 14 16", outerProps: props },
    React.createElement("title", null, "Display Scatter Plot"),
    React.createElement("path", { fillRule: "evenodd", d: "M8 9l3 6h-1l-2-4v5H7v-6l-2 5H4l2-5 2-1zM7 0H6v1h1V0zM5 3H4v1h1V3zM2 1H1v1h1V1zM.63 9a.52.52 0 0 0-.16.67l.55.92c.13.23.41.31.64.2l1.39-.66-1.16-2-1.27.86.01.01zm7.89-5.39l-5.8 3.95L3.95 9.7l6.33-3.03-1.77-3.06h.01zm4.22 1.28l-1.47-2.52a.51.51 0 0 0-.72-.17l-1.2.83 1.84 3.2 1.33-.64c.27-.13.36-.44.22-.7z" })));
exports.FileText = (props) => (React.createElement(exports.SVGWrapper, { width: 12, height: 16, viewBox: "0 0 12 16", outerProps: props },
    React.createElement("title", null, "File"),
    React.createElement("path", { d: "M6 5H2V4h4v1zM2 8h7V7H2v1zm0 2h7V9H2v1zm0 2h7v-1H2v1zm10-7.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v12h10V5z" })));
exports.Book = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Notebook"),
    React.createElement("path", { fillRule: "evenodd", d: "M3 5h4v1H3V5zm0 3h4V7H3v1zm0 2h4V9H3v1zm11-5h-4v1h4V5zm0 2h-4v1h4V7zm0 2h-4v1h4V9zm2-6v9c0 .55-.45 1-1 1H9.5l-1 1-1-1H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h5.5l1 1 1-1H15c.55 0 1 .45 1 1zm-8 .5L7.5 3H2v9h6V3.5zm7-.5H9.5l-.5.5V12h6V3z" })));
exports.FileDirectory = (props) => (React.createElement(exports.SVGWrapper, { width: 14, height: 16, viewBox: "0 0 14 16", outerProps: props },
    React.createElement("title", null, "Directory"),
    React.createElement("path", { fillRule: "evenodd", d: "M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z" })));
exports.CloudDownload = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Cloud Download"),
    React.createElement("path", { fillRule: "evenodd", d: "M9 12h2l-3 3-3-3h2V7h2v5zm3-8c0-.44-.91-3-4.5-3C5.08 1 3 2.92 3 5 1.02 5 0 6.52 0 8c0 1.53 1 3 3 3h3V9.7H3C1.38 9.7 1.3 8.28 1.3 8c0-.17.05-1.7 1.7-1.7h1.3V5c0-1.39 1.56-2.7 3.2-2.7 2.55 0 3.13 1.55 3.2 1.8v1.2H12c.81 0 2.7.22 2.7 2.2 0 2.09-2.25 2.2-2.7 2.2h-2V11h2c2.08 0 4-1.16 4-3.5C16 5.06 14.08 4 12 4z" })));
exports.Beaker = (props) => (React.createElement(exports.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Experimental Data Explorer"),
    React.createElement("path", { fillRule: "evenodd", d: "M14.38 14.59L11 7V3h1V2H3v1h1v4L.63 14.59A1 1 0 0 0 1.54 16h11.94c.72 0 1.2-.75.91-1.41h-.01zM3.75 10L5 7V3h5v4l1.25 3h-7.5zM8 8h1v1H8V8zM7 7H6V6h1v1zm0-3h1v1H7V4zm0-3H6V0h1v1z" })));


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "arc", function() { return /* reexport */ src_arc; });
__webpack_require__.d(__webpack_exports__, "area", function() { return /* reexport */ src_area; });
__webpack_require__.d(__webpack_exports__, "line", function() { return /* reexport */ src_line; });
__webpack_require__.d(__webpack_exports__, "pie", function() { return /* reexport */ src_pie; });
__webpack_require__.d(__webpack_exports__, "radialArea", function() { return /* reexport */ radialArea; });
__webpack_require__.d(__webpack_exports__, "radialLine", function() { return /* reexport */ src_radialLine; });
__webpack_require__.d(__webpack_exports__, "symbol", function() { return /* reexport */ src_symbol; });
__webpack_require__.d(__webpack_exports__, "symbols", function() { return /* reexport */ symbols; });
__webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return /* reexport */ circle; });
__webpack_require__.d(__webpack_exports__, "symbolCross", function() { return /* reexport */ cross; });
__webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return /* reexport */ diamond; });
__webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return /* reexport */ square; });
__webpack_require__.d(__webpack_exports__, "symbolStar", function() { return /* reexport */ star; });
__webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return /* reexport */ triangle; });
__webpack_require__.d(__webpack_exports__, "symbolWye", function() { return /* reexport */ wye; });
__webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return /* reexport */ basisClosed; });
__webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return /* reexport */ basisOpen; });
__webpack_require__.d(__webpack_exports__, "curveBasis", function() { return /* reexport */ basis; });
__webpack_require__.d(__webpack_exports__, "curveBundle", function() { return /* reexport */ curve_bundle; });
__webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return /* reexport */ cardinalClosed; });
__webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return /* reexport */ cardinalOpen; });
__webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return /* reexport */ cardinal; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return /* reexport */ catmullRomClosed; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return /* reexport */ catmullRomOpen; });
__webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return /* reexport */ curve_catmullRom; });
__webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return /* reexport */ linearClosed; });
__webpack_require__.d(__webpack_exports__, "curveLinear", function() { return /* reexport */ linear; });
__webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return /* reexport */ monotoneX; });
__webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return /* reexport */ monotoneY; });
__webpack_require__.d(__webpack_exports__, "curveNatural", function() { return /* reexport */ natural; });
__webpack_require__.d(__webpack_exports__, "curveStep", function() { return /* reexport */ step; });
__webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return /* reexport */ stepAfter; });
__webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return /* reexport */ stepBefore; });
__webpack_require__.d(__webpack_exports__, "stack", function() { return /* reexport */ src_stack; });
__webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return /* reexport */ expand; });
__webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return /* reexport */ none; });
__webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return /* reexport */ silhouette; });
__webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return /* reexport */ wiggle; });
__webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return /* reexport */ ascending; });
__webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return /* reexport */ order_descending; });
__webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return /* reexport */ insideOut; });
__webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return /* reexport */ order_none; });
__webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return /* reexport */ reverse; });

// EXTERNAL MODULE: ./node_modules/d3-path/src/path.js
var path = __webpack_require__(520);

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function constant() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/arc.js




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ var src_arc = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = Object(path["a" /* default */])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi) {
          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ var linear = (function(context) {
  return new Linear(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/point.js
function point_x(p) {
  return p[0];
}

function point_y(p) {
  return p[1];
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/line.js





/* harmony default export */ var src_line = (function() {
  var x = point_x,
      y = point_y,
      defined = constant(true),
      context = null,
      curve = linear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = Object(path["a" /* default */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/area.js






/* harmony default export */ var src_area = (function() {
  var x0 = point_x,
      x1 = null,
      y0 = constant(0),
      y1 = point_y,
      defined = constant(true),
      context = null,
      curve = linear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = Object(path["a" /* default */])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return src_line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/identity.js
/* harmony default export */ var identity = (function(d) {
  return d;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/pie.js





/* harmony default export */ var src_pie = (function() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/radial.js


var curveRadialLinear = curveRadial(linear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/radialLine.js



function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ var src_radialLine = (function() {
  return radialLine(src_line().curve(curveRadialLinear));
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/radialArea.js




/* harmony default export */ var radialArea = (function() {
  var a = src_area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return radialLine(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return radialLine(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return radialLine(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return radialLine(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/circle.js


/* harmony default export */ var circle = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/cross.js
/* harmony default export */ var cross = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ var diamond = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/star.js


var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

/* harmony default export */ var star = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/square.js
/* harmony default export */ var square = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

/* harmony default export */ var triangle = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol/wye.js
var wye_c = -0.5,
    wye_s = Math.sqrt(3) / 2,
    wye_k = 1 / Math.sqrt(12),
    wye_a = (wye_k / 2 + 1) * 3;

/* harmony default export */ var wye = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / wye_a),
        x0 = r / 2,
        y0 = r * wye_k,
        x1 = x0,
        y1 = r * wye_k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(wye_c * x0 - wye_s * y0, wye_s * x0 + wye_c * y0);
    context.lineTo(wye_c * x1 - wye_s * y1, wye_s * x1 + wye_c * y1);
    context.lineTo(wye_c * x2 - wye_s * y2, wye_s * x2 + wye_c * y2);
    context.lineTo(wye_c * x0 + wye_s * y0, wye_c * y0 - wye_s * x0);
    context.lineTo(wye_c * x1 + wye_s * y1, wye_c * y1 - wye_s * x1);
    context.lineTo(wye_c * x2 + wye_s * y2, wye_c * y2 - wye_s * x2);
    context.closePath();
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/symbol.js










var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

/* harmony default export */ var src_symbol = (function() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = Object(path["a" /* default */])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/noop.js
/* harmony default export */ var noop = (function() {});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/basis.js
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basis = (function(context) {
  return new Basis(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/basisClosed.js



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basisClosed = (function(context) {
  return new BasisClosed(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/basisOpen.js


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ var basisOpen = (function(context) {
  return new BasisOpen(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/bundle.js


function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ var curve_bundle = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/cardinal.js
function cardinal_point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: cardinal_point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinal = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/cardinalClosed.js



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinalClosed = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/cardinalOpen.js


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: cardinal_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var cardinalOpen = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/catmullRom.js



function catmullRom_point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var curve_catmullRom = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/catmullRomClosed.js




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var catmullRomClosed = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/catmullRomOpen.js



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: catmullRom_point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ var catmullRomOpen = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/linearClosed.js


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ var linearClosed = (function(context) {
  return new LinearClosed(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/monotone.js
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function monotone_point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: monotone_point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; monotone_point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: monotone_point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ var natural = (function(context) {
  return new Natural(context);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ var step = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/offset/none.js
/* harmony default export */ var none = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/order/none.js
/* harmony default export */ var order_none = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/stack.js





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ var src_stack = (function() {
  var keys = constant([]),
      order = order_none,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? order_none : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/offset/expand.js


/* harmony default export */ var expand = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/offset/silhouette.js


/* harmony default export */ var silhouette = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/offset/wiggle.js


/* harmony default export */ var wiggle = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/order/ascending.js


/* harmony default export */ var ascending = (function(series) {
  var sums = series.map(ascending_sum);
  return order_none(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function ascending_sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/order/descending.js


/* harmony default export */ var order_descending = (function(series) {
  return ascending(series).reverse();
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/order/insideOut.js



/* harmony default export */ var insideOut = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(ascending_sum),
      order = order_none(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/src/order/reverse.js


/* harmony default export */ var reverse = (function(series) {
  return order_none(series).reverse();
});

// CONCATENATED MODULE: ./node_modules/viz-annotation/node_modules/d3-shape/index.js












































/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bisect", function() { return /* reexport */ bisect; });
__webpack_require__.d(__webpack_exports__, "bisectRight", function() { return /* reexport */ bisectRight; });
__webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return /* reexport */ bisectLeft; });
__webpack_require__.d(__webpack_exports__, "ascending", function() { return /* reexport */ ascending; });
__webpack_require__.d(__webpack_exports__, "bisector", function() { return /* reexport */ bisector; });
__webpack_require__.d(__webpack_exports__, "cross", function() { return /* reexport */ cross; });
__webpack_require__.d(__webpack_exports__, "descending", function() { return /* reexport */ descending; });
__webpack_require__.d(__webpack_exports__, "deviation", function() { return /* reexport */ deviation; });
__webpack_require__.d(__webpack_exports__, "extent", function() { return /* reexport */ extent; });
__webpack_require__.d(__webpack_exports__, "histogram", function() { return /* reexport */ src_histogram; });
__webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return /* reexport */ freedmanDiaconis; });
__webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return /* reexport */ scott; });
__webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return /* reexport */ sturges; });
__webpack_require__.d(__webpack_exports__, "max", function() { return /* reexport */ src_max; });
__webpack_require__.d(__webpack_exports__, "mean", function() { return /* reexport */ src_mean; });
__webpack_require__.d(__webpack_exports__, "median", function() { return /* reexport */ median; });
__webpack_require__.d(__webpack_exports__, "merge", function() { return /* reexport */ merge; });
__webpack_require__.d(__webpack_exports__, "min", function() { return /* reexport */ src_min; });
__webpack_require__.d(__webpack_exports__, "pairs", function() { return /* reexport */ pairs; });
__webpack_require__.d(__webpack_exports__, "permute", function() { return /* reexport */ permute; });
__webpack_require__.d(__webpack_exports__, "quantile", function() { return /* reexport */ quantile; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ range; });
__webpack_require__.d(__webpack_exports__, "scan", function() { return /* reexport */ scan; });
__webpack_require__.d(__webpack_exports__, "shuffle", function() { return /* reexport */ shuffle; });
__webpack_require__.d(__webpack_exports__, "sum", function() { return /* reexport */ src_sum; });
__webpack_require__.d(__webpack_exports__, "ticks", function() { return /* reexport */ ticks; });
__webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return /* reexport */ tickIncrement; });
__webpack_require__.d(__webpack_exports__, "tickStep", function() { return /* reexport */ tickStep; });
__webpack_require__.d(__webpack_exports__, "transpose", function() { return /* reexport */ src_transpose; });
__webpack_require__.d(__webpack_exports__, "variance", function() { return /* reexport */ variance; });
__webpack_require__.d(__webpack_exports__, "zip", function() { return /* reexport */ zip; });

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/bisector.js


/* harmony default export */ var bisector = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/cross.js


/* harmony default export */ var cross = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/variance.js


/* harmony default export */ var variance = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/deviation.js


/* harmony default export */ var deviation = (function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/range.js
/* harmony default export */ var range = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/histogram.js









/* harmony default export */ var src_histogram = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/quantile.js


/* harmony default export */ var quantile = (function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/threshold/scott.js


/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/mean.js


/* harmony default export */ var src_mean = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/median.js




/* harmony default export */ var median = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/merge.js
/* harmony default export */ var merge = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/scan.js


/* harmony default export */ var scan = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-sankey-circular/node_modules/d3-array/src/index.js





























/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "forceCenter", function() { return /* reexport */ center; });
__webpack_require__.d(__webpack_exports__, "forceCollide", function() { return /* reexport */ collide; });
__webpack_require__.d(__webpack_exports__, "forceLink", function() { return /* reexport */ src_link; });
__webpack_require__.d(__webpack_exports__, "forceManyBody", function() { return /* reexport */ manyBody; });
__webpack_require__.d(__webpack_exports__, "forceRadial", function() { return /* reexport */ radial; });
__webpack_require__.d(__webpack_exports__, "forceSimulation", function() { return /* reexport */ src_simulation; });
__webpack_require__.d(__webpack_exports__, "forceX", function() { return /* reexport */ d3_force_src_x; });
__webpack_require__.d(__webpack_exports__, "forceY", function() { return /* reexport */ d3_force_src_y; });

// CONCATENATED MODULE: ./node_modules/d3-force/src/center.js
/* harmony default export */ var center = (function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/jiggle.js
/* harmony default export */ var jiggle = (function() {
  return (Math.random() - 0.5) * 1e-6;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/add.js
/* harmony default export */ var add = (function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add_add(this.cover(x, y), x, y, d);
});

function add_add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add_add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/cover.js
/* harmony default export */ var cover = (function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/data.js
/* harmony default export */ var src_data = (function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/extent.js
/* harmony default export */ var extent = (function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/quad.js
/* harmony default export */ var src_quad = (function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/find.js


/* harmony default export */ var find = (function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new src_quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new src_quad(node[3], xm, ym, x2, y2),
        new src_quad(node[2], x1, ym, xm, y2),
        new src_quad(node[1], xm, y1, x2, ym),
        new src_quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/remove.js
/* harmony default export */ var remove = (function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
});

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/root.js
/* harmony default export */ var root = (function() {
  return this._root;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/size.js
/* harmony default export */ var size = (function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/visit.js


/* harmony default export */ var visit = (function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new src_quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new src_quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new src_quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new src_quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new src_quad(child, x0, y0, xm, ym));
    }
  }
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/visitAfter.js


/* harmony default export */ var visitAfter = (function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new src_quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new src_quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new src_quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new src_quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new src_quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}

/* harmony default export */ var src_x = (function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}

/* harmony default export */ var src_y = (function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
});

// CONCATENATED MODULE: ./node_modules/d3-quadtree/src/quadtree.js













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = add;
treeProto.addAll = addAll;
treeProto.cover = cover;
treeProto.data = src_data;
treeProto.extent = extent;
treeProto.find = find;
treeProto.remove = remove;
treeProto.removeAll = removeAll;
treeProto.root = root;
treeProto.size = size;
treeProto.visit = visit;
treeProto.visitAfter = visitAfter;
treeProto.x = src_x;
treeProto.y = src_y;

// CONCATENATED MODULE: ./node_modules/d3-force/src/collide.js




function collide_x(d) {
  return d.x + d.vx;
}

function collide_y(d) {
  return d.y + d.vy;
}

/* harmony default export */ var collide = (function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, collide_x, collide_y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  return force;
});

// EXTERNAL MODULE: ./node_modules/d3-collection/src/index.js + 6 modules
var src = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/d3-force/src/link.js




function index(d) {
  return d.index;
}

function link_find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

/* harmony default export */ var src_link = (function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = Object(src["map"])(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = link_find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = link_find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
  };

  return force;
});

// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(521);

// EXTERNAL MODULE: ./node_modules/d3-timer/src/timer.js
var timer = __webpack_require__(229);

// CONCATENATED MODULE: ./node_modules/d3-force/src/simulation.js




function simulation_x(d) {
  return d.x;
}

function simulation_y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ var src_simulation = (function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = Object(src["map"])(),
      stepper = Object(timer["c" /* timer */])(step),
      event = Object(dispatch["a" /* default */])("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.each(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/manyBody.js





/* harmony default export */ var manyBody = (function() {
  var nodes,
      node,
      alpha,
      strength = constant(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, simulation_x, simulation_y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/radial.js


/* harmony default export */ var radial = (function(radius, x, y) {
  var nodes,
      strength = constant(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/x.js


/* harmony default export */ var d3_force_src_x = (function(x) {
  var strength = constant(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
  };

  return force;
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/y.js


/* harmony default export */ var d3_force_src_y = (function(y) {
  var strength = constant(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
  };

  return force;
});

// CONCATENATED MODULE: ./node_modules/d3-force/src/index.js










/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

(function (factory) {
	 true ? (module['exports'] = factory()) :
		undefined
}(function () {

	'use strict'

	return function (insertRule) {
		var delimiter = '/*|*/'
		var needle = delimiter+'}'

		function toSheet (block) {
			if (block)
				try {
					insertRule(block + '}')
				} catch (e) {}
		}

		return function ruleSheet (context, content, selectors, parents, line, column, length, ns, depth, at) {
			switch (context) {
				// property
				case 1:
					// @import
					if (depth === 0 && content.charCodeAt(0) === 64)
						return insertRule(content+';'), ''
					break
				// selector
				case 2:
					if (ns === 0)
						return content + delimiter
					break
				// at-rule
				case 3:
					switch (ns) {
						// @font-face, @page
						case 102:
						case 112:
							return insertRule(selectors[0]+content), ''
						default:
							return content + (at === 0 ? delimiter : '')
					}
				case -2:
					content.split(needle).forEach(toSheet)
			}
		}
	}
}))


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ __webpack_exports__["a"] = (unitlessKeys);


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return timer; });
/* unused harmony export timerFlush */
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ var memoize_browser_esm = (memoize);

// CONCATENATED MODULE: ./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var index = memoize_browser_esm(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

/* harmony default export */ var is_prop_valid_browser_esm = __webpack_exports__["a"] = (index);


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: concatArrays, merge

// CONCATENATED MODULE: ./node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is {[key: string]: any}}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is {[key: string]: any}}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is {}}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is {[key: string]: any}}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function
 *
 * @param {*} payload
 * @returns {payload is Function}
 */
function isFunction(payload) {
    return getType(payload) === 'Function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number
 *
 * This will return false for NaN
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is `NaN` but also a `number`
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
function isNullOrUndefined(payload) {
    return isNull(payload) || isUndefined(payload);
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: ./node_modules/merge-anything/dist/index.esm.js


/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function assignProp(carry, key, newVal, originalObject) {
    var propType = originalObject.propertyIsEnumerable(key)
        ? 'enumerable'
        : 'nonenumerable';
    if (propType === 'enumerable')
        carry[key] = newVal;
    if (propType === 'nonenumerable') {
        Object.defineProperty(carry, key, {
            value: newVal,
            enumerable: false,
            writable: true,
            configurable: true
        });
    }
}
function mergeRecursively(origin, newComer, extensions) {
    // work directly on newComer if its not an object
    if (!isPlainObject(newComer)) {
        // extend merge rules
        if (extensions && isArray(extensions)) {
            extensions.forEach(function (extend) {
                newComer = extend(origin, newComer);
            });
        }
        return newComer;
    }
    // define newObject to merge all values upon
    var newObject = {};
    if (isPlainObject(origin)) {
        var props_1 = Object.getOwnPropertyNames(origin);
        var symbols_1 = Object.getOwnPropertySymbols(origin);
        newObject = __spreadArrays(props_1, symbols_1).reduce(function (carry, key) {
            // @ts-ignore
            var targetVal = origin[key];
            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||
                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {
                assignProp(carry, key, targetVal, origin);
            }
            return carry;
        }, {});
    }
    var props = Object.getOwnPropertyNames(newComer);
    var symbols = Object.getOwnPropertySymbols(newComer);
    var result = __spreadArrays(props, symbols).reduce(function (carry, key) {
        // re-define the origin and newComer as targetVal and newVal
        var newVal = newComer[key];
        var targetVal = (isPlainObject(origin))
            // @ts-ignore
            ? origin[key]
            : undefined;
        // extend merge rules
        if (extensions && isArray(extensions)) {
            extensions.forEach(function (extend) {
                newVal = extend(targetVal, newVal);
            });
        }
        // When newVal is an object do the merge recursively
        if (targetVal !== undefined && isPlainObject(newVal)) {
            newVal = mergeRecursively(targetVal, newVal, extensions);
        }
        assignProp(carry, key, newVal, newComer);
        return carry;
    }, newObject);
    return result;
}
/**
 * Merge anything recursively.
 * Objects get merged, special objects (classes etc.) are re-assigned "as is".
 * Basic types overwrite objects or other basic types.
 *
 * @param {(IConfig | any)} origin
 * @param {...any[]} newComers
 * @returns the result
 */
function merge(origin) {
    var newComers = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        newComers[_i - 1] = arguments[_i];
    }
    var extensions = null;
    var base = origin;
    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {
        base = {};
        extensions = origin.extensions;
    }
    return newComers.reduce(function (result, newComer) {
        return mergeRecursively(result, newComer, extensions);
    }, base);
}

function concatArrays(originVal, newVal) {
    if (isArray(originVal) && isArray(newVal)) {
        // concat logic
        return originVal.concat(newVal);
    }
    return newVal; // always return newVal as fallback!!
}

/* harmony default export */ var index_esm = __webpack_exports__["a"] = (merge);



/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cubehelix; });
/* unused harmony export Cubehelix */
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__[/* Rgb */ "b"])) o = Object(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* rgbConvert */ "h"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_2__[/* rad2deg */ "b"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Cubehelix, cubehelix, Object(_define_js__WEBPACK_IMPORTED_MODULE_0__[/* extend */ "b"])(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* Color */ "a"], {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__[/* brighter */ "c"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* brighter */ "c"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_1__[/* darker */ "d"] : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* darker */ "d"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_2__[/* deg2rad */ "a"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__[/* Rgb */ "b"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),
/* 233 */,
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(235), exports);


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataExplorer = void 0;
const react_dom_1 = __importDefault(__webpack_require__(236));
const data_explorer_1 = __webpack_require__(241);
const react_1 = __importDefault(__webpack_require__(0));
function createDataExplorer(settings) {
    react_dom_1.default.render(react_1.default.createElement(data_explorer_1.DataExplorer, { data: settings.data }), settings.container);
}
exports.createDataExplorer = createDataExplorer;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(237);
} else {}


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(0),n=__webpack_require__(155),r=__webpack_require__(239);function u(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(u(227));
function ba(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba.apply(ia,arguments)}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null}else throw Error(u(198));fa||(fa=!0,ha=l)}}var la=null,ma=null,na=null;
function oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null}var pa=null,qa={};
function ra(){if(pa)for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c))throw Error(u(96,a));if(!sa[c]){if(!b.extractEvents)throw Error(u(97,a));sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h))throw Error(u(99,h));ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ua(k[e],g,h);e=!0}else f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(u(98,d,a));}}}}
function ua(a,b,c){if(va[a])throw Error(u(100,a));va[a]=b;wa[a]=b.eventTypes[c].dependencies}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c])throw Error(u(102,c));qa[c]=d;b=!0}}b&&ra()}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;
function Ca(a){if(a=ma(a)){if("function"!==typeof za)throw Error(u(280));var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b))}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b)for(a=0;a<b.length;a++)Ca(b[a])}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba)Ha(),Ea()}
function Ma(a,b,c){if(Ka)return a(b,c);Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La()}}var Na=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};
function Ra(a){if(Oa.call(Qa,a))return!0;if(Oa.call(Pa,a))return!1;if(Na.test(a))return Qa[a]=!0;Pa[a]=!0;return!1}function Sa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}var C={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C[a]=new v(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C[b]=new v(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C[a]=new v(a,2,!1,a.toLowerCase(),null,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C[a]=new v(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C[a]=new v(a,3,!1,a.toLowerCase(),null,!1)});
["checked","multiple","muted","selected"].forEach(function(a){C[a]=new v(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){C[a]=new v(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){C[a]=new v(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){C[a]=new v(a,5,!1,a.toLowerCase(),null,!1)});var Ua=/[\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,
Va);C[b]=new v(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!1)});
C.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!0)});var Wa=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});
function Xa(a,b,c,d){var e=C.hasOwnProperty(b)?C[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
var Ya=/^(.*)[\\\/]/,E="function"===typeof Symbol&&Symbol.for,Za=E?Symbol.for("react.element"):60103,$a=E?Symbol.for("react.portal"):60106,ab=E?Symbol.for("react.fragment"):60107,bb=E?Symbol.for("react.strict_mode"):60108,cb=E?Symbol.for("react.profiler"):60114,db=E?Symbol.for("react.provider"):60109,eb=E?Symbol.for("react.context"):60110,fb=E?Symbol.for("react.concurrent_mode"):60111,gb=E?Symbol.for("react.forward_ref"):60112,hb=E?Symbol.for("react.suspense"):60113,ib=E?Symbol.for("react.suspense_list"):
60120,jb=E?Symbol.for("react.memo"):60115,kb=E?Symbol.for("react.lazy"):60116,lb=E?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a)return null;a=mb&&a[mb]||a["@@iterator"];return"function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}
function pb(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ab:return"Fragment";case $a:return"Portal";case cb:return"Profiler";case bb:return"StrictMode";case hb:return"Suspense";case ib:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case eb:return"Context.Consumer";case db:return"Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
"ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null)return pb(a)}return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}
function rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function sb(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a))}function yb(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
function Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1)}
function Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function Fb(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Gb(a,b){a=n({children:void 0},b);if(b=Fb(b.children))a.children=b;return a}
function Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Ib(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(u(91));return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(u(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(u(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:rb(c)}}
function Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Nb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var Pb,Qb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a)a.innerHTML=b;else{Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};
ya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a])return Ub[a];if(!Tb[a])return a;var b=Tb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Vb)return Ub[a]=b[c];return a}
var Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}
function dc(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function fc(a){if(dc(a)!==a)throw Error(u(188));}
function gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b)throw Error(u(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return fc(e),a;if(f===d)return fc(e),b;f=f.sibling}throw Error(u(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(u(189));}}if(c.alternate!==d)throw Error(u(190));}if(3!==c.tag)throw Error(u(188));return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
function ic(a,b){if(null==b)throw Error(u(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var kc=null;
function lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)oa(a,b[d],c[d]);else b&&oa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc)throw Error(u(95));if(fa)throw a=ha,fa=!1,ha=null,a;}}
function nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a)}
function rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}
function sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=
ic(h,l))}mc(h)}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F(a,b)}c.set(a,null)}}
var wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
function Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c)});Ic.forEach(function(a){uc(a,b,c)})}function Kc(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}
function Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId)}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a;a.eventSystemFlags|=d;return a}
function Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return!1}
function Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c)if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;r.unstable_runWithPriority(a.priority,function(){yc(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function Qc(a){if(null!==a.blockedOn)return!1;var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return!1}return!0}
function Sc(a,b,c){Qc(a)&&c.delete(b)}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift()}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc)}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Tc)))}
function Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++)d=Gc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);)Pc(c),null===c.blockedOn&&Gc.shift()}
var Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",
"seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f}}
ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);
ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++)Zc.set(bd[cd],0);
var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function F(a,b){vc(b,a,!1)}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a)}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1)}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d)}finally{(Ja=f)||La()}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d))}
function id(a,b,c,d){if(fd)if(0<Ac.length&&-1<Hc.indexOf(a))a=Kc(null,a,b,c,d),Ac.push(a);else{var e=Rc(a,b,c,d);if(null===e)Lc(a,d);else if(-1<Hc.indexOf(a))a=Kc(e,a,b,c,d),Ac.push(a);else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a)}finally{qc(a)}}}}
function Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e)c=null;else{var f=e.tag;if(13===f){c=ec(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=rc(a,d,c,b);try{Ma(sc,a)}finally{qc(a)}return null}
var jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a]})});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}
function md(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var nd=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(u(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(u(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(u(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(u(62,""));}}
function pd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++)uc(b[d],a,c)}function sd(){}
function td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=ud(c)}}
function wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=td(a.document)}return b}
function yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}
function Gd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}
function Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b)return a;b--}else c===Ad&&b++}a=a.previousSibling}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;
function tc(a){var b=a[Md];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Kd(a);null!==a;){if(c=a[Md])return c;a=Kd(a)}return b}a=c;c=a.parentNode}return null}function Nc(a){a=a[Md]||a[Od];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(u(33));}function Qd(a){return a[Nd]||null}
function Rd(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}
function Sd(a,b){var c=a.stateNode;if(!c)return null;var d=la(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(u(231,
b,typeof c));return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a)}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Rd(b);for(b=c.length;0<b--;)Td(c[b],"captured",a);for(b=0;b<c.length;b++)Td(c[b],"bubbled",a)}}
function Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a))}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a)}function Xd(a){jc(a,Ud)}var Yd=null,Zd=null,$d=null;
function ae(){if($d)return $d;var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return $d=e.slice(a,1<d?1-d:void 0)}function be(){return!0}function ce(){return!1}
function G(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}
n(G.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be)},persist:function(){this.isPersistent=be},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,
b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null}});G.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
G.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function fe(a){if(!(a instanceof this))throw Error(u(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe}var ge=G.extend({data:null}),he=G.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);
var le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;
function qe(a,b){switch(a){case "keyup":return-1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function re(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which)return null;pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}
function ue(a,b){if(se)return"compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}
var ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je)b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0}else se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart);f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,
b,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!we[a.type]:"textarea"===b?!0:!1}
var ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a)}function De(a){var b=Pd(a);if(yb(b))return a}function Ee(a,b){if("change"===a)return b}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));
function Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null)}function He(a){if("value"===a.propertyName&&De(Be))if(a=ze(Be,a,nc(a)),Ja)mc(a);else{Ja=!0;try{Fa(Ce,a)}finally{Ja=!1,La()}}}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge()}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return De(Be)}function Ke(a,b){if("click"===a)return De(b)}function Le(a,b){if("input"===a||"change"===a)return De(b)}
var Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ee;else if(xe(e))if(Fe)g=Le;else{g=Je;var h=Ie}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke);if(g&&(g=g(a,b)))return ze(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value)}},Ne=G.extend({view:null,detail:null}),
Oe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}
var Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
var b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
dependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===
a){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse"}else if("pointerout"===a||"pointerover"===a)k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer";a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p)a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a))g++;a=0;for(b=m;b;b=Rd(b))a++;for(;0<g-a;)k=Rd(k),g--;for(;0<a-g;)m=Rd(m),a--;for(;g--;){if(k===m||k===m.alternate)break a;
k=Rd(k);m=Rd(m)}k=null}else k=null;m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m)break;k.push(d);d=Rd(d)}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m)break;d.push(p);p=Rd(p)}for(p=0;p<k.length;p++)Vd(k[p],"bubbled",l);for(p=d.length;0<p--;)Vd(d[p],"captured",c);return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;
function bf(a,b){if($e(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]]))return!1;return!0}
var cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;
function jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c))return null;c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}
var kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable)ef=e,ff=b,gf=null;break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf)break;
case "keydown":case "keyup":return jf(c,d)}return null}},lf=G.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
var pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return"keypress"===
a.type?of(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in
a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e)return null;switch(a){case "keypress":if(0===of(c))return null;case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=
Ve;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=
We;break;default:a=G}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa)throw Error(u(101));pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--)}
function I(a,b){zf++;yf[zf]=a.current;a.current=b}var Af={},J={current:Af},K={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c)return Af;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L(a){a=a.childContextTypes;return null!==a&&void 0!==a}
function Df(){H(K);H(J)}function Ef(a,b,c){if(J.current!==Af)throw Error(u(168));I(J,b);I(K,c)}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(u(108,pb(b)||"Unknown",e));return n({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J.current;I(J,a);I(K,K.current);return!0}
function Hf(a,b,c){var d=a.stateNode;if(!d)throw Error(u(169));c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H(K),H(J),I(J,a)):H(K);I(K,c)}
var If=r.unstable_runWithPriority,Jf=r.unstable_scheduleCallback,Kf=r.unstable_cancelCallback,Lf=r.unstable_requestPaint,Mf=r.unstable_now,Nf=r.unstable_getCurrentPriorityLevel,Of=r.unstable_ImmediatePriority,Pf=r.unstable_UserBlockingPriority,Qf=r.unstable_NormalPriority,Rf=r.unstable_LowPriority,Sf=r.unstable_IdlePriority,Tf={},Uf=r.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};
function ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a)}fg()}
function fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});Wf=null}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null}
function og(a){var b=jg.current;H(jg);a.type._context._currentValue=b}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null)}
function sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)mg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg)throw Error(u(308));lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null}}else lg=lg.next=b}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}
function vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}
function yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}
function zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g))}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=
ca,m=k):x=x.next=ca;g>l&&(l=g)}else{null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g)break a;k=n({},k,g);break a;case 2:tg=!0}}null!==z.callback&&
(a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z))}z=z.next;if(null===z||z===h)if(g=e.shared.pending,null===g)break;else z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k}}
function Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(u(191,d));d.call(e)}}}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new aa.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}
var Jg={isMounted:function(a){return(a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;
c=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c)}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}
function Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L(b)?Bf:J.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null)}
function Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L(b)?Bf:J.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var Og=Array.isArray;
function Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(u(309));var d=c.stateNode}if(!d)throw Error(u(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(u(284));if(!c._owner)throw Error(u(290,a));}return a}
function Qg(a,b){if("textarea"!==a.type)throw Error(u(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
function Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Tg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d;d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=Vg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Wg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Tg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||
nb(b))return b=Wg(b,a.mode,c,null),b.return=a,b;Qg(a,b)}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c))return null!==e?null:m(a,b,c,d,null);Qg(a,c)}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d))return a=a.get(c)||null,m(b,a,d,e,null);Qg(b,d)}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&
m&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A}if(y===h.length)return c(e,m),l;if(null===m){for(;y<h.length;y++)m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m);return l}for(m=d(e,m);y<h.length;y++)A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A);a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k)throw Error(u(150));h=k.call(h);
if(null==h)throw Error(u(151));for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A}if(q.done)return c(e,t),k;if(null===t){for(;!q.done;y++,q=h.next())q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);return k}for(t=d(e,t);!q.done;y++,q=h.next())q=z(t,e,y,q.value,l),null!==q&&(a&&null!==
q.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,
k.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h)}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=
d.sibling}d=Vg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a);if(Og(f))return ca(a,d,f,h);if(nb(f))return D(a,d,f,h);l&&Qg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(u(152,a.displayName||a.name||"Component"));}return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};
function ch(a){if(a===Zg)throw Error(u(174));return a}function dh(a,b){I(bh,b);I(ah,a);I($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a)}H($g);I($g,b)}function eh(){H($g);H(ah);H(bh)}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I(ah,a),I($g,c))}function gh(a){ah.current===a&&(H($g),H(ah))}var M={current:0};
function hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ih(a,b){return{responder:a,props:b}}
var jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N=null,O=null,P=null,mh=!1;function Q(){throw Error(u(321));}function nh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!$e(a[c],b[c]))return!1;return!0}
function oh(a,b,c,d,e,f){lh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(u(301));f+=1;P=O=null;b.updateQueue=null;jh.current=rh;a=c(d,e)}while(b.expirationTime===lh)}jh.current=sh;b=null!==O&&null!==O.next;lh=0;P=O=N=null;mh=!1;if(b)throw Error(u(300));return a}
function th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function uh(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(u(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}
function vh(a,b){return"function"===typeof b?b(a):b}
function wh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N.expirationTime&&
(N.expirationTime=l,Bg(l))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action);k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}
function xh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}
function yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N,a);return[b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}
function Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d)}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d)}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}
function Hh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0)});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c()}finally{kh.suspense=d}})}
function zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N||null!==f&&f===N)mh=!0,e.expirationTime=lh,N.expirationTime=lh;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g))return}catch(k){}finally{}Ig(a,
d)}}
var sh={readContext:sg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useResponder:Q,useDeferredValue:Q,useTransition:Q},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,
b];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=
c}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return[Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
wh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,
b,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}
function Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}
function Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c)}Oh=a;Ph=Jd(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Oh=a}
function Wh(a){if(a!==Oh)return!1;if(!Qh)return Vh(a),Qh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps))for(b=Ph;b;)Rh(a,b),b=Jd(b.nextSibling);Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(u(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--}else c!==zd&&c!==Cd&&c!==Bd||b++}a=a.nextSibling}Ph=null}}else Ph=Oh?Jd(a.stateNode.nextSibling):null;return!0}
function Xh(){Ph=Oh=null;Qh=!1}var Yh=Wa.ReactCurrentOwner,rg=!1;function R(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d)}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,d,e);return b.child}
function ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ci(a,b,g,d,e,f);a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref))return $h(a,b,f);b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
function ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function di(a,b,c,d,e){var f=L(c)?Bf:J.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,c,e);return b.child}
function fi(a,b,c,d,e){if(L(c)){var f=!0;Gf(b)}else f=!1;qg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===
typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
x,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):
("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return gi(a,b,c,d,f,e)}
function gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hf(b,c,!1),$h(a,b,f);d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo)}
var ii={dehydrated:null,retryTime:0};
function ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I(M,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=
b;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=
c}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}
function ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b)}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}
function mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&ki(a,c);else if(19===a.tag)ki(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(M,d);if(0===(b.mode&2))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}
function $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(u(153));if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}var ni,oi,pi,qi;
ni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};oi=function(){};
pi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd)}od(c,d);var h,k;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===
h)for(k in g=f[h],g)g.hasOwnProperty(k)&&(c||(c={}),c[k]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g))if("style"===h)if(g){for(k in g)!g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]="");for(k in l)l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),
c[k]=l[k])}else c||(a||(a=[]),a.push(h,c)),c=l;else"dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};
qi=function(a,b,c,d){c!==d&&(b.effectTag|=4)};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L(b.type)&&Df(),null;case 3:return eh(),H(K),H(J),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode)pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(u(166));
return null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++)F(ac[a],d);break;case "source":F("error",d);break;case "img":case "image":case "link":F("error",d);F("load",d);break;case "form":F("reset",d);F("submit",d);break;case "details":F("toggle",d);break;case "input":Ab(d,f);F("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=
{wasMultiple:!!f.multiple};F("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F("invalid",d),rd(c,"onChange")}od(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g)}switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&
(d.onclick=sd)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F("load",
a);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++)F(ac[h],a);h=d;break;case "source":F("error",a);h=d;break;case "img":case "image":case "link":F("error",a);F("load",a);h=d;break;case "form":F("reset",a);F("submit",a);h=d;break;case "details":F("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=n({},d,{value:void 0});F("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,
d);h=Ib(a,d);F("invalid",a);rd(c,"onChange");break;default:h=d}od(e,h);var k=h;for(f in k)if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g))}switch(e){case "input":xb(a);Eb(a,d,!1);
break;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd)}Fd(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)qi(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(u(166));
c=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c)}return null;case 13:H(M);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=
e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M.current&1))S===ti&&(S=ui);else{if(S===ti||S===ui)S=vi;0!==wi&&null!==T&&(xi(T,U),yi(T,wi))}if(c||d)b.effectTag|=4;return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L(b.type)&&Df(),null;case 19:H(M);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)ri(d,!1);else{if(S!==ti||null!==a&&0!==(a.effectTag&
64))for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,
e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;I(M,M.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=
b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M.current,I(M,e?b&1|2:b&1),c):null}throw Error(u(156,
b.tag));}function zi(a){switch(a.tag){case 1:L(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H(K);H(J);b=a.effectTag;if(0!==(b&64))throw Error(u(285));a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H(M),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H(M),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return{value:a,source:b,stack:qb(b)}}
var Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Ei(a,c)}}function Fi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Ei(a,c)}else b.current=null}
function Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u(163));}
function Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}
function Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4)if(null===b)a.componentDidMount();else{var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Cg(c,b,a)}return;
case 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u(163));}
function Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Ei(g,h)}}a=a.next}while(a!==d)})}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c)}}
function Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b)}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}
function Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return}throw Error(u(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b)}
function Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd));else if(4!==d&&(a=a.child,null!==a))for(Qi(a,b,c),a=a.sibling;null!==a;)Qi(a,b,c),a=a.sibling}
function Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Ri(a,b,c),a=a.sibling;null!==a;)Ri(a,b,c),a=a.sibling}
function Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(u(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Ki(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else{if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return}m.sibling.return=m.return;m=m.sibling}g?(h=
f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}
function Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b)}switch(a){case "input":Cb(c,d);break;
case "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(u(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?
d=!1:(d=!0,c=b.child,Ti=$f());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=
f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
var Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b)};return c}
function $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
var bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W=V,T=null,X=null,U=0,S=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return(W&(fj|gj))!==V?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}
function Hg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=ag();if(0===(b&4))return 99===d?1073741823:1073741822;if((W&fj)!==V)return U;if(null!==c)a=hg(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u(326));}null!==T&&a===U&&--a;return a}
function Ig(a,b){if(50<uj)throw uj=0,vj=null,Error(u(185));a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W&ej)!==V&&(W&(fj|gj))===V?yj(a):(Z(a),W===V&&gg()):Z(a);(W&4)===V||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)))}}
function xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(T===e&&(Bg(b),S===vi&&xi(e,U)),yi(e,b));return e}
function zj(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Aj(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}
function Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a));else{var b=zj(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Tf&&Kf(c)}a.callbackExpirationTime=
b;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b}}}
function Bj(a,b){wj=0;if(b)return b=Gg(),Cj(a,b),Z(a),null;var c=zj(a);if(0!==c){b=a.callbackNode;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&c===U||Ej(a,c);if(null!==X){var d=W;W|=fj;var e=Fj();do try{Gj();break}catch(h){Hj(a,h)}while(1);ng();W=d;cj.current=e;if(S===hj)throw b=kj,Ej(a,c),xi(a,c),Z(a),b;if(null===X)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S,T=null,d){case ti:case hj:throw Error(u(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;
c===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
d;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=
Hd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u(329));}Z(a);if(a.callbackNode===b)return Bj.bind(null,a)}}return null}
function yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&b===U||Ej(a,b);if(null!==X){var c=W;W|=fj;var d=Fj();do try{Kj();break}catch(e){Hj(a,e)}while(1);ng();W=c;cj.current=d;if(S===hj)throw c=kj,Ej(a,b),xi(a,b),Z(a),c;if(null!==X)throw Error(u(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T=null;Jj(a);Z(a)}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z(c)});gg()}}
function Mj(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,W===V&&gg()}}function Nj(a,b){var c=W;W&=-2;W|=ej;try{return a(b)}finally{W=c,W===V&&gg()}}
function Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X)for(c=X.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H(K);H(J);break;case 5:gh(d);break;case 4:eh();break;case 13:H(M);break;case 19:H(M);break;case 10:og(d)}c=c.return}T=a;X=Sg(a.current,null);U=b;S=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1}
function Hj(a,b){do{try{ng();jh.current=sh;if(mh)for(var c=N.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}lh=0;P=O=N=null;mh=!1;if(null===X||null===X.return)return S=hj,kj=b,X=null;a:{var e=a,f=X.return,g=X,h=b;b=U;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=
null,g.memoizedState=null)}var m=0!==(M.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z)x=null!==z.dehydrated?!0:!1;else{var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t}else D.add(k);if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var y=wg(1073741823,null);y.tag=2;xg(g,y)}g.expirationTime=1073741823;
break a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q)}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g))}S!==
jj&&(S=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return}while(null!==p)}X=Pj(X)}catch(Xc){b=Xc;continue}break}while(1)}
function Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b)}function Bg(a){a>wi&&(wi=a)}function Kj(){for(;null!==X;)X=Qj(X)}function Gj(){for(;null!==X&&!Uf();)X=Qj(X)}function Qj(a){var b=Rj(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}
function Pj(a){X=a;do{var b=X.alternate;a=X.return;if(0===(X.effectTag&2048)){b=si(b,X,U);if(1===U||1!==X.childExpirationTime){for(var c=0,d=X.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}X.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X.firstEffect),null!==X.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X.firstEffect),a.lastEffect=X.lastEffect),1<X.effectTag&&(null!==
a.lastEffect?a.lastEffect.nextEffect=X:a.firstEffect=X,a.lastEffect=X))}else{b=zi(X);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048)}b=X.sibling;if(null!==b)return b;X=a}while(null!==X);S===ti&&(S=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}
function Sj(a,b){do Dj();while(null!==rj);if((W&(fj|gj))!==V)throw Error(u(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(u(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T&&(X=T=null,U=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W;W|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,
m=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild))break;y=t;t=A}for(;;){if(t===g)break b;y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling))break;t=y;y=t.parentNode}t=A}h=-1===x||-1===z?null:{start:x,end:z}}else h=null}h=h||{start:0,end:0}}else h=
null;Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y=e;do try{Tj()}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(g=a,h=b;null!==Y;){var q=Y.effectTag;q&16&&Rb(Y.stateNode,"");if(q&128){var B=Y.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null)}}switch(q&1038){case 2:Pi(Y);Y.effectTag&=-3;break;case 6:Pi(Y);Y.effectTag&=-3;Si(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=
-1025;Si(Y.alternate,Y);break;case 4:Si(Y.alternate,Y);break;case 8:l=Y,Mi(g,l,h),Ni(l)}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&
(w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;)1===w.nodeType&&B.push({element:w,left:w.scrollLeft,
top:w.scrollTop});"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++)w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top}fd=!!Dd;Ed=Dd=null;a.current=c;Y=e;do try{for(q=a;null!==Y;){var ub=Y.effectTag;ub&36&&Ji(q,Y.alternate,Y);if(ub&128){B=void 0;var vb=Y.ref;if(null!==vb){var Xc=Y.stateNode;switch(Y.tag){case 5:B=Xc;break;default:B=Xc}"function"===typeof vb?vb(B):vb.current=B}}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=
null;Vf();W=f}else a.current=c;if(qj)qj=!1,rj=a,sj=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z(a);if(Yi)throw Yi=!1,a=Zi,Zi=null,a;if((W&ej)!==V)return null;gg();return null}function Tj(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Gi(Y.alternate,Y);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y=Y.nextEffect}}
function Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj)return!1;var a=rj;rj=null;if((W&(fj|gj))!==V)throw Error(u(331));var b=W;W|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c)}}catch(d){if(null===a)throw Error(u(330));Ei(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}W=b;gg();return!0}
function Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z(a)}function Ei(a,b){if(3===a.tag)Wj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z(c);break}}c=c.return}}
function Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T===a&&U===c?S===vi||S===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z(a)))}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z(a)}var Rj;
Rj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K.current)rg=!0;else{if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:L(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return ji(a,b,c);I(M,M.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I(M,M.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return mi(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I(M,M.current);if(!d)return null}return $h(a,b,c)}rg=!1}}else rg=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J.current);qg(b,c);e=oh(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L(d)){var f=!0;Gf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c)}else b.tag=0,R(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);
case 3:hi(b);d=b.updateQueue;if(null===a||null===d)throw Error(u(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e)Xh(),b=$h(a,b,c);else{if(e=b.stateNode.hydrate)Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0;if(e)for(c=Yg(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else R(a,b,d,c),Xh();b=b.child}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R(a,b,b.pendingProps,c),b.child;case 8:return R(a,
b,b.pendingProps.children,c),b.child;case 12:return R(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(jg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K.current){b=$h(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==
k){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}R(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,
b,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}
function Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Sh(a,b,c,d){return new Zj(a,b,c,d)}
function bi(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a)return bi(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb)return 11;if(a===jb)return 14}return 2}
function Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bi(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case db:g=
10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a}throw Error(u(130,null==a?a:typeof a,""));}b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}
function Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}
function Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}
function yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag)throw Error(u(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(u(171));}if(1===c.tag){var k=c.type;if(L(k)){c=Ff(c,k,h);break a}}c=h}else c=Af;null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b)}
function fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null)};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null})};
function gk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new fk(a,0,b?{hydrate:!0}:void 0)}
function ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a)}}bk(b,g,a,e)}else{f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a)}}Nj(function(){bk(b,g,a,e)})}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
wc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b)}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3))};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b)}};
za=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e)throw Error(u(90));yb(d);Cb(d,e)}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1)}};Fa=Mj;
Ga=function(a,b,c,d,e){var f=W;W|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W=f,W===V&&gg()}};Ha=function(){(W&(1|fj|gj))===V&&(Lj(),Dj())};Ia=function(a,b){var c=W;W|=2;try{return a(b)}finally{W=c,W===V&&gg()}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b))throw Error(u(200));return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd)},Da,Ea,id,mc,Dj,{current:!1}]};
(function(a){var b=a.findFiberByHostInstance;return Yj(n({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.13.1",
rendererPackageName:"react-dom"});exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lk;exports.createPortal=kk;exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(u(188));throw Error(u(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};
exports.flushSync=function(a,b){if((W&(fj|gj))!==V)throw Error(u(187));var c=W;W|=1;try{return cg(99,a.bind(null,b))}finally{W=c,gg()}};exports.hydrate=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!0,c)};exports.render=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!1,c)};
exports.unmountComponentAtNode=function(a){if(!gk(a))throw Error(u(40));return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null})}),!0):!1};exports.unstable_batchedUpdates=Mj;exports.unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c))throw Error(u(200));if(null==a||void 0===a._reactInternalFiber)throw Error(u(38));return ik(a,b,c,!1,d)};exports.version="16.13.1";


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var l=__webpack_require__(155),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.13.1";


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(240);
} else {}


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.19.1
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var f,g,h,k,l;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,
y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===
typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}
function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}
function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};
exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};
exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DataExplorer_1 = __webpack_require__(242);
Object.defineProperty(exports, "default", { enumerable: true, get: function () { return DataExplorer_1.DataExplorer; } });
Object.defineProperty(exports, "DataExplorer", { enumerable: true, get: function () { return DataExplorer_1.DataExplorer; } });
var Toolbar_1 = __webpack_require__(222);
Object.defineProperty(exports, "Toolbar", { enumerable: true, get: function () { return Toolbar_1.Toolbar; } });
var Viz_1 = __webpack_require__(221);
Object.defineProperty(exports, "Viz", { enumerable: true, get: function () { return Viz_1.Viz; } });


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataExplorer = exports.default = void 0;
const React = __importStar(__webpack_require__(0));
const grid_1 = __importDefault(__webpack_require__(243));
const settings_1 = __webpack_require__(253);
const settings_2 = __webpack_require__(506);
const VizControls_1 = __importDefault(__webpack_require__(507));
const HTMLLegend_1 = __importDefault(__webpack_require__(72));
const FacetControls_1 = __importDefault(__webpack_require__(508));
const Viz_1 = __webpack_require__(221);
const Toolbar_1 = __webpack_require__(222);
const styled_components_1 = __importDefault(__webpack_require__(19));
const Dx = __importStar(__webpack_require__(511));
const semiotic_1 = __webpack_require__(81);
const d3_array_1 = __webpack_require__(23);
const mediaType = "application/vnd.dataresource+json";
const generateChartKey = ({ view, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, chart }) => `${view}-${lineType}-${areaType}-${selectedDimensions.join(",")}-${selectedMetrics.join(",")}-${pieceType}-${summaryType}-${networkType}-${hierarchyType}-${trendLine}-${marginalGraphics}-${barGrouping}-${JSON.stringify(chart)}`;
/*
  contour is an option for scatterplot
  pie is a transform on bar
*/
const defaultResponsiveSize = [440, 300];
const MetadataWarningWrapper = styled_components_1.default.div `
  & {
    font-family: Source Sans Pro, Helvetica Neue, Helvetica, Arial, sans-serif;
  }
`;
const MetadataWarningContent = styled_components_1.default.div `
  & {
    background: #cce;
    padding: 10px;
    padding-left: 20px;
  }
`;
const MetadataWarning = ({ metadata }) => {
    const warning = metadata && metadata.sampled ? (React.createElement("span", null,
        React.createElement("b", null, "NOTE:"),
        " This data is sampled")) : null;
    return (React.createElement(MetadataWarningWrapper, null, warning ? (React.createElement(MetadataWarningContent, null, warning)) : null));
};
const FlexWrapper = styled_components_1.default.div `
  display: flex;
  flex-flow: row nowrap;
  width: 100%;
`;
const FacetWrapper = styled_components_1.default.div `
  display: flex;
  flex-flow: wrap;
  min-width: 0;

  .responsive-container {
    flex: 1 0 calc(50% - 10px);
    margin: 5px;
  }
`;
const SemioticWrapper = styled_components_1.default.div `
  width: 100%;
  .html-legend-item {
    color: var(--theme-app-fg);
  }

  .tick > path {
    stroke: lightgray;
  }

  .axis-labels,
  .ordinal-labels {
    fill: var(--theme-app-fg);
    font-size: 14px;
  }

  path.connector,
  path.connector-end {
    stroke: var(--theme-app-fg);
  }

  path.connector-end {
    fill: var(--theme-app-fg);
  }

  text.annotation-note-label,
  text.legend-title,
  .legend-item text {
    fill: var(--theme-app-fg);
    stroke: none;
  }

  .xyframe-area > path {
    stroke: var(--theme-app-fg);
  }

  .axis-baseline {
    stroke-opacity: 0.25;
    stroke: var(--theme-app-fg);
  }
  circle.frame-hover {
    fill: none;
    stroke: gray;
  }
  .rect {
    stroke: green;
    stroke-width: 5px;
    stroke-opacity: 0.5;
  }
  rect.selection {
    opacity: 0.5;
  }
`;
const processInitialData = (props, existingView, existingDX, filteredData) => {
    const { metadata, initialView, overrideSettings } = props;
    // Handle case of metadata being empty yet dx not set
    const dx = existingDX || metadata.dx || { chart: {}, facets: undefined };
    const { chart = {}, facets } = dx, nonChartDXSettings = __rest(dx, ["chart", "facets"]);
    let { fields = [], primaryKey = [] } = props.data.schema;
    // Provide a default primaryKey if none provided
    if (primaryKey.length === 0) {
        primaryKey = [Dx.defaultPrimaryKey];
        fields = [...fields, { name: Dx.defaultPrimaryKey, type: "integer" }];
    }
    const dimensions = fields
        .filter(field => field.type === "string" ||
        field.type === "boolean" ||
        field.type === "datetime")
        .map(field => (Object.assign({ cardinality: 0, cardinalValues: [], unfilteredCardinality: 0, unfilteredCardinalValues: [] }, field)));
    // Should datetime data types be transformed into js dates before getting to this resource?
    const baseData = filteredData || props.data.data;
    const data = baseData.map((datapoint, datapointIndex) => {
        const mappedDatapoint = Object.assign({}, datapoint);
        fields.forEach(field => {
            if (field.name === Dx.defaultPrimaryKey) {
                mappedDatapoint[Dx.defaultPrimaryKey] = datapointIndex;
            }
            if (field.type === "datetime") {
                mappedDatapoint[field.name] = new Date(mappedDatapoint[field.name]);
            }
        });
        return mappedDatapoint;
    });
    let largeDataset = true;
    let selectedDimensions = [];
    const metrics = fields
        .filter(field => field.type === "integer" ||
        field.type === "number" ||
        field.type === "datetime")
        .filter(field => !primaryKey.find(pkey => pkey === field.name)).map(d => (Object.assign({}, d)));
    if (data.length < 5000) {
        largeDataset = false;
    }
    if (data.length < 100000) {
        metrics.forEach(m => {
            if (!m.extent) {
                m.extent = d3_array_1.extent(data.map(d => d[m.name]));
            }
            if (!m.unfilteredExtent) {
                if (m.type === "datetime") {
                    m.unfilteredExtent = filteredData ? d3_array_1.extent(props.data.data.map(d => new Date(d[m.name]))) : m.extent;
                }
                else {
                    m.unfilteredExtent = filteredData ? d3_array_1.extent(props.data.data.map(d => d[m.name])) : m.extent;
                }
            }
        });
        dimensions.forEach(dim => {
            if (dim.cardinality === 0) {
                const cardinalityHash = {};
                cardinalityHash[dim.name] = {};
                data.forEach(datapoint => {
                    const dimValue = datapoint[dim.name];
                    cardinalityHash[dim.name][dimValue] = true;
                });
                const dimKeys = Object.keys(cardinalityHash[dim.name]);
                dim.cardinality = dimKeys.length;
                dim.cardinalValues = dimKeys;
            }
            if (dim.unfilteredCardinality === 0) {
                if (!filteredData) {
                    dim.unfilteredCardinality = dim.cardinality;
                    dim.unfilteredCardinalValues = dim.cardinalValues;
                }
                const cardinalityHash = {};
                cardinalityHash[dim.name] = {};
                props.data.data.forEach(datapoint => {
                    const dimValue = datapoint[dim.name];
                    cardinalityHash[dim.name][dimValue] = true;
                });
                const dimKeys = Object.keys(cardinalityHash[dim.name]);
                dim.unfilteredCardinality = dimKeys.length;
                dim.unfilteredCardinalValues = dimKeys;
            }
        });
        selectedDimensions = dimensions
            .sort((a, b) => a.cardinality - b.cardinality)
            .filter((data, index) => index === 0)
            .map(dim => dim.name);
    }
    const finalChartSettings = Object.assign({ metric1: (metrics[0] && metrics[0].name) || "none", metric2: (metrics[1] && metrics[1].name) || "none", metric3: "none", metric4: "none", dim1: (dimensions[0] && dimensions[0].name) || "none", dim2: (dimensions[1] && dimensions[1].name) || "none", dim3: "none", timeseriesSort: "array-order", networkLabel: "none" }, chart);
    const displayChart = {};
    let newState = {
        largeDataset,
        view: existingView || initialView,
        lineType: "line",
        areaType: "hexbin",
        trendLine: "none",
        marginalGraphics: "none",
        barGrouping: "Clustered",
        selectedDimensions,
        selectedMetrics: [],
        pieceType: "bar",
        summaryType: "violin",
        networkType: "force",
        hierarchyType: "dendrogram",
        dimensions,
        metrics,
        colors: settings_2.colors,
        // ui: {},
        chart: finalChartSettings,
        overrideSettings,
        displayChart,
        primaryKey,
        data,
        editable: true,
        showLegend: true,
        facets,
        schema: props.data.schema,
        props
    };
    if (!filteredData) {
        newState = Object.assign(Object.assign({}, newState), nonChartDXSettings);
    }
    else {
        newState = Object.assign(Object.assign(Object.assign({}, newState), nonChartDXSettings), { metrics,
            dimensions,
            data });
    }
    return newState;
};
class DataExplorer extends React.PureComponent {
    constructor(props) {
        super(props);
        this.filterData = (filterFn, useBaseData) => {
            const _a = this.state, { data, props, view, metrics, dimensions } = _a, remainingState = __rest(_a, ["data", "props", "view", "metrics", "dimensions"]);
            if (!filterFn) {
                this.updateChart(processInitialData(props, view, remainingState));
                return;
            }
            const { filteredData = data } = this.state;
            let newFilteredData = [];
            if (useBaseData) {
                newFilteredData = filterFn(props.data.data);
            }
            else {
                newFilteredData = filterFn(filteredData);
            }
            const newState = processInitialData(props, view, this.state, newFilteredData);
            this.updateChart(newState);
        };
        this.updateChart = (updatedState) => {
            const { view, dimensions, metrics, chart, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, colors, primaryKey, editable, showLegend, data: stateData, facets, overrideSettings, } = Object.assign(Object.assign({}, this.state), updatedState);
            if (!this.props.data && !this.props.metadata) {
                return;
            }
            let instantiatedView;
            const { data, height, OverrideVizControls, OverrideLegend, additionalViews } = this.props;
            const chartKey = generateChartKey({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                chart,
                trendLine,
                marginalGraphics,
                barGrouping
            });
            const extendedSettings = Object.assign(Object.assign({}, settings_1.semioticSettings), additionalViews);
            if (!view || view === "grid") {
                instantiatedView = React.createElement(grid_1.default, Object.assign({}, this.props));
            }
            else {
                const { Frame, chartGenerator } = extendedSettings[view];
                const chartSettings = {
                    metrics,
                    dimensions,
                    chart,
                    colors,
                    height,
                    lineType,
                    areaType,
                    selectedDimensions,
                    selectedMetrics,
                    pieceType,
                    summaryType,
                    networkType,
                    hierarchyType,
                    primaryKey,
                    trendLine,
                    marginalGraphics,
                    barGrouping,
                    setColor: this.setColor,
                    filterData: this.filterData,
                    showLegend
                };
                const baseFrameSettings = chartGenerator(stateData, data.schema, chartSettings);
                const { frameSettings } = baseFrameSettings;
                const frameOverride = typeof overrideSettings === "function" ? overrideSettings(chartSettings, baseFrameSettings, data, view) : overrideSettings;
                instantiatedView = React.createElement(Frame, Object.assign({ responsiveWidth: true, size: defaultResponsiveSize }, frameSettings, frameOverride));
            }
            let finalRenderedViz;
            if (facets && facets.length > 0) {
                let colorHashOverride;
                let colorDimOverride;
                const facetFrames = [];
                facets
                    .forEach((baseDXSettings, facetIndex) => {
                    const { dimFacet, initialView = view, data: facetDataSettings = this.state, metadata: facetMetadata = { dx: {} } } = baseDXSettings;
                    if (initialView === "grid") {
                        const facetGridProps = Object.assign(Object.assign({}, this.props), baseDXSettings);
                        facetFrames.push(React.createElement(grid_1.default, Object.assign({}, facetGridProps)));
                    }
                    else {
                        const { dx: facetDX = {} } = facetMetadata;
                        const { FacetFrame, chartGenerator: facetChartGenerator } = extendedSettings[initialView];
                        const { data: facetData, schema: facetSchema } = facetDataSettings;
                        const filteredFacetData = dimFacet ? facetData.filter(d => d[dimFacet.dim] === dimFacet.value) : facetData;
                        const title = dimFacet ? `${dimFacet.dim}=${dimFacet.value}` : "";
                        const facetChartSettings = Object.assign({ metrics,
                            dimensions, chart: Object.assign(Object.assign({}, chart), facetDX), colors,
                            height,
                            lineType,
                            areaType,
                            selectedDimensions,
                            selectedMetrics,
                            pieceType,
                            summaryType,
                            networkType,
                            hierarchyType,
                            primaryKey,
                            trendLine,
                            marginalGraphics,
                            barGrouping, setColor: this.setColor, filterData: this.filterData, showLegend }, facetDX);
                        const facetFrameSettings = facetChartGenerator(filteredFacetData, facetSchema, facetChartSettings, colorHashOverride, colorDimOverride);
                        const { colorHash, frameSettings, colorDim } = facetFrameSettings;
                        colorHashOverride = colorHashOverride || colorHash;
                        colorDimOverride = colorDimOverride || colorDim;
                        const facetOverride = typeof overrideSettings === "function" ? overrideSettings(facetChartSettings, facetFrameSettings, facetDataSettings, view) : overrideSettings;
                        facetFrames.push(React.createElement(FacetFrame, Object.assign({}, frameSettings, { beforeElements: React.createElement(FacetControls_1.default, { focusFunction: (dxSettings) => {
                                    this.updateChart({ chart: Object.assign(Object.assign({}, chart), dxSettings.dx), view: initialView, facets: [] });
                                }, removeFunction: (facetIndex) => { this.updateChart({ facets: facets.filter((d, i) => i !== facetIndex) }); }, dxSettings: facetMetadata, facetIndex: facetIndex }), size: defaultResponsiveSize, afterElements: null, margin: Object.assign(Object.assign({}, frameSettings.margin), { left: 55, right: 25, top: 25 }), title: title }, facetOverride)));
                    }
                });
                const ActualLegend = OverrideLegend ? OverrideLegend : HTMLLegend_1.default;
                finalRenderedViz = React.createElement(FacetWrapper, null,
                    React.createElement(semiotic_1.FacetController, null, facetFrames),
                    React.createElement(ActualLegend, { valueHash: {}, colorHash: colorHashOverride, setColor: this.setColor, colors: colors }));
            }
            else {
                const controlProps = {
                    data: stateData,
                    view,
                    chart,
                    metrics,
                    dimensions,
                    selectedDimensions,
                    selectedMetrics,
                    hierarchyType,
                    summaryType,
                    networkType,
                    trendLine,
                    marginalGraphics,
                    barGrouping,
                    lineType,
                    areaType,
                    setAreaType: this.setAreaType,
                    updateChart: this.updateChart,
                    updateDimensions: this.updateDimensions,
                    setLineType: this.setLineType,
                    updateMetrics: this.updateMetrics,
                    generateFacets: this.generateFacets,
                    filterData: this.filterData,
                    setColor: this.setColor
                };
                const ActualVizControls = OverrideVizControls ? OverrideVizControls : VizControls_1.default;
                finalRenderedViz = React.createElement(React.Fragment, null,
                    instantiatedView,
                    editable && React.createElement(ActualVizControls, Object.assign({}, controlProps)));
            }
            const display = (React.createElement(SemioticWrapper, null, finalRenderedViz));
            // If you pass an onMetadataChange function, then fire it and pass the updated dx settings so someone upstream can update the metadata or otherwise use it
            this.updateMetadata({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                trendLine,
                marginalGraphics,
                barGrouping,
                colors,
                chart
            });
            this.setState((prevState) => {
                return Object.assign(Object.assign({}, updatedState), { displayChart: Object.assign(Object.assign({}, prevState.displayChart), { [chartKey]: display }) });
            });
        };
        this.setView = (view) => {
            this.updateChart({ view });
        };
        this.updateMetadata = (overrideProps) => {
            const { onMetadataChange, metadata } = this.props;
            const { view, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, colors, chart, facets } = this.state;
            if (onMetadataChange) {
                onMetadataChange(Object.assign(Object.assign({}, metadata), { dx: Object.assign({ view,
                        lineType,
                        areaType,
                        selectedDimensions,
                        selectedMetrics,
                        pieceType,
                        summaryType,
                        networkType,
                        hierarchyType,
                        trendLine,
                        marginalGraphics,
                        barGrouping,
                        colors,
                        chart,
                        facets }, overrideProps) }), mediaType);
            }
        };
        this.setGrid = () => {
            this.updateChart({ view: "grid" });
        };
        this.setColor = (newColorArray) => {
            this.updateChart({ colors: newColorArray });
        };
        this.setLineType = (selectedLineType) => {
            this.updateChart({ lineType: selectedLineType });
        };
        this.setAreaType = (selectedAreaType) => {
            this.updateChart({ areaType: selectedAreaType });
        };
        this.updateDimensions = (selectedDimension) => {
            const oldDims = this.state.selectedDimensions;
            const newDimensions = oldDims.indexOf(selectedDimension) === -1
                ? [...oldDims, selectedDimension]
                : oldDims.filter(dimension => dimension !== selectedDimension);
            this.updateChart({ selectedDimensions: newDimensions });
        };
        this.updateMetrics = (selectedMetric) => {
            const oldMetrics = this.state.selectedMetrics;
            const newMetrics = oldMetrics.indexOf(selectedMetric) === -1
                ? [...oldMetrics, selectedMetric]
                : oldMetrics.filter(metric => metric !== selectedMetric);
            this.updateChart({ selectedMetrics: newMetrics });
        };
        this.generateFacets = (name) => (onWhat, which) => {
            if (onWhat === "metric") {
                const generatedFacets = this.state.metrics.map(metric => {
                    return {
                        metadata: {
                            dx: {
                                [name]: metric.name
                            }
                        }
                    };
                });
                this.updateChart({ facets: generatedFacets });
            }
        };
        this.state = processInitialData(props);
    }
    componentDidMount() {
        this.updateChart(this.state);
    }
    render() {
        const { view, dimensions, metrics, chart, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, largeDataset, facets } = this.state;
        const { additionalViews } = this.props;
        let display = null;
        if (settings_1.semioticSettings[view] || view === "grid" || (additionalViews && additionalViews[view])) {
            const chartKey = generateChartKey({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                chart,
                trendLine,
                marginalGraphics,
                barGrouping
            });
            display = this.state.displayChart[chartKey];
        }
        const toolbarProps = {
            dimensions,
            metrics,
            currentView: view,
            setGrid: this.setGrid,
            setView: this.setView,
            largeDataset
        };
        let children = React.Children.map(this.props.children, child => {
            if (!React.isValidElement(child)) {
                return;
            }
            const { componentType } = child.props;
            if (componentType === "viz") {
                const newProps = { children: display };
                return React.cloneElement(child, newProps);
            }
            else if (componentType === "toolbar") {
                return React.cloneElement(child, toolbarProps);
            }
            return child;
        });
        return (React.createElement("div", null,
            React.createElement(MetadataWarning, { metadata: this.props.metadata }),
            React.createElement(FlexWrapper, null, children ? children :
                React.createElement(React.Fragment, null,
                    React.createElement(Viz_1.Viz, null, display),
                    (!facets || facets.length === 0) && React.createElement(Toolbar_1.Toolbar, Object.assign({}, toolbarProps))))));
    }
}
exports.default = DataExplorer;
exports.DataExplorer = DataExplorer;
DataExplorer.MIMETYPE = mediaType;
DataExplorer.defaultProps = {
    metadata: {
        dx: {}
    },
    height: 500,
    mediaType,
    initialView: "grid",
    overrideSettings: {},
    additionalViews: {}
};


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
const react_table_1 = __importDefault(__webpack_require__(149));
const react_table_hoc_fixed_columns_1 = __importDefault(__webpack_require__(247));
const css_1 = __importDefault(__webpack_require__(250));
const ReactTableFixedColumns = react_table_hoc_fixed_columns_1.default(react_table_1.default);
const switchMode = (currentMode) => {
    const nextMode = {
        "=": ">",
        ">": "<",
        "<": "="
    };
    return nextMode[currentMode];
};
const NumberFilter = (props) => {
    const { filterState, filterName, updateFunction, onChange } = props;
    const mode = filterState[filterName] || "=";
    return (React.createElement("form", { style: {
            border: "1px solid gray",
            background: "white",
            borderRadius: "5px",
            width: "100%"
        } },
        React.createElement("input", { type: "text", id: "name", name: "user_name", style: { width: "calc(100% - 30px)", border: "none" }, onChange: (event) => {
                onChange(event.currentTarget.value);
            }, placeholder: "number" }),
        React.createElement("button", { onClick: () => {
                updateFunction({ [filterName]: switchMode(mode) });
            } }, mode)));
};
const stringFilter = () => ({ onChange }) => (React.createElement("form", null,
    React.createElement("input", { type: "text", id: "string-filter", name: "string-filter", onChange: (event) => {
            onChange(event.currentTarget.value);
        }, placeholder: "string" })));
const numberFilterWrapper = (filterState, filterName, updateFunction) => ({ onChange }) => (React.createElement(NumberFilter, { onChange: onChange, filterState: filterState, filterName: filterName, updateFunction: updateFunction }));
const filterNumbers = (mode = "=") => (filter, row) => {
    const filterValue = Number(filter.value);
    if (mode === "=") {
        return row[filter.id] === filterValue;
    }
    else if (mode === "<") {
        return row[filter.id] < filterValue;
    }
    else if (mode === ">") {
        return row[filter.id] > filterValue;
    }
    return row[filter.id];
};
const filterStrings = () => (filter, row) => {
    return (row[filter.id].toLowerCase().indexOf(filter.value.toLowerCase()) !== -1);
};
const columnFilters = {
    integer: numberFilterWrapper,
    number: numberFilterWrapper,
    string: stringFilter
};
const filterMethod = {
    integer: filterNumbers,
    number: filterNumbers,
    string: filterStrings
};
class DataResourceTransformGrid extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            filters: {},
            showFilters: false
        };
    }
    render() {
        const { data: { data, schema }, height, theme } = this.props;
        const { filters, showFilters } = this.state;
        const { primaryKey = [] } = schema;
        const tableColumns = schema.fields.map((field) => {
            if (field.type === "string" ||
                field.type === "number" ||
                field.type === "integer") {
                return {
                    Header: field.name,
                    accessor: field.name,
                    fixed: primaryKey.indexOf(field.name) !== -1 && "left",
                    filterMethod: (filter, row) => {
                        if (field.type === "string" ||
                            field.type === "number" ||
                            field.type === "integer") {
                            return filterMethod[field.type](filters[field.name])(filter, row);
                        }
                    },
                    // If we don't have a filter defined for this field type, pass an empty div
                    Filter: columnFilters[field.type](filters, field.name, (newFilter) => {
                        this.setState({ filters: Object.assign(Object.assign({}, filters), newFilter) });
                    })
                };
            }
            else {
                return {
                    Header: field.name,
                    id: field.name,
                    accessor: (rowValue) => {
                        return field.type === "boolean" ? rowValue[field.name].toString() : rowValue[field.name];
                    },
                    fixed: primaryKey.indexOf(field.name) !== -1 && "left"
                };
            }
        });
        return (React.createElement(css_1.default, { theme: theme },
            React.createElement("button", { 
                //          icon="filter"
                onClick: () => this.setState({ showFilters: !showFilters }) },
                showFilters ? "Hide" : "Show",
                " Filters"),
            React.createElement(ReactTableFixedColumns, { data: data, columns: tableColumns, style: {
                    height: `${height}px`
                }, className: "-striped -highlight", filterable: showFilters })));
    }
}
DataResourceTransformGrid.defaultProps = {
    metadata: {},
    height: 500
};
exports.default = DataResourceTransformGrid;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(246);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "withFixedColumnsStickyPosition", {
  enumerable: true,
  get: function get() {
    return _stickyPosition.default;
  }
});
Object.defineProperty(exports, "withFixedColumnsScrollEvent", {
  enumerable: true,
  get: function get() {
    return _scrollEvent.default;
  }
});
exports.default = void 0;

var _helpers = __webpack_require__(115);

var _stickyPosition = _interopRequireDefault(__webpack_require__(248));

var _scrollEvent = _interopRequireDefault(__webpack_require__(249));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var withFixedColumns = (0, _helpers.enableStickyPosition)() ? _stickyPosition.default : _scrollEvent.default; // use for legacy browser

var _default = withFixedColumns;
exports.default = _default;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _reactTable = __webpack_require__(149);

var _uniqid = _interopRequireDefault(__webpack_require__(156));

var _classnames = _interopRequireDefault(__webpack_require__(5));

var _helpers = __webpack_require__(115);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _default = function _default(ReactTable) {
  var ReactTableFixedColumns =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(ReactTableFixedColumns, _React$Component);

    function ReactTableFixedColumns(props) {
      var _this;

      _classCallCheck(this, ReactTableFixedColumns);

      _this = _possibleConstructorReturn(this, (ReactTableFixedColumns.__proto__ || Object.getPrototypeOf(ReactTableFixedColumns)).call(this, props));

      _this.onResizedChange = function () {
        var onResizedChange = _this.props.onResizedChange;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (onResizedChange) {
          onResizedChange.apply(void 0, args);
        }

        args[0].forEach(function (_ref) {
          var id = _ref.id,
              value = _ref.value;
          _this.columnsWidth[id] = value;
        });

        _this.forceUpdate();
      };

      _this.getColumns = (0, _helpers.memoize)(function (columns) {
        var sortedColumns = (0, _helpers.sortColumns)(columns);

        var columnsWithFixed = _this.getColumnsWithFixed(sortedColumns);

        return columnsWithFixed;
      });
      (0, _helpers.checkErrors)(_this.props.columns);
      _this.columnsWidth = {};
      _this.uniqClassName = _this.props.uniqClassName || (0, _uniqid.default)('rthfc-');
      return _this;
    }

    _createClass(ReactTableFixedColumns, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateRowsPosition();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateRowsPosition();
      }
    }, {
      key: "updateRowsPosition",
      value: function updateRowsPosition() {
        var headerRows = document.querySelectorAll(".".concat(this.uniqClassName, " .rt-thead"));
        var topPosition = 0;
        /* eslint-disable no-param-reassign */

        Array.from(headerRows).forEach(function (row) {
          row.style.top = "".concat(topPosition, "px");
          topPosition += row.offsetHeight;
        });
        /* eslint-enable no-param-reassign */
      }
    }, {
      key: "getLeftOffsetColumns",
      value: function getLeftOffsetColumns(columns, index) {
        var offset = 0;

        for (var i = 0; i < index; i += 1) {
          var column = columns[i];

          if (column.show !== false) {
            var id = (0, _helpers.getColumnId)(column);
            var width = this.columnsWidth[id] || column.width || column.minWidth || 100;
            offset += width;
          }
        }

        return offset;
      }
    }, {
      key: "getRightOffsetColumns",
      value: function getRightOffsetColumns(columns, index) {
        var offset = 0;

        for (var i = index + 1; i < columns.length; i += 1) {
          var column = columns[i];

          if (column.show !== false) {
            var id = (0, _helpers.getColumnId)(column);
            var width = this.columnsWidth[id] || column.width || column.minWidth || 100;
            offset += width;
          }
        }

        return offset;
      }
    }, {
      key: "getColumnsWithFixed",
      value: function getColumnsWithFixed(columns, parentIsfixed, parentIsLastFixed, parentIsFirstFixed) {
        var _this2 = this;

        var defaultColumn = this.props.column;
        return columns.map(function (column, index) {
          var fixed = column.fixed || parentIsfixed || false;
          var nextColumn = (0, _helpers.findNextColumnNotHidden)(columns, index);

          var _parentIsLastFixed = fixed && parentIsfixed === undefined && nextColumn && !nextColumn.fixed;

          var isLastFixed = fixed && (parentIsfixed ? [true, 'left'].includes(parentIsfixed) && parentIsLastFixed : true) && (parentIsfixed && !nextColumn || !parentIsfixed && nextColumn && !nextColumn.fixed);
          var prevColumn = (0, _helpers.findPrevColumnNotHidden)(columns, index);

          var _parentIsFirstFixed = fixed && parentIsfixed === undefined && prevColumn && !prevColumn.fixed;

          var isFirstFixed = fixed && (parentIsfixed ? parentIsfixed === 'right' && parentIsFirstFixed : true) && (parentIsfixed && !prevColumn || !parentIsfixed && prevColumn && !prevColumn.fixed);
          var columnIsLeftFixed = (0, _helpers.isLeftFixed)({
            fixed: fixed
          });
          var columnIsRightFixed = (0, _helpers.isRightFixed)({
            fixed: fixed
          });

          var left = columnIsLeftFixed && _this2.getLeftOffsetColumns(columns, index);

          var right = columnIsRightFixed && _this2.getRightOffsetColumns(columns, index);

          var output = _objectSpread({}, column, {
            fixed: fixed,
            className: (0, _classnames.default)(defaultColumn.className, column.className, fixed && 'rthfc-td-fixed', columnIsLeftFixed && 'rthfc-td-fixed-left', columnIsRightFixed && 'rthfc-td-fixed-right', isLastFixed && 'rthfc-td-fixed-left-last', isFirstFixed && 'rthfc-td-fixed-right-first'),
            style: _objectSpread({}, defaultColumn.style, column.style, {
              left: left,
              right: right
            }),
            headerClassName: (0, _classnames.default)(defaultColumn.headerClassName, column.headerClassName, fixed && 'rthfc-th-fixed', columnIsLeftFixed && 'rthfc-th-fixed-left', columnIsRightFixed && 'rthfc-th-fixed-right', (_parentIsLastFixed || parentIsLastFixed && isLastFixed) && 'rthfc-th-fixed-left-last', (_parentIsFirstFixed || parentIsFirstFixed && isFirstFixed) && 'rthfc-th-fixed-right-first'),
            headerStyle: _objectSpread({}, defaultColumn.headerStyle, column.headerStyle, {
              left: left,
              right: right
            })
          });

          if (column.columns) {
            output.columns = _this2.getColumnsWithFixed(column.columns, fixed, _parentIsLastFixed, _parentIsFirstFixed);
          }

          return output;
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            className = _props.className,
            innerRef = _props.innerRef,
            columns = _props.columns,
            props = _objectWithoutProperties(_props, ["className", "innerRef", "columns"]);

        return _react.default.createElement(ReactTable, _extends({}, props, {
          ref: innerRef,
          className: (0, _classnames.default)(className, this.uniqClassName, 'rthfc', '-sp'),
          columns: this.getColumns(columns),
          onResizedChange: this.onResizedChange
        }));
      }
    }]);

    return ReactTableFixedColumns;
  }(_react.default.Component);

  ReactTableFixedColumns.propTypes = {
    columns: _propTypes.default.array.isRequired,
    innerRef: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),
    className: _propTypes.default.string,
    onResizedChange: _propTypes.default.func,
    uniqClassName: _propTypes.default.string,
    column: _propTypes.default.object
  };
  ReactTableFixedColumns.defaultProps = {
    innerRef: null,
    className: null,
    onResizedChange: null,
    uniqClassName: null,
    column: _reactTable.ReactTableDefaults.column
  };
  return ReactTableFixedColumns;
};

exports.default = _default;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _reactTable = __webpack_require__(149);

var _uniqid = _interopRequireDefault(__webpack_require__(156));

var _classnames = _interopRequireDefault(__webpack_require__(5));

var _helpers = __webpack_require__(115);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _default = function _default(ReactTable) {
  var ReactTableFixedColumns =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(ReactTableFixedColumns, _React$Component);

    function ReactTableFixedColumns(props) {
      var _this;

      _classCallCheck(this, ReactTableFixedColumns);

      _this = _possibleConstructorReturn(this, (ReactTableFixedColumns.__proto__ || Object.getPrototypeOf(ReactTableFixedColumns)).call(this, props));

      _this.onScrollX = function (event) {
        if (event.nativeEvent.target.getAttribute('class').indexOf('rt-table') === -1) return;

        _this.calculatePos(event.nativeEvent.target);
      };

      _this.onChangeProperty = function (propertyName) {
        return function () {
          var propertyProps = _this.props[propertyName];

          if (propertyProps) {
            propertyProps.apply(void 0, arguments);
          }

          _this.calculatePos();
        };
      };

      _this.getColumnsWithFixed = function (columns, parentIsfixed, parentIsLastFixed, parentIsFirstFixed) {
        return columns.map(function (column, index) {
          var defaultColumn = _this.props.column;
          var fixed = column.fixed || parentIsfixed || false;
          var nextColumn = (0, _helpers.findNextColumnNotHidden)(columns, index);

          var _parentIsLastFixed = fixed && parentIsfixed === undefined && nextColumn && !nextColumn.fixed;

          var isLastFixed = fixed && (parentIsfixed ? [true, 'left'].includes(parentIsfixed) && parentIsLastFixed : true) && (parentIsfixed && !nextColumn || !parentIsfixed && nextColumn && !nextColumn.fixed);
          var prevColumn = (0, _helpers.findPrevColumnNotHidden)(columns, index);

          var _parentIsFirstFixed = fixed && parentIsfixed === undefined && prevColumn && !prevColumn.fixed;

          var isFirstFixed = fixed && (parentIsfixed ? parentIsfixed === 'right' && parentIsFirstFixed : true) && (parentIsfixed && !prevColumn || !parentIsfixed && prevColumn && !prevColumn.fixed);

          var output = _objectSpread({}, column, {
            fixed: fixed,
            className: (0, _classnames.default)(defaultColumn.className, column.className, fixed && 'rthfc-td-fixed', (0, _helpers.isLeftFixed)({
              fixed: fixed
            }) && 'rthfc-td-fixed-left', (0, _helpers.isRightFixed)({
              fixed: fixed
            }) && 'rthfc-td-fixed-right', isLastFixed && 'rthfc-td-fixed-left-last', isFirstFixed && 'rthfc-td-fixed-right-first'),
            headerClassName: (0, _classnames.default)(defaultColumn.headerClassName, column.headerClassName, fixed && 'rthfc-th-fixed', (0, _helpers.isLeftFixed)({
              fixed: fixed
            }) && 'rthfc-th-fixed-left', (0, _helpers.isRightFixed)({
              fixed: fixed
            }) && 'rthfc-th-fixed-right', (_parentIsLastFixed || parentIsLastFixed && isLastFixed) && 'rthfc-th-fixed-left-last', (_parentIsFirstFixed || parentIsFirstFixed && isFirstFixed) && 'rthfc-th-fixed-right-first')
          });

          if (column.columns) {
            output.columns = _this.getColumnsWithFixed(column.columns, fixed, _parentIsLastFixed, _parentIsFirstFixed);
          }

          return output;
        });
      };

      _this.getColumns = (0, _helpers.memoize)(function (columns) {
        var sortedColumns = (0, _helpers.sortColumns)(columns);

        var columnsWithFixed = _this.getColumnsWithFixed(sortedColumns);

        return columnsWithFixed;
      });

      _this.getProps = function () {
        var getProps = _this.props.getProps;
        return _objectSpread({}, getProps && getProps.apply(void 0, arguments), {
          onScroll: _this.onScrollX
        });
      };

      (0, _helpers.checkErrors)(_this.props.columns);
      _this.uniqClassName = _this.props.uniqClassName || (0, _uniqid.default)('rthfc-');
      _this.onChangePropertyList = {
        onResizedChange: _this.onChangeProperty('onResizedChange'),
        onFilteredChange: _this.onChangeProperty('onFilteredChange'),
        onPageChange: _this.onChangeProperty('onPageChange'),
        onPageSizeChange: _this.onChangeProperty('onPageSizeChange'),
        onExpandedChange: _this.onChangeProperty('onExpandedChange')
      };
      return _this;
    }

    _createClass(ReactTableFixedColumns, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.tableRef = document.querySelector(".".concat(this.uniqClassName, " .rt-table"));
        this.calculatePos();
        this.leftFixedCells = this.tableRef.querySelectorAll(".".concat(this.uniqClassName, " .rthfc-fixed-left"));
        this.rightFixedCells = this.tableRef.querySelectorAll(".".concat(this.uniqClassName, " .rthfc-fixed-left"));
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updatePos();
      }
    }, {
      key: "calculatePos",
      value: function calculatePos() {
        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tableRef;
        var scrollLeft = target.scrollLeft,
            scrollWidth = target.scrollWidth,
            offsetWidth = target.offsetWidth;
        this.nextTranslateLeftX = scrollLeft;
        this.nextTranslateRightX = scrollWidth - scrollLeft - offsetWidth;
        this.updatePos(target);
      }
    }, {
      key: "updatePos",
      value: function updatePos() {
        var _this2 = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tableRef;

        /* eslint-disable no-param-reassign */
        Array.from(target.querySelectorAll('.rthfc-th-fixed-left, .rthfc-td-fixed-left')).forEach(function (td) {
          td.style.transform = "translate3d(".concat(_this2.nextTranslateLeftX, "px, 0, 0)");
        });
        Array.from(target.querySelectorAll('.rthfc-th-fixed-right, .rthfc-td-fixed-right')).forEach(function (td) {
          td.style.transform = "translate3d(".concat(-_this2.nextTranslateRightX, "px, 0, 0)");
        });
        /* eslint-enable no-param-reassign */
      }
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            className = _props.className,
            innerRef = _props.innerRef,
            columns = _props.columns,
            props = _objectWithoutProperties(_props, ["className", "innerRef", "columns"]);

        return _react.default.createElement(ReactTable, _extends({}, props, {
          ref: innerRef,
          className: (0, _classnames.default)(className, 'rthfc', '-se', this.uniqClassName),
          columns: this.getColumns(columns),
          getProps: this.getProps
        }, this.onChangePropertyList));
      }
    }]);

    return ReactTableFixedColumns;
  }(_react.default.Component);

  ReactTableFixedColumns.propTypes = {
    columns: _propTypes.default.array.isRequired,
    getProps: _propTypes.default.func,
    innerRef: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),
    className: _propTypes.default.string,
    uniqClassName: _propTypes.default.string,
    column: _propTypes.default.object
  };
  ReactTableFixedColumns.defaultProps = {
    getProps: null,
    innerRef: null,
    className: null,
    uniqClassName: null,
    column: _reactTable.ReactTableDefaults.column
  };
  return ReactTableFixedColumns;
};

exports.default = _default;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const styled_components_1 = __importDefault(__webpack_require__(19));
const react_table_1 = __importDefault(__webpack_require__(251));
const react_table_hoc_fixed_columns_1 = __importDefault(__webpack_require__(252));
exports.default = styled_components_1.default.div `
  /* React table style customization */
  width: 100%;
  font-family: System-UI, -apple-system, BlinkMacSystemFont, "Source Sans Pro", sans-serif;
  font-size: 0.875rem;


  .ReactTable .rt-thead.-header .rt-th {
    color: ${props => (props.theme === "dark" ? "#bbb" : "#111")};
    background-color: ${props => (props.theme === "dark" ? "#1e1e1e" : "#f2f2f2")};
    padding: 2.5rem 0.75rem 0.5rem;
  }
  .ReactTable.-striped .rt-tr.-odd > div {
    color: ${props => (props.theme === "dark" ? "#bbb" : "#111")};
    background-color: ${props => (props.theme === "dark" ? "#111" : "#fff")};
  }

  .ReactTable.-striped .rt-tr.-even > div {
    color: ${props => (props.theme === "dark" ? "#bbb" : "#111")};
    background-color: ${props => (props.theme === "dark" ? "#111" : "#fff")};
  }

  .ReactTable.-highlight .rt-tbody .rt-tr:not(.-padRow):hover {
    /* 
    What does this selector do? 
    These classes were in our react-table style sheet previously
    color: var(--theme-app-fg);
    background: var(--cm-background); 
    */
  }

  .ReactTable .-pagination .-btn {
  }

  /* 
  These parts are mostly copied from the dependency packages, 
  but we remove some things that clash with us
  */
  ${react_table_1.default}
  ${react_table_hoc_fixed_columns_1.default}
`;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// just a string copy/paste for now
/*  'react-table@6.8.6' vendorized css */
/* 'react-table/react-table.css' */
// this will be merged with other styles and combined into one styled-component
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = `
  
  .ReactTable {
    position: relative;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    border: 1px solid #BDBDBD;
    border-radius: 8px;
    overflow: hidden;
  }
  .ReactTable * {
    box-sizing: border-box;
  }
  .ReactTable .rt-table {
    -webkit-box-flex: 1;
    -ms-flex: auto 1;
    flex: auto 1;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    -webkit-box-align: stretch;
    -ms-flex-align: stretch;
    align-items: stretch;
    width: 100%;
    border-collapse: collapse;
    overflow: auto;
  }
  .ReactTable .rt-thead {
    -webkit-box-flex: 1;
    -ms-flex: 1 0 auto;
    flex: 1 0 auto;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  .ReactTable .rt-thead.-headerGroups {
    background: rgba(0, 0, 0, 0.03);
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
  }
  .ReactTable .rt-thead.-filters {
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
  }
  .ReactTable .rt-thead.-filters input,
  .ReactTable .rt-thead.-filters select {
    border: 1px solid rgba(0, 0, 0, 0.1);
    background: #fff;
    padding: 5px 7px;
    font-size: inherit;
    border-radius: 3px;
    font-weight: normal;
    outline: none;
  }
  .ReactTable .rt-thead.-filters .rt-th {
    border-right: 1px solid rgba(0, 0, 0, 0.02);
  }

  .ReactTable .rt-thead .rt-tr {
    text-align: center;
    background: #ffffff;
  }
  .ReactTable .rt-thead .rt-th,
  .ReactTable .rt-thead .rt-td {
    line-height: normal;
    position: relative;
    border-right: 1px solid rgba(0, 0, 0, 0.05);
    transition: box-shadow 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-shadow: inset 0 0 0 0 transparent;
  }
  .ReactTable .rt-thead .rt-th.-sort-asc,
  .ReactTable .rt-thead .rt-td.-sort-asc {
    box-shadow: inset 0 3px 0 0 rgba(0, 0, 0, 0.6);
  }
  .ReactTable .rt-thead .rt-th.-sort-desc,
  .ReactTable .rt-thead .rt-td.-sort-desc {
    box-shadow: inset 0 -3px 0 0 rgba(0, 0, 0, 0.6);
  }
  .ReactTable .rt-thead .rt-th.-cursor-pointer,
  .ReactTable .rt-thead .rt-td.-cursor-pointer {
    cursor: pointer;
  }
  .ReactTable .rt-thead .rt-th:last-child,
  .ReactTable .rt-thead .rt-td:last-child {
    border-right: 0;
  }
  .ReactTable .rt-thead .rt-resizable-header {
    overflow: visible;
  }
  .ReactTable .rt-thead .rt-resizable-header:last-child {
    overflow: hidden;
  }
  .ReactTable .rt-thead .rt-resizable-header-content {
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
  }
  .ReactTable .rt-thead .rt-header-pivot {
    border-right-color: #f7f7f7;
  }
  .ReactTable .rt-thead .rt-header-pivot:after,
  .ReactTable .rt-thead .rt-header-pivot:before {
    left: 100%;
    top: 50%;
    border: solid transparent;
    content: " ";
    height: 0;
    width: 0;
    position: absolute;
    pointer-events: none;
  }
  .ReactTable .rt-thead .rt-header-pivot:after {
    border-color: rgba(255, 255, 255, 0);
    border-left-color: #fff;
    border-width: 8px;
    margin-top: -8px;
  }
  .ReactTable .rt-thead .rt-header-pivot:before {
    border-color: rgba(102, 102, 102, 0);
    border-left-color: #f7f7f7;
    border-width: 10px;
    margin-top: -10px;
  }
  .ReactTable .rt-tbody {
    -webkit-box-flex: 99999;
    -ms-flex: 99999 1 auto;
    flex: 99999 1 auto;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    overflow: auto;
  }
  .ReactTable .rt-tbody .rt-tr-group:last-child {
    border-bottom: 0;
  }
  .ReactTable .rt-tbody .rt-td {
    border-right: 1px solid rgba(0, 0, 0, 0.02);
  }
  .ReactTable .rt-tbody .rt-td:last-child {
    border-right: 0;
  }
  .ReactTable .rt-tbody .rt-expandable {
    cursor: pointer;
    text-overflow: clip;
  }
  .ReactTable .rt-tr-group {
    -webkit-box-flex: 1;
    -ms-flex: 1 0 auto;
    flex: 1 0 auto;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    -webkit-box-align: stretch;
    -ms-flex-align: stretch;
    align-items: stretch;
  }
  .ReactTable .rt-tr {
    -webkit-box-flex: 1;
    -ms-flex: 1 0 auto;
    flex: 1 0 auto;
    display: -webkit-inline-box;
    display: -ms-inline-flexbox;
    display: inline-flex;
  }
  .ReactTable .rt-th,
  .ReactTable .rt-td {
    -webkit-box-flex: 1;
    -ms-flex: 1 0 0px;
    flex: 1 0 0;
    white-space: nowrap;
    text-overflow: ellipsis;
    padding: 0.5625rem 0.75rem;
    overflow: hidden;
    transition: 0.3s ease;
    transition-property: width, min-width, padding, opacity;
  }
  .ReactTable .rt-th.-hidden,
  .ReactTable .rt-td.-hidden {
    width: 0 !important;
    min-width: 0 !important;
    padding: 0 !important;
    border: 0 !important;
    opacity: 0 !important;
  }
  .ReactTable .rt-expander {
    display: inline-block;
    position: relative;
    margin: 0;
    color: transparent;
    margin: 0 10px;
  }
  .ReactTable .rt-expander:after {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    top: 50%;
    left: 50%;
    -webkit-transform: translate(-50%, -50%) rotate(-90deg);
    transform: translate(-50%, -50%) rotate(-90deg);
    border-left: 5.04px solid transparent;
    border-right: 5.04px solid transparent;
    border-top: 7px solid rgba(0, 0, 0, 0.8);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: pointer;
  }
  .ReactTable .rt-expander.-open:after {
    -webkit-transform: translate(-50%, -50%) rotate(0);
    transform: translate(-50%, -50%) rotate(0);
  }
  .ReactTable .rt-resizer {
    display: inline-block;
    position: absolute;
    width: 36px;
    top: 0;
    bottom: 0;
    right: -18px;
    cursor: col-resize;
    z-index: 10;
  }
  .ReactTable .rt-tfoot {
    -webkit-box-flex: 1;
    -ms-flex: 1 0 auto;
    flex: 1 0 auto;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
    -ms-flex-direction: column;
    flex-direction: column;
    box-shadow: 0 0 15px 0 rgba(0, 0, 0, 0.15);
  }
  .ReactTable .rt-tfoot .rt-td {
    border-right: 1px solid rgba(0, 0, 0, 0.05);
  }
  .ReactTable .rt-tfoot .rt-td:last-child {
    border-right: 0;
  }
  .ReactTable.-highlight .rt-tbody .rt-tr:not(.-padRow):hover {
    background: rgba(0, 0, 0, 0.05);
  }
  .ReactTable .-pagination {
    z-index: 1;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
    justify-content: space-between;
    -webkit-box-align: stretch;
    -ms-flex-align: stretch;
    align-items: stretch;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    padding: 3px;
    border-top: 2px solid rgba(0, 0, 0, 0.1);
  }
  .ReactTable .-pagination input,
  .ReactTable .-pagination select {
    border: 1px solid rgba(0, 0, 0, 0.1);
    background: #fff;
    padding: 5px 7px;
    font-size: inherit;
    border-radius: 3px;
    font-weight: normal;
    outline: none;
  }
  .ReactTable .-pagination .-btn {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    display: block;
    width: 100%;
    height: 100%;
    border: 0;
    border-radius: 3px;
    padding: 6px;
    font-size: 1em;
    transition: all 0.1s ease;
    cursor: pointer;
    outline: none;
  }
  .ReactTable .-pagination .-btn[disabled] {
    opacity: 0.5;
    cursor: default;
  }
  .ReactTable .-pagination .-btn:not([disabled]):hover {
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
  }
  .ReactTable .-pagination .-previous,
  .ReactTable .-pagination .-next {
    -webkit-box-flex: 1;
    -ms-flex: 1;
    flex: 1;
    text-align: center;
  }
  .ReactTable .-pagination .-center {
    -webkit-box-flex: 1.5;
    -ms-flex: 1.5;
    flex: 1.5;
    text-align: center;
    margin-bottom: 0;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: horizontal;
    -webkit-box-direction: normal;
    -ms-flex-direction: row;
    flex-direction: row;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -ms-flex-pack: distribute;
    justify-content: space-around;
  }
  .ReactTable .-pagination .-pageInfo {
    display: inline-block;
    margin: 3px 10px;
    white-space: nowrap;
  }
  .ReactTable .-pagination .-pageJump {
    display: inline-block;
  }
  .ReactTable .-pagination .-pageJump input {
    width: 70px;
    text-align: center;
  }
  .ReactTable .-pagination .-pageSizeOptions {
    margin: 3px 10px;
  }
  .ReactTable .rt-noData {
    display: block;
    position: absolute;
    left: 50%;
    top: 50%;
    -webkit-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.8);
    transition: all 0.3s ease;
    z-index: 1;
    pointer-events: none;
    padding: 20px;
    color: rgba(0, 0, 0, 0.5);
  }
  .ReactTable .-loading {
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    transition: all 0.3s ease;
    z-index: -1;
    opacity: 0;
    pointer-events: none;
  }
  .ReactTable .-loading > div {
    position: absolute;
    display: block;
    text-align: center;
    width: 100%;
    top: 50%;
    left: 0;
    font-size: 15px;
    color: rgba(0, 0, 0, 0.6);
    -webkit-transform: translateY(-52%);
    transform: translateY(-52%);
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .ReactTable .-loading.-active {
    opacity: 1;
    z-index: 2;
    pointer-events: all;
  }
  .ReactTable .-loading.-active > div {
    -webkit-transform: translateY(50%);
    transform: translateY(50%);
  }
  .ReactTable .rt-resizing .rt-th,
  .ReactTable .rt-resizing .rt-td {
    transition: none !important;
    cursor: col-resize;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
`;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// just a string copy/paste for now:
/*
'react-table-hoc-fixed-columns@6.8.6' vendorized css
'react-table-hoc-fixed-columns/lib/styles.css'
*/
// to be merged with react-table styles and combined into one styled-component
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = `

  .rthfc .rt-thead.-headerGroups,
  .rthfc .rt-thead.-header {
    z-index: 3;
    
  }

  .rthfc .rt-thead.-filters {
    z-index: 2;
  }

  .rthfc .rt-th,
  .rthfc .rt-td {
    
  }

  .rthfc .-headerGroups .rt-th {
    
  }

  .rthfc.-striped .rt-tr.-odd .rt-td {
    
  }

  .rthfc.-highlight .rt-tr:hover .rt-td {
    
  }

  .rthfc .-filters .rt-th.rthfc-th-fixed-left-last,
  .rthfc .rt-th.rthfc-th-fixed-left-last,
  .rthfc .rt-td.rthfc-td-fixed-left-last {
    border-right: solid #BDBDBD 1px;
    background: #fff;
  }

  .rthfc .rt-th.rthfc-th-fixed-right-first,
  .rthfc .rt-td.rthfc-td-fixed-right-first {
    border-left: solid 1px;
  }

  /*------------ Sticky position version: -sp ------------*/

  .rthfc.-sp .rt-tbody {
    overflow: visible;
    flex: 1 0 auto;
  }

  .rthfc.-sp .rt-thead {
    position: -webkit-sticky;
    position: sticky;
  }

  .rthfc.-sp .rt-thead.-headerGroups {
    
  }

  .rthfc.-sp .rt-tfoot {
    position: -webkit-sticky;
    position: sticky;
    z-index: 1;
    bottom: 0px;
  }

  .rthfc.-sp .rthfc-th-fixed,
  .rthfc.-sp .rthfc-td-fixed {
    position: -webkit-sticky;
    position: sticky;
    z-index: 1;
  }

  .rthfc.-sp .rthfc-th-fixed-left,
  .rthfc.-sp .rthfc-td-fixed-left {
    left: 0;
  }

  .rthfc.-sp .rthfc-th-fixed-right,
  .rthfc.-sp .rthfc-td-fixed-right {
    left: 0;
  }

  /*------------ scroll event version: -se ------------*/

  .rthfc.-se .-header .rt-th.rthfc-th-fixed,
  .rthfc.-se .-headerGroups .rt-th.rthfc-th-fixed,
  .rthfc.-se .-filters .rt-th.rthfc-th-fixed,
  .rthfc.-se .rt-td.rthfc-td-fixed {
    position: relative;
    z-index: 1;
  }
`;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticSettings = void 0;
const semiotic_1 = __webpack_require__(81);
const ParallelCoordinatesController_1 = __importDefault(__webpack_require__(332));
const bar_1 = __webpack_require__(500);
const hierarchical_1 = __webpack_require__(501);
const line_1 = __webpack_require__(502);
const network_1 = __webpack_require__(503);
const summary_1 = __webpack_require__(504);
const xyplot_1 = __webpack_require__(505);
const semioticParallelCoordinates = (data, schema, options) => {
    return {
        frameSettings: {
            data,
            schema,
            options
        }
    };
};
exports.semioticSettings = {
    line: {
        Frame: semiotic_1.ResponsiveXYFrame,
        controls: "switch between linetype",
        chartGenerator: line_1.semioticLineChart,
        FacetFrame: semiotic_1.XYFrame
    },
    scatter: {
        Frame: semiotic_1.ResponsiveXYFrame,
        controls: "switch between modes",
        chartGenerator: xyplot_1.semioticScatterplot,
        FacetFrame: semiotic_1.XYFrame
    },
    hexbin: {
        Frame: semiotic_1.ResponsiveXYFrame,
        controls: "switch between modes",
        chartGenerator: xyplot_1.semioticHexbin,
        FacetFrame: semiotic_1.XYFrame
    },
    bar: {
        Frame: semiotic_1.ResponsiveOrdinalFrame,
        controls: "switch between modes",
        chartGenerator: bar_1.semioticBarChart,
        FacetFrame: semiotic_1.OrdinalFrame
    },
    summary: {
        Frame: semiotic_1.ResponsiveOrdinalFrame,
        controls: "switch between modes",
        chartGenerator: summary_1.semioticSummaryChart,
        FacetFrame: semiotic_1.OrdinalFrame
    },
    network: {
        Frame: semiotic_1.ResponsiveNetworkFrame,
        controls: "switch between modes",
        chartGenerator: network_1.semioticNetwork,
        FacetFrame: semiotic_1.NetworkFrame
    },
    hierarchy: {
        Frame: semiotic_1.ResponsiveNetworkFrame,
        controls: "switch between modes",
        chartGenerator: hierarchical_1.semioticHierarchicalChart,
        FacetFrame: semiotic_1.NetworkFrame
    },
    parallel: {
        Frame: ParallelCoordinatesController_1.default,
        controls: "switch between modes",
        chartGenerator: semioticParallelCoordinates,
        FacetFrame: ParallelCoordinatesController_1.default
    }
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var d3labeler_1 = __importDefault(__webpack_require__(255));
var basicLabelSizeFunction = function (noteData, characterWidth, lineHeight, padding) {
    var text = noteData.note.label || noteData.note.title;
    var textLength = text.length;
    var wrap = noteData.note.wrap || 120;
    var width = Math.min(wrap, textLength * characterWidth) + padding * 2;
    var height = Math.ceil((textLength * characterWidth) / 120) * lineHeight + padding * 2;
    return [width, height];
};
function bumpAnnotations(adjustableNotes, processor, size, propsPointSizeFunction, propsLabelSizeFunction) {
    var _a = processor.padding, padding = _a === void 0 ? 1 : _a, _b = processor.characterWidth, characterWidth = _b === void 0 ? 8 : _b, _c = processor.lineHeight, lineHeight = _c === void 0 ? 20 : _c, _d = processor.iterations, iterations = _d === void 0 ? 500 : _d, _e = processor.pointSizeFunction, pointSizeFunction = _e === void 0 ? propsPointSizeFunction : _e, _f = processor.labelSizeFunction, labelSizeFunction = _f === void 0 ? propsLabelSizeFunction || basicLabelSizeFunction : _f;
    var labels = adjustableNotes.map(function (d, i) {
        var anchorX = (d.props.noteData.x[0] || d.props.noteData.x) +
            (d.props.noteData.dx !== undefined
                ? d.props.noteData.dx
                : ((i % 3) - 1) * -10);
        var anchorY = (d.props.noteData.y[0] || d.props.noteData.y) +
            (d.props.noteData.dy !== undefined
                ? d.props.noteData.dy
                : ((i % 3) - 1) * 10);
        var _a = __read(labelSizeFunction(d.props.noteData, characterWidth, lineHeight, padding), 2), labelWidth = _a[0], labelHeight = _a[1];
        return {
            x: anchorX,
            y: anchorY,
            above: anchorY < d.props.noteData.y,
            left: anchorX < d.props.noteData.x,
            width: labelWidth,
            height: labelHeight,
            type: "label",
            name: "",
            originalNote: d
        };
    });
    var points = adjustableNotes.map(function (d) { return ({
        x: d.props.noteData.x,
        y: d.props.noteData.y,
        fx: d.props.noteData.x,
        fy: d.props.noteData.y,
        r: (pointSizeFunction && pointSizeFunction(d.props.noteData)) || 5,
        type: "point",
        originalNote: d
    }); });
    var instantiatedLabeler = d3labeler_1.default();
    instantiatedLabeler.label(labels);
    instantiatedLabeler.anchor(points);
    instantiatedLabeler.width(size[0]);
    instantiatedLabeler.height(size[1]);
    instantiatedLabeler.start(iterations);
    labels.forEach(function (d) {
        if (d.type === "label") {
            var adjusted = adjustedXY(d.originalNote.props.noteData, d, padding);
            d.originalNote.props.noteData.nx = adjusted[0];
            d.originalNote.props.noteData.ny = adjusted[1];
        }
    });
    return adjustableNotes;
}
exports.bumpAnnotations = bumpAnnotations;
function adjustedXY(note, calculated, padding) {
    if (note.y > calculated.y) {
        //below
        return [
            calculated.x + calculated.width / 2 + padding / 2,
            calculated.y - calculated.height + padding / 2
        ];
    }
    return [calculated.x + calculated.width / 2, calculated.y];
}


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// from Evan Wang's https://github.com/tinker10/D3-Labeler
function default_1() {
    var lab = [], anc = [], w = 1, // box width
    h = 1, // box width
    labeler = {
        start: function (x) { },
        width: function (x) { },
        height: function (x) { },
        label: function (x) { },
        anchor: function (x) { },
        alt_energy: function (x) { },
        alt_schedule: function (x) { }
    };
    var max_move = 5.0, max_angle = 0.5;
    // weights
    var w_len = 0.2, // leader line length
    w_inter = 1.0, // leader line intersection
    w_lab2 = 30.0, // label-label overlap
    w_lab_anc = 30.0, // label-anchor overlap
    w_orient = 3.0; // orientation bias
    // booleans for user defined functions
    var user_energy = false, user_schedule = false;
    var user_defined_energy, user_defined_schedule;
    var energy = function (index) {
        // energy function, tailored for label placement
        var m = lab.length, ener = 0, dx = lab[index].x - anc[index].x, dy = anc[index].y - lab[index].y, dist = Math.sqrt(dx * dx + dy * dy), overlap = true, amount = 0, theta = 0;
        // penalty for length of leader line
        if (dist > 0)
            ener += dist * w_len;
        // label orientation bias
        dx /= dist;
        dy /= dist;
        if (dx > 0 && dy > 0) {
            ener += 0 * w_orient;
        }
        else if (dx < 0 && dy > 0) {
            ener += 1 * w_orient;
        }
        else if (dx < 0 && dy < 0) {
            ener += 2 * w_orient;
        }
        else {
            ener += 3 * w_orient;
        }
        var x21 = lab[index].x, y21 = lab[index].y - lab[index].height + 2.0, x22 = lab[index].x + lab[index].width, y22 = lab[index].y + 2.0;
        var x11, x12, y11, y12, x_overlap, y_overlap, overlap_area;
        for (var i = 0; i < m; i++) {
            if (i !== index) {
                // penalty for intersection of leader lines
                var overlap_1 = intersect(anc[index].x, lab[index].x, anc[i].x, lab[i].x, anc[index].y, lab[index].y, anc[i].y, lab[i].y);
                if (overlap_1)
                    ener += w_inter;
                // penalty for label-label overlap
                x11 = lab[i].x;
                y11 = lab[i].y - lab[i].height + 2.0;
                x12 = lab[i].x + lab[i].width;
                y12 = lab[i].y + 2.0;
                x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
                y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
                overlap_area = x_overlap * y_overlap;
                ener += overlap_area * w_lab2;
            }
            // penalty for label-anchor overlap
            x11 = anc[i].x - anc[i].r;
            y11 = anc[i].y - anc[i].r;
            x12 = anc[i].x + anc[i].r;
            y12 = anc[i].y + anc[i].r;
            x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
            y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
            overlap_area = x_overlap * y_overlap;
            ener += overlap_area * w_lab_anc;
        }
        return ener;
    };
    var mcmove = function (currT) {
        // Monte Carlo translation move
        // select a random label
        var i = Math.floor(Math.random() * lab.length);
        // save old coordinates
        var x_old = lab[i].x;
        var y_old = lab[i].y;
        // old energy
        var old_energy;
        if (user_energy) {
            old_energy = user_defined_energy(i, lab, anc);
        }
        else {
            old_energy = energy(i);
        }
        // random translation
        lab[i].x += (Math.random() - 0.5) * max_move;
        lab[i].y += (Math.random() - 0.5) * max_move;
        // hard wall boundaries
        if (lab[i].x > w)
            lab[i].x = x_old;
        if (lab[i].x < 0)
            lab[i].x = x_old;
        if (lab[i].y > h)
            lab[i].y = y_old;
        if (lab[i].y < 0)
            lab[i].y = y_old;
        // new energy
        var new_energy;
        if (user_energy) {
            new_energy = user_defined_energy(i, lab, anc);
        }
        else {
            new_energy = energy(i);
        }
        // delta E
        var delta_energy = new_energy - old_energy;
        if (!(Math.random() < Math.exp(-delta_energy / currT))) {
            // move back to old coordinates
            lab[i].x = x_old;
            lab[i].y = y_old;
        }
    };
    var mcrotate = function (currT) {
        // Monte Carlo rotation move
        // select a random label
        var i = Math.floor(Math.random() * lab.length);
        // save old coordinates
        var x_old = lab[i].x;
        var y_old = lab[i].y;
        // old energy
        var old_energy;
        if (user_energy) {
            old_energy = user_defined_energy(i, lab, anc);
        }
        else {
            old_energy = energy(i);
        }
        // random angle
        var angle = (Math.random() - 0.5) * max_angle;
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        // translate label (relative to anchor at origin):
        lab[i].x -= anc[i].x;
        lab[i].y -= anc[i].y;
        // rotate label
        var x_new = lab[i].x * c - lab[i].y * s, y_new = lab[i].x * s + lab[i].y * c;
        // translate label back
        lab[i].x = x_new + anc[i].x;
        lab[i].y = y_new + anc[i].y;
        // hard wall boundaries
        if (lab[i].x > w)
            lab[i].x = x_old;
        if (lab[i].x < 0)
            lab[i].x = x_old;
        if (lab[i].y > h)
            lab[i].y = y_old;
        if (lab[i].y < 0)
            lab[i].y = y_old;
        // new energy
        var new_energy;
        if (user_energy) {
            new_energy = user_defined_energy(i, lab, anc);
        }
        else {
            new_energy = energy(i);
        }
        // delta E
        var delta_energy = new_energy - old_energy;
        if (!(Math.random() < Math.exp(-delta_energy / currT))) {
            // move back to old coordinates
            lab[i].x = x_old;
            lab[i].y = y_old;
        }
    };
    var intersect = function (x1, x2, x3, x4, y1, y2, y3, y4) {
        // returns true if two lines intersect, else false
        // from http://paulbourke.net/geometry/lineline2d/
        var mua, mub;
        var denom, numera, numerb;
        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        numera = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        numerb = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
        /* Is the intersection along the the segments */
        mua = numera / denom;
        mub = numerb / denom;
        if (!(mua < 0 || mua > 1 || mub < 0 || mub > 1)) {
            return true;
        }
        return false;
    };
    var cooling_schedule = function (currT, initialT, nsweeps) {
        // linear cooling
        return currT - initialT / nsweeps;
    };
    labeler.start = function (nsweeps) {
        // main simulated annealing function
        var m = lab.length, currT = 1.0, initialT = 1.0;
        for (var i = 0; i < nsweeps; i++) {
            for (var j = 0; j < m; j++) {
                if (Math.random() < 0.5) {
                    mcmove(currT);
                }
                else {
                    mcrotate(currT);
                }
            }
            currT = cooling_schedule(currT, initialT, nsweeps);
        }
    };
    labeler.width = function (x) {
        // users insert graph width
        if (!arguments.length)
            return w;
        w = x;
        return labeler;
    };
    labeler.height = function (x) {
        // users insert graph height
        if (!arguments.length)
            return h;
        h = x;
        return labeler;
    };
    labeler.label = function (x) {
        // users insert label positions
        if (!arguments.length)
            return lab;
        lab = x;
        return labeler;
    };
    labeler.anchor = function (x) {
        // users insert anchor positions
        if (!arguments.length)
            return anc;
        anc = x;
        return labeler;
    };
    labeler.alt_energy = function (x) {
        // user defined energy
        if (!arguments.length)
            return energy;
        user_defined_energy = x;
        user_energy = true;
        return labeler;
    };
    labeler.alt_schedule = function (x) {
        // user defined cooling_schedule
        if (!arguments.length)
            return cooling_schedule;
        user_defined_schedule = x;
        user_schedule = true;
        return labeler;
    };
    return labeler;
}
exports.default = default_1;
/*eslint-enable */


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Annotation = _interopRequireDefault(__webpack_require__(161));

var _classnames = _interopRequireDefault(__webpack_require__(31));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EditableAnnotation =
/*#__PURE__*/
function (_React$Component) {
  _inherits(EditableAnnotation, _React$Component);

  function EditableAnnotation() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, EditableAnnotation);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditableAnnotation)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    });

    return _this;
  }

  _createClass(EditableAnnotation, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        x: this.props.x,
        y: this.props.y,
        dx: this.props.dx,
        dy: this.props.dy
      });
    }
  }, {
    key: "getData",
    value: function getData() {
      return Object.assign({}, this.props, this.state);
    }
  }, {
    key: "dragEnd",
    value: function dragEnd() {
      if (this.props.onDragEnd) {
        this.props.onDragEnd(this.getData());
      }
    }
  }, {
    key: "dragStart",
    value: function dragStart() {
      if (this.props.onDragStart) {
        this.props.onDragStart(this.getData());
      }
    }
  }, {
    key: "dragSubject",
    value: function dragSubject(event, data) {
      var _this2 = this;

      this.setState({
        x: this.state.x + data.deltaX,
        y: this.state.y + data.deltaY
      }, function () {
        if (_this2.props.onDrag) _this2.props.onDrag(_this2.getData());
      });
    }
  }, {
    key: "dragConnectorSettings",
    value: function dragConnectorSettings(event, data) {
      var _this3 = this;

      this.setState(data, function () {
        if (_this3.props.onDrag) _this3.props.onDrag(_this3.getData());
      });
    }
  }, {
    key: "dragSubjectSettings",
    value: function dragSubjectSettings(event, data) {
      var _this4 = this;

      this.setState(data, function () {
        if (_this4.props.onDrag) _this4.props.onDrag(_this4.getData());
      });
    }
  }, {
    key: "dragNote",
    value: function dragNote(event, data) {
      var _this5 = this;

      this.setState({
        dx: this.state.dx + data.deltaX,
        dy: this.state.dy + data.deltaY
      }, function () {
        if (_this5.props.onDrag) _this5.props.onDrag(_this5.getData());
      });
    }
  }, {
    key: "render",
    value: function render() {
      var cleanedProps = Object.assign({}, this.props, _objectSpread({}, this.state, {
        dragSubject: this.dragSubject.bind(this),
        dragNote: this.dragNote.bind(this),
        dragSubjectSettings: this.dragSubjectSettings.bind(this),
        dragConnectorSettings: this.dragConnectorSettings.bind(this),
        dragEnd: this.dragEnd.bind(this),
        dragStart: this.dragStart.bind(this),
        editMode: true,
        className: (0, _classnames.default)(this.props.className, "editable")
      }));
      return _react.default.createElement(_Annotation.default, cleanedProps);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props) {
      return {
        x: props.x,
        y: props.y,
        dx: props.dx,
        dy: props.dy
      };
    }
  }]);

  return EditableAnnotation;
}(_react.default.Component);

exports.default = EditableAnnotation;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

exports.default = function (_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      radiusPadding = _ref.radiusPadding,
      width = _ref.width,
      height = _ref.height;

  var x1 = 0,
      x2 = dx,
      y1 = 0,
      y2 = dy;

  if (width && height) {
    if (width > 0 && dx > 0 || width < 0 && dx < 0) {
      if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
    }
    if (height > 0 && dy > 0 || height < 0 && dy < 0) {
      if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
    }
    if (x1 === width / 2 && y1 === height / 2) {
      x1 = x2;
      y1 = y2;
    }
  }

  var data = [[x1, y1], [x2, y2]];

  var diffY = y2 - y1;
  var diffX = x2 - x1;
  var xe = x2;
  var ye = y2;
  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

  if (Math.abs(diffX) < Math.abs(diffY)) {
    xe = x2;
    ye = y1 + diffX * opposite;
  } else {
    ye = y2;
    xe = x1 + diffY * opposite;
  }

  if (outerRadius || radius) {
    var r = (outerRadius || radius) + (radiusPadding || 0);
    var length = r / Math.sqrt(2);

    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
      x1 = length * (x2 < 0 ? -1 : 1);
      y1 = length * (y2 < 0 ? -1 : 1);
      data = [[x1, y1], [xe, ye], [x2, y2]];
    } else if (Math.abs(diffX) > Math.abs(diffY)) {
      var angle = Math.asin(-y2 / r);
      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      data = [[x1, y2], [x2, y2]];
    } else {
      var _angle = Math.acos(x2 / r);
      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
      data = [[x2, y1], [x2, y2]];
    }
  } else {
    data = [[x1, y1], [xe, ye], [x2, y2]];
  }

  return { components: [(0, _Builder.lineBuilder)({ data: data, className: "connector" })] };
};

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeCurve = _interopRequireDefault(__webpack_require__(259));

var _Connector2 = _interopRequireDefault(__webpack_require__(117));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorCurve =
/*#__PURE__*/
function (_Connector) {
  _inherits(ConnectorCurve, _Connector);

  function ConnectorCurve() {
    _classCallCheck(this, ConnectorCurve);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorCurve).apply(this, arguments));
  }

  _createClass(ConnectorCurve, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var curve = _ref.curve,
          points = _ref.points,
          x = _ref.x,
          y = _ref.y,
          dx = _ref.dx,
          dy = _ref.dy,
          radius = _ref.radius,
          outerRadius = _ref.outerRadius,
          width = _ref.width,
          height = _ref.height,
          editMode = _ref.editMode;
      var components = (0, _typeCurve.default)({
        curve: curve,
        points: points,
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        radius: radius,
        outerRadius: outerRadius,
        width: width,
        height: height,
        editMode: editMode
      });
      components.handleKeys = {
        points: components.handles
      };

      components.handleFunction = function (h, data) {
        var p = components.points.slice(0);
        p[h.index] = [h.x + data.oDeltaX, h.y + data.oDeltaY];
        return {
          points: p
        };
      };

      return components;
    }
  }]);

  return ConnectorCurve;
}(_Connector2.default);

exports.default = ConnectorCurve;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

var _typeLine = __webpack_require__(162);

var _d3Shape = __webpack_require__(224);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createPoints = function createPoints(offset) {
  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
  var p = [];

  var i = 1;
  for (; i <= anchors; i++) {
    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
  }
  return p;
};

exports.default = function (_ref) {
  var curve = _ref.curve,
      points = _ref.points,
      x = _ref.x,
      y = _ref.y,
      dx = _ref.dx,
      dy = _ref.dy,
      radius = _ref.radius,
      outerRadius = _ref.outerRadius,
      width = _ref.width,
      height = _ref.height,
      editMode = _ref.editMode;

  if (!points || typeof points === "number") {
    points = createPoints({ x: dx, y: dy }, points);
  }
  if (!curve) {
    curve = _d3Shape.curveCatmullRom;
  }

  var handles = [];

  if (editMode) {
    handles = points.map(function (c, i) {
      return { index: i, x: c[0], y: c[1] };
    });
  }

  var data = (0, _typeLine.lineSetup)({ x: x, y: y, dx: dx, dy: dy, radius: radius, outerRadius: outerRadius, width: width, height: height });
  data = [data[0]].concat(_toConsumableArray(points), [data[1]]);
  var components = [(0, _Builder.lineBuilder)({ data: data, curve: curve, className: "connector" })];

  return { components: components, handles: handles, points: points };
};

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _endDot = _interopRequireDefault(__webpack_require__(261));

var _ConnectorEnd2 = _interopRequireDefault(__webpack_require__(163));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEndDot =
/*#__PURE__*/
function (_ConnectorEnd) {
  _inherits(ConnectorEndDot, _ConnectorEnd);

  function ConnectorEndDot() {
    _classCallCheck(this, ConnectorEndDot);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEndDot).apply(this, arguments));
  }

  _createClass(ConnectorEndDot, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          lineData = _ref.lineData,
          scale = _ref.scale;
      return (0, _endDot.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        lineData: lineData,
        scale: scale
      });
    }
  }]);

  return ConnectorEndDot;
}(_ConnectorEnd2.default);

exports.default = ConnectorEndDot;
ConnectorEndDot.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  scale: _propTypes.default.number,
  lineData: _propTypes.default.array //array of arrays of x,y coordinates for the connector line

};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

exports.default = function (_ref) {
  var lineData = _ref.lineData,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  var dot = (0, _Builder.arcBuilder)({
    className: "connector-end connector-dot",
    classID: "connector-end",
    data: { radius: 3 * Math.sqrt(scale) }
  });
  dot.attrs.transform = "translate(" + lineData[0][0] + ", " + lineData[0][1] + ")";

  return { components: [dot] };
};

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _endArrow = _interopRequireDefault(__webpack_require__(263));

var _ConnectorEnd2 = _interopRequireDefault(__webpack_require__(163));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ConnectorEndArrow =
/*#__PURE__*/
function (_ConnectorEnd) {
  _inherits(ConnectorEndArrow, _ConnectorEnd);

  function ConnectorEndArrow() {
    _classCallCheck(this, ConnectorEndArrow);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectorEndArrow).apply(this, arguments));
  }

  _createClass(ConnectorEndArrow, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x = _ref.x,
          y = _ref.y,
          dy = _ref.dy,
          dx = _ref.dx,
          lineData = _ref.lineData,
          scale = _ref.scale;
      var start = lineData[1];
      var end = lineData[0];
      var distance = Math.sqrt(Math.pow(start[0] - end[0], 2) + Math.pow(start[1] - end[1], 2));

      if (distance < 5 && lineData[2]) {
        start = lineData[2];
      }

      return (0, _endArrow.default)({
        x: x,
        y: y,
        dx: dx,
        dy: dy,
        start: start,
        end: end,
        scale: scale
      });
    }
  }]);

  return ConnectorEndArrow;
}(_ConnectorEnd2.default);

exports.default = ConnectorEndArrow;
ConnectorEndArrow.propTypes = {
  x: _propTypes.default.number,
  y: _propTypes.default.number,
  dx: _propTypes.default.number,
  dy: _propTypes.default.number,
  scale: _propTypes.default.number,
  lineData: _propTypes.default.array
};

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

exports.default = function (_ref) {
  var dx = _ref.dx,
      dy = _ref.dy,
      start = _ref.start,
      end = _ref.end,
      _ref$scale = _ref.scale,
      scale = _ref$scale === undefined ? 1 : _ref$scale;

  if (!start) {
    start = [dx, dy];
  } else {
    start = [-end[0] + start[0], -end[1] + start[1]];
  }
  if (!end) {
    end = [0, 0];
  }

  var x1 = end[0],
      y1 = end[1];

  var size = 10 * scale;
  var angleOffset = 16 / 180 * Math.PI;
  var angle = Math.atan(start[1] / start[0]);

  if (start[0] < 0) {
    angle += Math.PI;
  }

  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

  //TODO add in reverse
  // if (canvasContext.arrowReverse){
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // } else {
  //   data = [[x1, y1],
  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
  //   [x1, y1]
  //   ]
  // }

  return {
    components: [(0, _Builder.lineBuilder)({
      data: data,
      className: "connector-end connector-arrow",
      classID: "connector-end"
    })]
  };
};

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

var _alignment = __webpack_require__(118);

exports.default = function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      bbox = _ref.bbox,
      offset = _ref.offset;

  align = (0, _alignment.leftRightDynamic)(align, offset.y);

  if (align === "top") {
    y -= bbox.height;
  } else if (align === "middle") {
    y -= bbox.height / 2;
  }

  var data = [[x, y], [x, y + bbox.height]];
  return { components: [(0, _Builder.lineBuilder)({ data: data, className: "note-line" })] };
};

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

var _alignment = __webpack_require__(118);

exports.default = function (_ref) {
  var align = _ref.align,
      _ref$x = _ref.x,
      x = _ref$x === undefined ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === undefined ? 0 : _ref$y,
      offset = _ref.offset,
      bbox = _ref.bbox;

  align = (0, _alignment.topBottomDynamic)(align, offset.x);

  if (align === "right") {
    x -= bbox.width;
  } else if (align === "middle") {
    x -= bbox.width / 2;
  }

  var data = [[x, y], [x + bbox.width, y]];
  return { components: [(0, _Builder.lineBuilder)({ data: data, className: "note-line" })] };
};

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = JSXNote;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Handle = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */
function JSXNote(props) {
  var note = props.note,
      dx = props.dx,
      dy = props.dy,
      editMode = props.editMode,
      dragStart = props.dragStart,
      dragEnd = props.dragEnd,
      dragNote = props.dragNote;
  var handle;

  if (editMode) {
    handle = _react.default.createElement(_Handle.default, {
      handleStart: dragStart,
      handleStop: dragEnd,
      handleDrag: dragNote
    });
  }

  return _react.default.createElement("g", {
    className: "annotation-note",
    transform: "translate(".concat(dx, ", ").concat(dy, ")")
  }, typeof note === "function" ? note(props) : note, handle);
}

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={exports:{},id:n,loaded:!1};return t[n].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";t.exports={Node:r(1),Force:r(2),Distributor:r(3),Renderer:r(10)}},function(t,e){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=function(){function t(e,n,i){r(this,t),this.idealPos=e,this.currentPos=e,this.width=n,this.data=i,this.layerIndex=0}return n(t,[{key:"distanceFrom",value:function(t){var e=this.width/2,r=t.width/2;return Math.max(this.currentPos-e,t.currentPos-r)-Math.min(this.currentPos+e,t.currentPos+r)}},{key:"moveToIdealPosition",value:function(){return this.currentPos=this.idealPos,this}},{key:"displacement",value:function(){return this.idealPos-this.currentPos}},{key:"overlapWithNode",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.distanceFrom(t)-e<0}},{key:"overlapWithPoint",value:function(t){var e=this.width/2;return t>=this.currentPos-e&&t<=this.currentPos+e}},{key:"positionBefore",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.currentLeft()-this.width/2-e}},{key:"positionAfter",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.currentRight()+this.width/2+e}},{key:"currentRight",value:function(){return this.currentPos+this.width/2}},{key:"currentLeft",value:function(){return this.currentPos-this.width/2}},{key:"idealRight",value:function(){return this.idealPos+this.width/2}},{key:"idealLeft",value:function(){return this.idealPos-this.width/2}},{key:"createStub",value:function(e){var r=new t(this.idealPos,e,this.data);return r.currentPos=this.currentPos,r.child=this,this.parent=r,r}},{key:"removeStub",value:function(){return this.parent&&(this.parent.child=null,this.parent=null),this}},{key:"isStub",value:function(){return!!this.child}},{key:"getPathToRoot",value:function(){for(var t=[],e=this;e;)t.push(e),e=e.parent;return t}},{key:"getPathFromRoot",value:function(){return this.getPathToRoot().reverse()}},{key:"getPathToRootLength",value:function(){for(var t=0,e=this;e;){var r=e.parent?e.parent.currentPos:e.idealPos;t+=Math.abs(e.currentPos-r),e=e.parent}return t}},{key:"getRoot",value:function(){for(var t=this,e=this;e;)t=e,e=e.parent;return t}},{key:"getLayerIndex",value:function(){return this.layerIndex}},{key:"clone",value:function(){var e=new t(this.idealPos,this.width,this.data);return e.currentPos=this.currentPos,e.layerIndex=this.layerIndex,e}}]),t}();t.exports=i},function(t,e,r){"use strict";var n=r(3),i=r(4),o=r(8),s={nodeSpacing:3,minPos:0,maxPos:null,algorithm:"overlap",removeOverlap:!0,density:.85,stubWidth:1},u=function(t){var e={},r=i.extend({},s),u=new n,a=[],c=null;return e.nodes=function(t){return arguments.length?(a=t,c=[t.concat()],e):a},e.getLayers=function(){return c},e.options=function(t){if(!arguments.length)return r;r=i.extend(r,t);var o=i.pick(r,Object.keys(n.DEFAULT_OPTIONS));return i.isDefined(r.minPos)&&i.isDefined(r.maxPos)?o.layerWidth=r.maxPos-r.minPos:o.layerWidth=null,u.options(o),e},e.options(t),e.compute=function(){var t=i.pick(r,Object.keys(o.DEFAULT_OPTIONS));return a.forEach(function(t){t.removeStub()}),c=u.distribute(a),c.map(function(e,n){e.forEach(function(t){t.layerIndex=n}),r.removeOverlap&&o(e,t)}),e},e.start=function(){console.log("[warning] force.start() is deprecated. Please use force.compute() instead.")},e};u.DEFAULT_OPTIONS=s,t.exports=u},function(t,e,r){"use strict";var n=r(4),i=r(6),o={algorithm:"overlap",layerWidth:1e3,density:.75,nodeSpacing:3,stubWidth:1},s=function(t){var e={};t=n.extend({},o,t),e.options=function(r){return arguments.length?(t=n.extend(t,r),e):t},e.computeRequiredWidth=function(e){return n.sum(e,function(e){return e.width+t.nodeSpacing})-t.nodeSpacing},e.maxWidthPerLayer=function(){return t.density*t.layerWidth},e.needToSplit=function(t){return e.estimateRequiredLayers(t)>1},e.estimateRequiredLayers=function(r){return t.layerWidth?Math.ceil(e.computeRequiredWidth(r)/e.maxWidthPerLayer()):1};var r={simple:function(r){for(var n=e.estimateRequiredLayers(r),i=[],o=0;o<n;o++)i.push([]);return r.forEach(function(e,r){var o=r%n;i[o].push(e);for(var s=e,u=o-1;u>=0;u--)s=s.createStub(t.stubWidth),i[u].push(s)}),i},roundRobin:function(t){var e=[];return e},overlap:function(r){for(var n=[],i=e.maxWidthPerLayer(),o=r.concat(),s=e.computeRequiredWidth(o);s>i;){e.countIdealOverlaps(o);var u=o.concat(),a=s;for(o=[];u.length>2&&a>i;){u.sort(function(t,e){return e.overlapCount-t.overlapCount});var c=u.shift();a-=c.width,a+=t.stubWidth,c.overlaps.forEach(function(t){t.overlapCount--}),o.push(c)}n.push(u),s=e.computeRequiredWidth(o)}o.length>0&&n.push(o);for(var h=n.length-1;h>=1;h--)for(var l=n[h],f=0;f<l.length;f++){var p=l[f];if(!p.isStub())for(var d=p,v=h-1;v>=0;v--)d=d.createStub(t.stubWidth),n[v].push(d)}return n}};return e.countIdealOverlaps=function(e){var r=new i(t.layerWidth/2);return e.forEach(function(t){r.add([t.idealLeft(),t.idealRight(),t])}),e.forEach(function(t){var e=r.search(t.idealLeft(),t.idealRight());t.overlaps=e.map(function(t){return t.data[2]}),t.overlapCount=e.length}),e},e.distribute=function(i){if(!i||0===i.length)return[];if("none"==t.algorithm||!n.isDefined(t.algorithm))return[i];if(!e.needToSplit(i))return[i];var o=i.concat().sort(function(t,e){return t.idealPos-e.idealPos});if("function"==typeof t.algorithm)return t.algorithm(o,t);if(r.hasOwnProperty(t.algorithm))return r[t.algorithm](o);throw"Unknown algorithm: "+t.algorithm},e};s.DEFAULT_OPTIONS=o,t.exports=s},function(t,e,r){"use strict";var n={isDefined:function(t){return null!==t&&void 0!==t},last:function(t){return t.length>0?t[t.length-1]:null},pick:function(t,e){return e.reduce(function(e,r){return e[r]=t[r],e},{})},sum:function(t,e){return t.map(e).reduce(function(t,e){return t+e},0)}};n.extend=r(5),t.exports=n},function(t,e){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n=Object.prototype.hasOwnProperty,i=Object.prototype.toString,o=function(t){return"function"==typeof Array.isArray?Array.isArray(t):"[object Array]"===i.call(t)},s=function(t){if(!t||"[object Object]"!==i.call(t))return!1;var e=n.call(t,"constructor"),r=t.constructor&&t.constructor.prototype&&n.call(t.constructor.prototype,"isPrototypeOf");if(t.constructor&&!e&&!r)return!1;var o;for(o in t);return void 0===o||n.call(t,o)};t.exports=function u(){var t,e,n,i,a,c,h=arguments[0],l=1,f=arguments.length,p=!1;for("boolean"==typeof h?(p=h,h=arguments[1]||{},l=2):("object"!==("undefined"==typeof h?"undefined":r(h))&&"function"!=typeof h||null==h)&&(h={});l<f;++l)if(t=arguments[l],null!=t)for(e in t)n=h[e],i=t[e],h!==i&&(p&&i&&(s(i)||(a=o(i)))?(a?(a=!1,c=n&&o(n)?n:[]):c=n&&s(n)?n:{},h[e]=u(p,c,i)):void 0!==i&&(h[e]=i));return h}},function(t,e,r){"use strict";function n(t,e){if(e||(e={}),this.startKey=e.startKey||0,this.endKey=e.endKey||1,this.intervalHash={},this.pointTree=new c({compare:function(t,e){if(null==t)return-1;if(null==e)return 1;var r=t[0]-e[0];return r>0?1:0==r?0:-1}}),this._autoIncrement=0,!t||"number"!=typeof t)throw new Error("you must specify center index as the 2nd argument.");this.root=new u(t,this)}function i(t,e){return e.end<t.idx?(t.left||(t.left=new u(e.start+e.end>>1,this)),i.call(this,t.left,e)):t.idx<e.start?(t.right||(t.right=new u(e.start+e.end>>1,this)),i.call(this,t.right,e)):t.insert(e)}function o(t,e,r){if(t)return e<t.idx?(t.starts.every(function(t){var n=t.start<=e;return n&&r.push(t.result()),n}),o.call(this,t.left,e,r)):e>t.idx?(t.ends.every(function(t){var n=t.end>=e;return n&&r.push(t.result()),n}),o.call(this,t.right,e,r)):void t.starts.map(function(t){r.push(t.result())})}function s(t,e,r){if(e-t<=0)throw new Error("end must be greater than start. start: "+t+", end: "+e);var n={},i=[];o.call(this,this.root,t+e>>1,i,!0),i.forEach(function(t){n[t.id]=!0});for(var s=this.pointTree.bsearch([t,null]),u=this.pointTree;s>=0&&u[s][0]==t;)s--;var a=this.pointTree.bsearch([e,null]);if(a>=0){for(var c=u.length-1;a<=c&&u[a][0]<=e;)a++;u.slice(s+1,a).forEach(function(t){var e=t[1];n[e]=!0},this),Object.keys(n).forEach(function(n){var i=this.intervalHash[n];r.push(i.result(t,e))},this)}}function u(t){this.idx=t,this.starts=new c({compare:function(t,e){if(null==t)return-1;if(null==e)return 1;var r=t.start-e.start;return r>0?1:0==r?0:-1}}),this.ends=new c({compare:function(t,e){if(null==t)return-1;if(null==e)return 1;var r=t.end-e.end;return r<0?1:0==r?0:-1}})}function a(t,e,r,n){if(this.id=e,this.start=t[r],this.end=t[n],this.data=t,"number"!=typeof this.start||"number"!=typeof this.end)throw new Error("start, end must be number. start: "+this.start+", end: "+this.end);if(this.start>=this.end)throw new Error("start must be smaller than end. start: "+this.start+", end: "+this.end)}var c=r(7);n.prototype.add=function(t,e){if(this.intervalHash[e])throw new Error("id "+e+" is already registered.");if(void 0==e){for(;this.intervalHash[this._autoIncrement];)this._autoIncrement++;e=this._autoIncrement}var r=new a(t,e,this.startKey,this.endKey);this.pointTree.insert([r.start,e]),this.pointTree.insert([r.end,e]),this.intervalHash[e]=r,this._autoIncrement++,i.call(this,this.root,r)},n.prototype.search=function(t,e){var r=[];if("number"!=typeof t)throw new Error(t+": invalid input");if(void 0==e)o.call(this,this.root,t,r);else{if("number"!=typeof e)throw new Error(t+","+e+": invalid input");s.call(this,t,e,r)}return r},n.prototype.remove=function(t){},u.prototype.insert=function(t){this.starts.insert(t),this.ends.insert(t)},a.prototype.result=function(t,e){var r={id:this.id,data:this.data};if("number"==typeof t&&"number"==typeof e){var n=Math.max(this.start,t),i=Math.min(this.end,e),o=i-n;r.rate1=o/(e-t),r.rate2=o/(this.end-this.start)}return r},t.exports=n},function(t,e){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n=function i(){var t=null,e={},n=arguments;["0","1"].forEach(function(i){var o=n[i];Array.isArray(o)?t=o:o&&"object"==("undefined"==typeof o?"undefined":r(o))&&(e=o)}),"function"==typeof e.filter&&(this._filter=e.filter),"function"==typeof e.compare?this._compare=e.compare:"string"==typeof e.compare&&i.compares[e.compare]&&(this._compare=i.compares[e.compare]),this._unique=!!e.unique,e.resume&&t?t.forEach(function(t,e){this.push(t)},this):t&&this.insert.apply(this,t)};n.create=function(t,e){return new n(t,e)},n.prototype=new Array,n.prototype.constructor=Array.prototype.constructor,n.prototype.insertOne=function(t){var e=this.bsearch(t);return(!this._unique||null==this.key(t,e))&&(!!this._filter(t,e)&&(this.splice(e+1,0,t),e+1))},n.prototype.insert=function(){return Array.prototype.map.call(arguments,function(t){return this.insertOne(t)},this)},n.prototype.remove=function(t){return this.splice(t,1),this},n.prototype.bsearch=function(t){if(!this.length)return-1;for(var e,r=0,n=this.length;n-r>1;){e=Math.floor((r+n)/2);var i=this[e],o=this._compare(t,i);if(0==o)return e;o>0?r=e:n=e}return 0==r&&this._compare(this[0],t)>0?-1:r},n.prototype.key=function(t,e){null==e&&(e=this.bsearch(t));var r=e;if(r==-1||this._compare(this[r],t)<0)return r+1<this.length&&0==this._compare(this[r+1],t)?r+1:null;for(;r>=1&&0==this._compare(this[r-1],t);)r--;return r},n.prototype.keys=function(t,e){var r=[];null==e&&(e=this.bsearch(t));for(var n=e;n>=0&&0==this._compare(this[n],t);)r.push(n),n--;var i=this.length;for(n=e+1;n<i&&0==this._compare(this[n],t);)r.push(n),n++;return r.length?r:null},n.prototype.unique=function(t){if(t)return this.filter(function(t,e){return 0==e||0!=this._compare(this[e-1],t)},this);var e=0;return this.map(function(t,r){return 0==r||0!=this._compare(this[r-1],t)?null:r-e++},this).forEach(function(t){null!=t&&this.remove(t)},this),this},n.prototype.toArray=function(){return this.slice()},n.prototype._filter=function(t,e){return!0},n.compares={number:function(t,e){var r=t-e;return r>0?1:0==r?0:-1},string:function(t,e){return t>e?1:t==e?0:-1}},n.prototype._compare=n.compares.string,t.exports=n},function(t,e,r){"use strict";function n(t){var e=new s.Variable(t.targetPos);return e.node=t,e}function i(t,e){if(t.length>0){e=o.extend(u,e),t.forEach(function(t,e){t.targetPos=t.parent?t.parent.currentPos:t.idealPos,t.index=e});for(var r=t.concat().sort(function(t,e){var r=t.targetPos-e.targetPos;if(0!==r)return r;var n=t.isStub()-e.isStub();return 0!==n?n:t.index-e.index}).map(n),i=[],a=1;a<r.length;a++){var c=r[a-1],h=r[a],l=void 0;l=c.node.isStub()&&h.node.isStub()?(c.node.width+h.node.width)/2+e.lineSpacing:(c.node.width+h.node.width)/2+e.nodeSpacing,i.push(new s.Constraint(c,h,l))}if(o.isDefined(e.minPos)){var f=new s.Variable(e.minPos,1e10),p=r[0];i.push(new s.Constraint(f,p,p.node.width/2)),r.unshift(f)}if(o.isDefined(e.maxPos)){var d=new s.Variable(e.maxPos,1e10),v=o.last(r);i.push(new s.Constraint(v,d,v.node.width/2)),r.push(d)}new s.Solver(r,i).solve(),r.filter(function(t){return t.node}).map(function(t){return t.node.currentPos=Math.round(t.position()),t})}return t}var o=r(4),s=r(9),u={lineSpacing:2,nodeSpacing:3,minPos:0,maxPos:null};i.DEFAULT_OPTIONS=u,t.exports=i},function(t,e){"use strict";var r={},n=function(){function t(t){this.scale=t,this.AB=0,this.AD=0,this.A2=0}return t.prototype.addVariable=function(t){var e=this.scale/t.scale,r=t.offset/t.scale,n=t.weight;this.AB+=n*e*r,this.AD+=n*e*t.desiredPosition,this.A2+=n*e*e},t.prototype.getPosn=function(){return(this.AD-this.AB)/this.A2},t}();r.PositionStats=n;var i=function(){function t(t,e,r,n){void 0===n&&(n=!1),this.left=t,this.right=e,this.gap=r,this.equality=n,this.active=!1,this.unsatisfiable=!1,this.left=t,this.right=e,this.gap=r,this.equality=n}return t.prototype.slack=function(){return this.unsatisfiable?Number.MAX_VALUE:this.right.scale*this.right.position()-this.gap-this.left.scale*this.left.position()},t}();r.Constraint=i;var o=function(){function t(t,e,r){void 0===e&&(e=1),void 0===r&&(r=1),this.desiredPosition=t,this.weight=e,this.scale=r,this.offset=0}return t.prototype.dfdv=function(){return 2*this.weight*(this.position()-this.desiredPosition)},t.prototype.position=function(){return(this.block.ps.scale*this.block.posn+this.offset)/this.scale},t.prototype.visitNeighbours=function(t,e){var r=function(r,n){return r.active&&t!==n&&e(r,n)};this.cOut.forEach(function(t){return r(t,t.right)}),this.cIn.forEach(function(t){return r(t,t.left)})},t}();r.Variable=o;var s=function(){function t(t){this.vars=[],t.offset=0,this.ps=new n(t.scale),this.addVariable(t)}return t.prototype.addVariable=function(t){t.block=this,this.vars.push(t),this.ps.addVariable(t),this.posn=this.ps.getPosn()},t.prototype.updateWeightedPosition=function(){this.ps.AB=this.ps.AD=this.ps.A2=0;for(var t=0,e=this.vars.length;t<e;++t)this.ps.addVariable(this.vars[t]);this.posn=this.ps.getPosn()},t.prototype.compute_lm=function(t,e,r){var n=this,i=t.dfdv();return t.visitNeighbours(e,function(e,o){var s=n.compute_lm(o,t,r);o===e.right?(i+=s*e.left.scale,e.lm=s):(i+=s*e.right.scale,e.lm=-s),r(e)}),i/t.scale},t.prototype.populateSplitBlock=function(t,e){var r=this;t.visitNeighbours(e,function(e,n){n.offset=t.offset+(n===e.right?e.gap:-e.gap),r.addVariable(n),r.populateSplitBlock(n,t)})},t.prototype.traverse=function(t,e,r,n){var i=this;void 0===r&&(r=this.vars[0]),void 0===n&&(n=null),r.visitNeighbours(n,function(n,o){e.push(t(n)),i.traverse(t,e,o,r)})},t.prototype.findMinLM=function(){var t=null;return this.compute_lm(this.vars[0],null,function(e){!e.equality&&(null===t||e.lm<t.lm)&&(t=e)}),t},t.prototype.findMinLMBetween=function(t,e){this.compute_lm(t,null,function(){});var r=null;return this.findPath(t,null,e,function(t,e){!t.equality&&t.right===e&&(null===r||t.lm<r.lm)&&(r=t)}),r},t.prototype.findPath=function(t,e,r,n){var i=this,o=!1;return t.visitNeighbours(e,function(e,s){o||s!==r&&!i.findPath(s,t,r,n)||(o=!0,n(e,s))}),o},t.prototype.isActiveDirectedPathBetween=function(t,e){if(t===e)return!0;for(var r=t.cOut.length;r--;){var n=t.cOut[r];if(n.active&&this.isActiveDirectedPathBetween(n.right,e))return!0}return!1},t.split=function(e){return e.active=!1,[t.createSplitBlock(e.left),t.createSplitBlock(e.right)]},t.createSplitBlock=function(e){var r=new t(e);return r.populateSplitBlock(e,null),r},t.prototype.splitBetween=function(e,r){var n=this.findMinLMBetween(e,r);if(null!==n){var i=t.split(n);return{constraint:n,lb:i[0],rb:i[1]}}return null},t.prototype.mergeAcross=function(t,e,r){e.active=!0;for(var n=0,i=t.vars.length;n<i;++n){var o=t.vars[n];o.offset+=r,this.addVariable(o)}this.posn=this.ps.getPosn()},t.prototype.cost=function(){for(var t=0,e=this.vars.length;e--;){var r=this.vars[e],n=r.position()-r.desiredPosition;t+=n*n*r.weight}return t},t}();r.Block=s;var u=function(){function t(t){this.vs=t;var e=t.length;for(this.list=new Array(e);e--;){var r=new s(t[e]);this.list[e]=r,r.blockInd=e}}return t.prototype.cost=function(){for(var t=0,e=this.list.length;e--;)t+=this.list[e].cost();return t},t.prototype.insert=function(t){t.blockInd=this.list.length,this.list.push(t)},t.prototype.remove=function(t){var e=this.list.length-1,r=this.list[e];this.list.length=e,t!==r&&(this.list[t.blockInd]=r,r.blockInd=t.blockInd)},t.prototype.merge=function(t){var e=t.left.block,r=t.right.block,n=t.right.offset-t.left.offset-t.gap;e.vars.length<r.vars.length?(r.mergeAcross(e,t,n),this.remove(e)):(e.mergeAcross(r,t,-n),this.remove(r))},t.prototype.forEach=function(t){this.list.forEach(t)},t.prototype.updateBlockPositions=function(){this.list.forEach(function(t){return t.updateWeightedPosition()})},t.prototype.split=function(t){var e=this;this.updateBlockPositions(),this.list.forEach(function(r){var n=r.findMinLM();null!==n&&n.lm<a.LAGRANGIAN_TOLERANCE&&(r=n.left.block,s.split(n).forEach(function(t){return e.insert(t)}),e.remove(r),t.push(n))})},t}();r.Blocks=u;var a=function(){function t(t,e){this.vs=t,this.cs=e,this.vs=t,t.forEach(function(t){t.cIn=[],t.cOut=[]}),this.cs=e,e.forEach(function(t){t.left.cOut.push(t),t.right.cIn.push(t)}),this.inactive=e.map(function(t){return t.active=!1,t}),this.bs=null}return t.prototype.cost=function(){return this.bs.cost()},t.prototype.setStartingPositions=function(t){this.inactive=this.cs.map(function(t){return t.active=!1,t}),this.bs=new u(this.vs),this.bs.forEach(function(e,r){return e.posn=t[r]})},t.prototype.setDesiredPositions=function(t){this.vs.forEach(function(e,r){return e.desiredPosition=t[r]})},t.prototype.mostViolated=function(){for(var e=Number.MAX_VALUE,r=null,n=this.inactive,i=n.length,o=i,s=0;s<i;++s){var u=n[s];if(!u.unsatisfiable){var a=u.slack();if((u.equality||a<e)&&(e=a,r=u,o=s,u.equality))break}}return o!==i&&(e<t.ZERO_UPPERBOUND&&!r.active||r.equality)&&(n[o]=n[i-1],n.length=i-1),r},t.prototype.satisfy=function(){null==this.bs&&(this.bs=new u(this.vs)),this.bs.split(this.inactive);for(var e=null;(e=this.mostViolated())&&(e.equality||e.slack()<t.ZERO_UPPERBOUND&&!e.active);){var r=e.left.block,n=e.right.block;if(r!==n)this.bs.merge(e);else{if(r.isActiveDirectedPathBetween(e.right,e.left)){e.unsatisfiable=!0;continue}var i=r.splitBetween(e.left,e.right);if(null===i){e.unsatisfiable=!0;continue}this.bs.insert(i.lb),this.bs.insert(i.rb),this.bs.remove(r),this.inactive.push(i.constraint),e.slack()>=0?this.inactive.push(e):this.bs.merge(e)}}},t.prototype.solve=function(){this.satisfy();for(var t=Number.MAX_VALUE,e=this.bs.cost();Math.abs(t-e)>1e-4;)this.satisfy(),t=e,e=this.bs.cost();return e},t.LAGRANGIAN_TOLERANCE=-1e-4,t.ZERO_UPPERBOUND=-1e-10,t}();r.Solver=a,t.exports=r},function(t,e,r){"use strict";function n(t){this.options=c.extend({layerGap:60,nodeHeight:10,direction:"down"},t)}function i(t){return"L "+t.join(" ")}function o(t){return"M "+t.join(" ")}function s(t,e,r){return"C "+t.join(" ")+" "+e.join(" ")+" "+r.join(" ")}function u(t,e){var r=(t[1]+e[1])/2;return s([t[0],r],[e[0],r],e)}function a(t,e){var r=(t[0]+e[0])/2;return s([r,t[1]],[r,e[1]],e)}var c=r(4);n.lineTo=i,n.moveTo=o,n.curveTo=s,n.vCurveBetween=u,n.hCurveBetween=a,n.prototype.getWaypoints=function(t){var e=this.options,r=e.direction,n=t.getPathFromRoot(),i=e.nodeHeight+e.layerGap;return"left"===r?[[[0,n[0].idealPos]]].concat(n.map(function(t,r){var n=i*(r+1)*-1;return[[n+e.nodeHeight,t.currentPos],[n,t.currentPos]]})):"right"===r?[[[0,n[0].idealPos]]].concat(n.map(function(t,r){var n=i*(r+1);return[[n-e.nodeHeight,t.currentPos],[n,t.currentPos]]})):"up"===r?[[[n[0].idealPos,0]]].concat(n.map(function(t,r){var n=i*(r+1)*-1;return[[t.currentPos,n+e.nodeHeight],[t.currentPos,n]]})):[[[n[0].idealPos,0]]].concat(n.map(function(t,r){var n=i*(r+1);return[[t.currentPos,n-e.nodeHeight],[t.currentPos,n]]}))},n.prototype.layout=function(t){var e=this.options,r=e.layerGap+e.nodeHeight;switch(e.direction){case"left":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=-n-e.nodeHeight,t.y=t.currentPos,t.dx=e.nodeHeight,t.dy=t.width});break;case"right":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=n,t.y=t.currentPos,t.dx=e.nodeHeight,t.dy=t.width});break;case"up":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=t.currentPos,t.y=-n-e.nodeHeight,t.dx=t.width,t.dy=e.nodeHeight});break;default:case"down":t.forEach(function(t){var n=t.getLayerIndex()*r+e.layerGap;t.x=t.currentPos,t.y=n,t.dx=t.width,t.dy=e.nodeHeight})}return t},n.prototype.generatePath=function(t){var e=this.options,r=e.direction,n=this.getWaypoints(t,r),s=[o(n[0][0])];return"left"===r||"right"===r?n.reduce(function(t,e,r){return s.push(a(t[t.length-1],e[0])),r<n.length-1&&s.push(i(e[1])),e}):n.reduce(function(t,e,r){return s.push(u(t[t.length-1],e[0])),r<n.length-1&&s.push(i(e[1])),e}),s.join(" ")},t.exports=n}])});

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_shape_1 = __webpack_require__(18);
var lineDrawing_1 = __webpack_require__(68);
// components
var semiotic_mark_1 = __webpack_require__(15);
var DividedLine = /** @class */ (function (_super) {
    __extends(DividedLine, _super);
    function DividedLine(props) {
        var _this = _super.call(this, props) || this;
        _this.createLineSegments = _this.createLineSegments.bind(_this);
        return _this;
    }
    DividedLine.prototype.createLineSegments = function () {
        var _a = this.props, parameters = _a.parameters, className = _a.className, _b = _a.interpolate, interpolate = _b === void 0 ? d3_shape_1.curveLinear : _b, customAccessors = _a.customAccessors, lineDataAccessor = _a.lineDataAccessor, data = _a.data, searchIterations = _a.searchIterations, rest = __rest(_a, ["parameters", "className", "interpolate", "customAccessors", "lineDataAccessor", "data", "searchIterations"]);
        var x = customAccessors.x, y = customAccessors.y;
        var lineData = lineDrawing_1.projectLineData({
            data: data,
            lineDataAccessor: [lineDataAccessor],
            xProp: "x",
            yProp: "y",
            xAccessor: [x],
            yAccessor: [y]
        });
        //Compatibility before Semiotic 2
        lineData.forEach(function (projectedD) {
            projectedD.data = projectedD.data.map(function (d) { return (__assign(__assign({}, d.data), d)); });
        });
        var lines = lineDrawing_1.dividedLine(parameters, lineData[0].data, searchIterations);
        var lineRender = d3_shape_1.line()
            .curve(interpolate)
            .x(function (d) { return d.x; })
            .y(function (d) { return d.y; });
        return lines.map(function (d, i) { return (React.createElement(semiotic_mark_1.Mark, __assign({}, rest, { className: className, markType: "path", key: "DividedLine-" + i, style: d.key, d: lineRender(d.points) }))); });
    };
    DividedLine.prototype.render = function () {
        var lines = this.createLineSegments();
        return React.createElement("g", null, lines);
    };
    return DividedLine;
}(React.Component));
exports.default = DividedLine;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _d3Selection = __webpack_require__(11);

__webpack_require__(112);

var _drawing = __webpack_require__(270);

var _markTransition = __webpack_require__(271);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function generateSketchyHash(props) {
  var _props$style = props.style,
      style = _props$style === undefined ? {} : _props$style;

  var sketchyHash = "";
  _markTransition.redrawSketchyList.forEach(function (d) {
    sketchyHash += "-" + (style[d] || props[d]);
  });
  return sketchyHash;
}

var updateSketchy = function updateSketchy(nextProps, oldSketchyHash) {

  var RoughGenerator = nextProps.sketchyGenerator;

  var renderOptions = nextProps.renderMode !== null && _typeof(nextProps.renderMode) === "object" ? nextProps.renderMode : { renderMode: nextProps.renderMode };

  var sketchyHash = renderOptions.renderMode === "sketchy" && generateSketchyHash(nextProps);
  if (RoughGenerator && sketchyHash && sketchyHash !== oldSketchyHash) {
    var _nextProps$style = nextProps.style,
        style = _nextProps$style === undefined ? {} : _nextProps$style;
    var _renderOptions$simpli = renderOptions.simplification,
        simplification = _renderOptions$simpli === undefined ? 0 : _renderOptions$simpli,
        _renderOptions$curveS = renderOptions.curveStepCount,
        curveStepCount = _renderOptions$curveS === undefined ? 9 : _renderOptions$curveS,
        _renderOptions$fillSt = renderOptions.fillStyle,
        fillStyle = _renderOptions$fillSt === undefined ? "hachure" : _renderOptions$fillSt,
        _renderOptions$roughn = renderOptions.roughness,
        roughness = _renderOptions$roughn === undefined ? 1 : _renderOptions$roughn,
        _renderOptions$bowing = renderOptions.bowing,
        bowing = _renderOptions$bowing === undefined ? 1 : _renderOptions$bowing,
        _renderOptions$fillWe = renderOptions.fillWeight,
        fillWeight = _renderOptions$fillWe === undefined ? 1 : _renderOptions$fillWe,
        _renderOptions$hachur = renderOptions.hachureAngle,
        hachureAngle = _renderOptions$hachur === undefined ? -41 : _renderOptions$hachur;


    var roughGenerator = RoughGenerator({}, { width: 1000, height: 1000 });
    var drawingInstructions = void 0;
    var roughOptions = {
      fill: style.fill || nextProps.fill,
      stroke: style.stroke || nextProps.stroke,
      strokeWidth: style.strokeWidth || nextProps.strokeWidth,
      fillStyle: fillStyle,
      roughness: roughness,
      bowing: bowing,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: renderOptions.hachureGap || style.fillOpacity && (5 - style.fillOpacity * 5) * fillWeight || fillWeight * 2,
      curveStepCount: curveStepCount,
      simplification: simplification
    };

    switch (nextProps.markType) {
      case "line":
        drawingInstructions = roughGenerator.line(nextProps.x1 || 0, nextProps.y1 || 0, nextProps.x2 || 0, nextProps.y2 || 0, roughOptions);
        break;
      case "rect":
        if (nextProps.rx || nextProps.ry) {
          drawingInstructions = roughGenerator.circle((nextProps.x || 0) + nextProps.width / 2, (nextProps.y || 0) + nextProps.width / 2, nextProps.width, roughOptions);
        } else {
          drawingInstructions = roughGenerator.rectangle(nextProps.x || 0, nextProps.y || 0, nextProps.width, nextProps.height, roughOptions);
        }
        break;
      case "circle":
        drawingInstructions = roughGenerator.circle(nextProps.cx || 0, nextProps.cy || 0, nextProps.r * 2, roughOptions);
        break;
      case "ellipse":
        drawingInstructions = roughGenerator.ellipse(nextProps.x || 0, nextProps.y || 0, nextProps.width, nextProps.height, roughOptions);
        break;
      case "polygon":
        drawingInstructions = roughGenerator.polygon(nextProps.points, roughOptions);
        break;
      case "path":
        drawingInstructions = roughGenerator.path(nextProps.d, roughOptions);
        break;
    }

    var fillOpacityStyles = {};
    var strokeOpacityStyles = {};

    // Assume if hachure gap is explicitly set then opacity is real
    if (renderOptions.hachureGap || renderOptions.fillStyle === "solid") {
      fillOpacityStyles.opacity = style.opacity || nextProps.opacity;
      fillOpacityStyles.fillOpacity = style.fillOpacity || nextProps.fillOpacity;
      fillOpacityStyles.strokeOpacity = style.fillOpacity || nextProps.fillOpacity;
      strokeOpacityStyles.opacity = style.opacity || nextProps.opacity;
      strokeOpacityStyles.strokeOpacity = style.strokeOpacity || nextProps.strokeOpacity;
    }

    var roughPieces = [];
    roughGenerator.toPaths(drawingInstructions).forEach(function (_ref, i) {
      var d = _ref.d,
          fill = _ref.fill,
          stroke = _ref.stroke,
          strokeWidth = _ref.strokeWidth,
          pattern = _ref.pattern;


      var opacityStyles = i === 0 ? fillOpacityStyles : strokeOpacityStyles;
      if (pattern) {
        var roughRandomID = "rough-" + Math.random();
        roughPieces.push(_react2.default.createElement(
          "pattern",
          {
            key: "pattern-" + i,
            id: roughRandomID,
            x: pattern.x,
            y: pattern.y,
            height: pattern.height,
            width: pattern.width,
            viewBox: pattern.viewBox
          },
          _react2.default.createElement("path", {
            key: "pattern-path-" + i,
            d: pattern.path.d,
            style: {
              fill: pattern.path.fill,
              stroke: pattern.path.stroke,
              strokeWidth: pattern.path.strokeWidth
            }
          })
        ));
        fill = "url(#" + roughRandomID + ")";
      }
      roughPieces.push(_react2.default.createElement("path", {
        key: "path-" + i,
        d: d,
        style: _extends({
          fill: fill,
          stroke: stroke,
          strokeWidth: strokeWidth
        }, opacityStyles),
        transform: nextProps.transform
      }));
    });

    return {
      sketchyHash: sketchyHash,
      sketchyFill: roughPieces
    };
  }
  return null;
};

var Mark = function (_React$Component) {
  _inherits(Mark, _React$Component);

  function Mark(props) {
    _classCallCheck(this, Mark);

    var _this = _possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).call(this, props));

    _this.state = _extends({
      sketchyFill: undefined,
      sketchyHash: ""
    }, updateSketchy(props, ""));

    return _this;
  }

  _createClass(Mark, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var _this2 = this;

      if (nextProps.renderMode || this.props.renderMode || this.props.markType !== nextProps.markType || this.state.dragging || this.props.forceUpdate || nextProps.forceUpdate || this.props.className !== nextProps.className || this.props.children !== nextProps.children || this.props.customTween && !nextProps.customTween || !this.props.customTween && nextProps.customTween) {
        return true;
      }

      var node = this.node;

      var actualSVG = (0, _drawing.generateSVG)(nextProps, nextProps.className);
      var cloneProps = actualSVG.props;

      if (!cloneProps) {
        return true;
      }

      var _nextProps$transition = nextProps.transitionDuration,
          transitionDuration = _nextProps$transition === undefined ? {} : _nextProps$transition;

      var isDefault = typeof transitionDuration === "number";
      var defaultDuration = isDefault ? transitionDuration : 1000;
      transitionDuration = isDefault ? { default: defaultDuration } : _extends({ default: defaultDuration }, transitionDuration);

      var newProps = Object.keys(cloneProps).filter(function (d) {
        return d !== "style";
      });
      var oldProps = Object.keys(this.props).filter(function (d) {
        return d !== "style" && !newProps.find(function (p) {
          return p === d;
        });
      });

      var hasTransition = (0, _d3Selection.select)(node).select("*").transition;

      function adjustedPropName(propname) {
        return _markTransition.reactCSSNameStyleHash[propname] || propname;
      }

      oldProps.forEach(function (oldProp) {
        if (oldProp !== "style") {
          (0, _d3Selection.select)(node).select("*").attr(adjustedPropName(oldProp), undefined);
        }
      });

      newProps.forEach(function (newProp) {
        if (!hasTransition || !_markTransition.attributeTransitionWhitelist.find(function (d) {
          return d === newProp;
        }) || newProp === "d" && (0, _markTransition.differentD)(cloneProps.d, _this2.props.d)) {
          if (newProp === "d" && nextProps.customTween) {
            (0, _d3Selection.select)(node).select("*").attr("d", nextProps.customTween.fn(nextProps.customTween.props, nextProps.customTween.props)(1));
          } else {
            (0, _d3Selection.select)(node).select("*").attr(adjustedPropName(newProp), cloneProps[newProp]);
          }
        } else {
          var _transitionDuration = transitionDuration,
              defaultDur = _transitionDuration.default,
              _transitionDuration$n = _transitionDuration[newProp],
              appliedDuration = _transitionDuration$n === undefined ? defaultDur : _transitionDuration$n;


          if (newProp === "d" && nextProps.customTween) {
            var initialTweenProps = _extends({}, _this2.props.customTween.props);
            var nextTweenProps = _extends({}, nextProps.customTween.props);
            (0, _d3Selection.select)(node).select("*").transition(adjustedPropName("d")).duration(appliedDuration).attrTween("d", function () {
              return nextProps.customTween.fn(initialTweenProps, nextTweenProps);
            });
          } else {
            (0, _d3Selection.select)(node).select("*").transition(adjustedPropName(newProp)).duration(appliedDuration).attr(adjustedPropName(newProp), cloneProps[newProp]);
          }
        }
      });

      var newStyleProps = Object.keys(cloneProps.style || {});
      var oldStyleProps = Object.keys(this.props.style || {}).filter(function (d) {
        return !newStyleProps.find(function (p) {
          return p === d;
        });
      });

      oldStyleProps.forEach(function (oldProp) {
        (0, _d3Selection.select)(node).select("*").style(adjustedPropName(oldProp), undefined);
      });

      newStyleProps.forEach(function (newProp) {
        if (!hasTransition) {
          (0, _d3Selection.select)(node).select("*").style(adjustedPropName(newProp), cloneProps.style[newProp]);
        } else {
          var _transitionDuration2 = transitionDuration,
              defaultDur = _transitionDuration2.default,
              _transitionDuration2$ = _transitionDuration2[newProp],
              appliedDuration = _transitionDuration2$ === undefined ? defaultDur : _transitionDuration2$;


          (0, _d3Selection.select)(node).select("*").transition(adjustedPropName(newProp)).duration(appliedDuration).style(adjustedPropName(newProp), cloneProps.style[newProp]);
        }
      });

      return false;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var className = this.props.className || "";

      var actualSVG = (this.props.renderMode === "sketchy" || this.props.renderMode && this.props.renderMode.renderMode === "sketchy") && this.state.sketchyFill || (0, _drawing.generateSVG)(this.props, className);

      return _react2.default.createElement(
        "g",
        {
          ref: function ref(node) {
            return _this3.node = node;
          },
          className: className,
          "aria-label": this.props["aria-label"]
        },
        actualSVG
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      return updateSketchy(nextProps, prevState.sketchyHash);
    }
  }]);

  return Mark;
}(_react2.default.Component);

exports.default = Mark;
module.exports = exports['default'];

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.pathStr = pathStr;
exports.circlePath = circlePath;
exports.rectPath = rectPath;
exports.linePath = linePath;
exports.generateSVG = generateSVG;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//All generic line constructors expect a projected coordinates array with x & y coordinates, if there are no y1 & x1 coordinates then it defaults to 0-width
function roundToTenth(number) {
  return Math.round(number * 10) / 10;
}

function pathStr(_ref) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r;

  if (cx !== undefined) {
    return ["M", roundToTenth(cx - r), roundToTenth(cy), "a", r, r, 0, 1, 0, r * 2, 0, "a", r, r, 0, 1, 0, -(r * 2), 0].join(" ") + "Z";
  }
  return ["M", roundToTenth(x), roundToTenth(y), "h", width, "v", height, "h", -width, "v", -height].join(" ") + "Z";
}

function circlePath(cx, cy, r) {
  return pathStr({ cx: cx, cy: cy, r: r });
}

function rectPath(x, y, width, height) {
  return pathStr({ x: x, y: y, width: width, height: height });
}

function linePath(x1, x2, y1, y2) {
  return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "L";
}

function generateSVG(props, className) {
  var markType = props.markType;
  var renderMode = props.renderMode;

  var cloneProps = _extends({}, props);
  delete cloneProps.markType;
  delete cloneProps.renderMode;
  delete cloneProps.resetAfter;
  delete cloneProps.droppable;
  delete cloneProps.nid;
  delete cloneProps.dropFunction;
  delete cloneProps.context;
  delete cloneProps.updateContext;
  delete cloneProps.parameters;
  delete cloneProps.lineDataAccessor;
  delete cloneProps.customAccessors;
  delete cloneProps.interpolate;
  delete cloneProps.forceUpdate;
  delete cloneProps.searchIterations;
  delete cloneProps.simpleInterpolate;
  delete cloneProps.transitionDuration;
  delete cloneProps.tx;
  delete cloneProps.ty;
  delete cloneProps.customTween;
  delete cloneProps.sketchyGenerator;

  //        let transform = cloneProps['transform'];
  if (props.draggable) {
    delete cloneProps.transform;
  }

  cloneProps.className = className;

  var actualSVG = null;

  if (renderMode === "forcePath" && markType === "circle") {
    cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
    markType = "path";
    actualSVG = _react2.default.createElement(markType, cloneProps);
  } else if (renderMode === "forcePath" && markType === "rect") {
    cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
    markType = "path";
    actualSVG = _react2.default.createElement(markType, cloneProps);
  } else {
    if (props.markType === "text" && _typeof(cloneProps.children) !== "object") {
      cloneProps.children = _react2.default.createElement(
        "tspan",
        null,
        cloneProps.children
      );
    }
    actualSVG = _react2.default.createElement(markType, cloneProps);
  }
  return actualSVG;
}

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var styleTransitionWhitelist = exports.styleTransitionWhitelist = ["strokeOpacity", "fillOpacity", "strokeWidth", "fill", "stroke", "opacity", "strokeDasharray"];

var redrawSketchyList = exports.redrawSketchyList = ["fill", "stroke", "cx", "cy", "x", "y", "d", "height", "width", "x1", "x2", "y1", "y2", "rx", "ry", "r", "transform"];

var attributeTransitionWhitelist = exports.attributeTransitionWhitelist = ["transform"].concat(redrawSketchyList, styleTransitionWhitelist);

//TODO find React Everything to everything translater
var reactCSSNameStyleHash = exports.reactCSSNameStyleHash = {
  strokeWidth: "stroke-width",
  fillOpacity: "fill-opacity",
  strokeOpacity: "stroke-opacity",
  strokeDasharray: "stroke-dasharray"
};

var differentD = exports.differentD = function differentD(d, newD) {
  if (!d || !newD) {
    return true;
  }
  var lowerD = d.toLowerCase();
  var lowerNewD = newD.toLowerCase();

  if ((lowerD.match(/m/g) || []).length !== (lowerNewD.match(/m/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/l/g) || []).length !== (lowerNewD.match(/l/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/c/g) || []).length !== (lowerNewD.match(/c/g) || []).length) {
    return true;
  }

  if ((lowerD.match(/a/g) || []).length !== (lowerNewD.match(/a/g) || []).length) {
    return true;
  }

  return false;
};

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var coordinateNames_1 = __webpack_require__(121);
var d3_array_1 = __webpack_require__(3);
var d3_voronoi_1 = __webpack_require__(514);
var semiotic_mark_1 = __webpack_require__(15);
var constructDataObject = function (d, points) {
    if (d === undefined)
        return d;
    return d && d.data ? __assign(__assign({ points: points }, d.data), d) : __assign({ points: points }, d);
};
exports.changeVoronoi = function (voronoiHover, d, customHoverTypes, customHoverBehavior, points) {
    //Until semiotic 2
    var dataObject = constructDataObject(d, points);
    if (customHoverBehavior)
        customHoverBehavior(dataObject);
    if (!d)
        voronoiHover(null);
    else if (customHoverTypes === true) {
        var vorD = Object.assign({}, dataObject);
        vorD.type = vorD.type === "column-hover" ? "column-hover" : "frame-hover";
        voronoiHover(vorD);
    }
    else if (customHoverTypes) {
        var arrayWrappedHoverTypes = Array.isArray(customHoverTypes)
            ? customHoverTypes
            : [customHoverTypes];
        var mappedHoverTypes = arrayWrappedHoverTypes
            .map(function (c) {
            var finalC = typeof c === "function" ? c(dataObject) : c;
            if (!finalC)
                return undefined;
            return Object.assign({}, dataObject, finalC);
        })
            .filter(function (d) { return d; });
        voronoiHover(mappedHoverTypes);
    }
};
exports.clickVoronoi = function (d, customClickBehavior, points) {
    //Until semiotic 2
    var dataObject = constructDataObject(d, points);
    if (customClickBehavior)
        customClickBehavior(dataObject);
};
exports.doubleclickVoronoi = function (d, customDoubleClickBehavior, points) {
    //Until semiotic 2
    var dataObject = constructDataObject(d, points);
    if (customDoubleClickBehavior)
        customDoubleClickBehavior(dataObject);
};
exports.brushStart = function (e, columnName, data, columnData, interaction) {
    if (interaction && interaction.start)
        interaction.start(e, columnName, data, columnData);
};
exports.brushing = function (e, columnName, data, columnData, interaction) {
    if (interaction && interaction.during)
        interaction.during(e, columnName, data, columnData);
};
exports.brushEnd = function (e, columnName, data, columnData, interaction) {
    if (interaction && interaction.end)
        interaction.end(e, columnName, data, columnData);
};
exports.calculateOverlay = function (props) {
    var voronoiPaths = [];
    var xScale = props.xScale, yScale = props.yScale, points = props.points, projectedX = props.projectedX, showLinePoints = props.showLinePoints, size = props.size, overlay = props.overlay, _a = props.interactionOverflow, interactionOverflow = _a === void 0 ? { top: 0, bottom: 0, left: 0, right: 0 } : _a, customClickBehavior = props.customClickBehavior, customDoubleClickBehavior = props.customDoubleClickBehavior, customHoverBehavior = props.customHoverBehavior, hoverAnnotation = props.hoverAnnotation, voronoiHover = props.voronoiHover, margin = props.margin, _b = props.advancedSettings, advancedSettings = _b === void 0 ? {} : _b;
    var whichPoints = {
        top: coordinateNames_1.projectedYTop,
        bottom: coordinateNames_1.projectedYBottom
    };
    var pointerStyle = customClickBehavior || customDoubleClickBehavior
        ? { cursor: "pointer" }
        : {};
    if (points && hoverAnnotation && !overlay) {
        var _c = advancedSettings.voronoiFilter, voronoiFilter_1 = _c === void 0 ? function () { return true; } : _c;
        var voronoiDataset_1 = [];
        var voronoiUniqueHash_1 = {};
        points.filter(function (d) { return voronoiFilter_1(__assign(__assign({}, d), d.data)); }).forEach(function (d) {
            var xValue = Math.floor(xScale(d[projectedX]));
            var yValue = Math.floor(yScale(showLinePoints && d[whichPoints[showLinePoints]] !== undefined
                ? d[whichPoints[showLinePoints]]
                : d[coordinateNames_1.projectedYMiddle] !== undefined
                    ? d[coordinateNames_1.projectedYMiddle]
                    : d[coordinateNames_1.projectedY]));
            if (xValue >= (0 - margin.left) &&
                xValue <= (size[0] + margin.right) &&
                yValue >= (0 - margin.top) &&
                yValue <= (size[1] + margin.bottom) &&
                xValue !== undefined &&
                yValue !== undefined &&
                isNaN(xValue) === false &&
                isNaN(yValue) === false) {
                var pointKey = xValue + "," + yValue;
                if (!voronoiUniqueHash_1[pointKey]) {
                    var voronoiPoint = __assign(__assign({}, d), { coincidentPoints: [d], voronoiX: xValue, voronoiY: yValue });
                    voronoiDataset_1.push(voronoiPoint);
                    voronoiUniqueHash_1[pointKey] = voronoiPoint;
                }
                else
                    voronoiUniqueHash_1[pointKey].coincidentPoints.push(d);
            }
        });
        var voronoiXExtent = d3_array_1.extent(voronoiDataset_1.map(function (d) { return d.voronoiX; }));
        var voronoiYExtent = d3_array_1.extent(voronoiDataset_1.map(function (d) { return d.voronoiY; }));
        var voronoiExtent = [
            [
                Math.min(voronoiXExtent[0] - 5, -interactionOverflow.left),
                Math.min(voronoiYExtent[0] - 5, -interactionOverflow.top)
            ],
            [
                Math.max(voronoiXExtent[1] + 5, size[0] + interactionOverflow.right),
                Math.max(voronoiYExtent[1] + 5, size[1] + interactionOverflow.bottom)
            ]
        ];
        var voronoiDiagram = d3_voronoi_1.voronoi()
            .extent(voronoiExtent)
            .x(function (d) { return d.voronoiX; })
            .y(function (d) { return d.voronoiY; });
        var voronoiData = voronoiDiagram.polygons(voronoiDataset_1);
        voronoiPaths = voronoiData.map(function (d, i) {
            var clipPath = null;
            if (advancedSettings.voronoiClipping) {
                var circleSize = advancedSettings.voronoiClipping === true ? 50 : advancedSettings.voronoiClipping;
                var correspondingD = voronoiDataset_1[i];
                clipPath = React.createElement("clipPath", { id: "voronoi-" + i },
                    React.createElement("circle", { r: circleSize, cx: correspondingD.voronoiX, cy: correspondingD.voronoiY }));
            }
            return (React.createElement("g", { key: "voronoi-" + i },
                React.createElement("path", { onClick: function () {
                        exports.clickVoronoi(voronoiDataset_1[i], customClickBehavior, points);
                    }, onDoubleClick: function () {
                        exports.doubleclickVoronoi(voronoiDataset_1[i], customDoubleClickBehavior, points);
                    }, onMouseEnter: function () {
                        exports.changeVoronoi(voronoiHover, voronoiDataset_1[i], hoverAnnotation, customHoverBehavior, points);
                    }, onMouseLeave: function () {
                        exports.changeVoronoi(voronoiHover, undefined, undefined, customHoverBehavior);
                    }, key: "interactionVoronoi" + i, d: "M" + d.join("L") + "Z", style: __assign({ fillOpacity: 0 }, pointerStyle), clipPath: "url(#voronoi-" + i + ")" }),
                clipPath));
        }, _this);
        return voronoiPaths;
    }
    else if (overlay) {
        var renderedOverlay = overlay.map(function (overlayRegion, i) {
            var overlayData = overlayRegion.overlayData, rest = __rest(overlayRegion, ["overlayData"]);
            var overlayProps = {
                key: "overlay-" + i,
                onMouseEnter: function () {
                    exports.changeVoronoi(voronoiHover, overlayData, props.hoverAnnotation, customHoverBehavior, points);
                },
                onMouseLeave: function () {
                    exports.changeVoronoi(voronoiHover, undefined, undefined, customHoverBehavior);
                },
                onClick: function () {
                    exports.clickVoronoi(overlayData, customClickBehavior, points);
                },
                onDoubleClick: function () {
                    exports.doubleclickVoronoi(overlayData, customDoubleClickBehavior, points);
                },
                style: __assign({ opacity: 0 }, pointerStyle)
            };
            if (React.isValidElement(overlayRegion.renderElement)) {
                return React.cloneElement(overlayRegion.renderElement, overlayProps);
            }
            else {
                return (React.createElement(semiotic_mark_1.Mark, __assign({ forceUpdate: true }, rest, { key: "overlay-" + i }, overlayProps)));
            }
        });
        return renderedOverlay;
    }
};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var frameFunctions_1 = __webpack_require__(33);
var InteractionCanvas = /** @class */ (function (_super) {
    __extends(InteractionCanvas, _super);
    function InteractionCanvas(props) {
        var _this = _super.call(this, props) || this;
        _this.canvasMap = new Map();
        _this.canvasRendering = function () {
            var canvasMap = _this.canvasMap;
            var interactionContext = _this.state.interactionContext;
            var _a = _this.props, voronoiHover = _a.voronoiHover, height = _a.height, width = _a.width, overlayRegions = _a.overlayRegions, margin = _a.margin;
            if (interactionContext === null || !overlayRegions)
                return;
            var boundCanvasEvent = frameFunctions_1.canvasEvent.bind(null, interactionContext, overlayRegions, _this.canvasMap);
            interactionContext.onmousemove = function (e) {
                var overlay = boundCanvasEvent(e);
                if (overlay && overlay.props && overlay.props.children[0]) {
                    overlay.props.children[0].props.onMouseEnter();
                }
                else {
                    voronoiHover(null);
                }
            };
            interactionContext.onclick = function (e) {
                var overlay = boundCanvasEvent(e);
                if (overlay && overlay.props) {
                    overlay.props.children[0].props.onClick();
                }
            };
            interactionContext.ondblclick = function (e) {
                var overlay = boundCanvasEvent(e);
                if (overlay && overlay.props) {
                    overlay.props.children[0].props.onDoubleClick();
                }
            };
            canvasMap.clear();
            var interactionContext2D = interactionContext.getContext("2d");
            interactionContext2D.imageSmoothingEnabled = false;
            interactionContext2D.setTransform(1, 0, 0, 1, margin.left, margin.top);
            interactionContext2D.clearRect(-margin.left, -margin.top, width, height);
            interactionContext2D.lineWidth = 1;
            overlayRegions.forEach(function (overlay, oi) {
                var overlayD = overlay.props.d || overlay.props.children[0].props.d;
                var interactionRGBA = "rgba(" + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + ",255)";
                canvasMap.set(interactionRGBA, oi);
                interactionContext2D.fillStyle = interactionRGBA;
                interactionContext2D.strokeStyle = interactionRGBA;
                var p = new Path2D(overlayD);
                interactionContext2D.stroke(p);
                interactionContext2D.fill(p);
            });
        };
        _this.state = {
            ref: null,
            interactionContext: null
        };
        return _this;
    }
    InteractionCanvas.prototype.componentDidMount = function () {
        this.canvasRendering();
    };
    InteractionCanvas.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (prevProps.width !== this.props.width ||
            prevProps.height !== this.props.height ||
            this.props.overlayRegions !== prevProps.overlayRegions ||
            (!prevState.interactionContext && this.state.interactionContext)) {
            this.canvasRendering();
        }
    };
    InteractionCanvas.prototype.render = function () {
        var _this = this;
        var _a = this.props, width = _a.width, height = _a.height;
        return (React.createElement("canvas", { className: "frame-canvas-interaction", ref: function (canvasContext) {
                if (canvasContext &&
                    _this.state.interactionContext !== canvasContext) {
                    _this.setState({ interactionContext: canvasContext });
                }
            }, style: {
                position: "absolute",
                left: "0px",
                top: "0px",
                imageRendering: "pixelated",
                pointerEvents: "all",
                opacity: 0
            }, width: width, height: height }));
    };
    return InteractionCanvas;
}(React.Component));
exports.default = InteractionCanvas;


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (module) {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };

  /**
  * Determine the coefficient of determination (r^2) of a fit from the observations
  * and predictions.
  *
  * @param {Array<Array<number>>} data - Pairs of observed x-y values
  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
  *
  * @return {number} - The r^2 value, or NaN if one cannot be calculated.
  */
  function determinationCoefficient(data, results) {
    var predictions = [];
    var observations = [];

    data.forEach(function (d, i) {
      if (d[1] !== null) {
        observations.push(d);
        predictions.push(results[i]);
      }
    });

    var sum = observations.reduce(function (a, observation) {
      return a + observation[1];
    }, 0);
    var mean = sum / observations.length;

    var ssyy = observations.reduce(function (a, observation) {
      var difference = observation[1] - mean;
      return a + difference * difference;
    }, 0);

    var sse = observations.reduce(function (accum, observation, index) {
      var prediction = predictions[index];
      var residual = observation[1] - prediction[1];
      return accum + residual * residual;
    }, 0);

    return 1 - sse / ssyy;
  }

  /**
  * Determine the solution of a system of linear equations A * x = b using
  * Gaussian elimination.
  *
  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
  * @param {number} order - How many degrees to solve for
  *
  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
  */
  function gaussianElimination(input, order) {
    var matrix = input;
    var n = input.length - 1;
    var coefficients = [order];

    for (var i = 0; i < n; i++) {
      var maxrow = i;
      for (var j = i + 1; j < n; j++) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
          maxrow = j;
        }
      }

      for (var k = i; k < n + 1; k++) {
        var tmp = matrix[k][i];
        matrix[k][i] = matrix[k][maxrow];
        matrix[k][maxrow] = tmp;
      }

      for (var _j = i + 1; _j < n; _j++) {
        for (var _k = n; _k >= i; _k--) {
          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];
        }
      }
    }

    for (var _j2 = n - 1; _j2 >= 0; _j2--) {
      var total = 0;
      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
        total += matrix[_k2][_j2] * coefficients[_k2];
      }

      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];
    }

    return coefficients;
  }

  /**
  * Round a number to a precision, specificed in number of decimal places
  *
  * @param {number} number - The number to round
  * @param {number} precision - The number of decimal places to round to:
  *                             > 0 means decimals, < 0 means powers of 10
  *
  *
  * @return {numbr} - The number, rounded
  */
  function round(number, precision) {
    var factor = Math.pow(10, precision);
    return Math.round(number * factor) / factor;
  }

  /**
  * The set of all fitting methods
  *
  * @namespace
  */
  var methods = {
    linear: function linear(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = 0;

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          len++;
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0];
          sum[3] += data[n][0] * data[n][1];
          sum[4] += data[n][1] * data[n][1];
        }
      }

      var run = len * sum[2] - sum[0] * sum[0];
      var rise = len * sum[3] - sum[0] * sum[1];
      var gradient = run === 0 ? 0 : round(rise / run, options.precision);
      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [gradient, intercept],
        r2: round(determinationCoefficient(data, points), options.precision),
        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
      };
    },
    exponential: function exponential(data, options) {
      var sum = [0, 0, 0, 0, 0, 0];

      for (var n = 0; n < data.length; n++) {
        if (data[n][1] !== null) {
          sum[0] += data[n][0];
          sum[1] += data[n][1];
          sum[2] += data[n][0] * data[n][0] * data[n][1];
          sum[3] += data[n][1] * Math.log(data[n][1]);
          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);
          sum[5] += data[n][0] * data[n][1];
        }
      }

      var denominator = sum[1] * sum[2] - sum[5] * sum[5];
      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);
      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;
      var coeffA = round(a, options.precision);
      var coeffB = round(b, options.precision);
      var predict = function predict(x) {
        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    logarithmic: function logarithmic(data, options) {
      var sum = [0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += data[n][1] * Math.log(data[n][0]);
          sum[2] += data[n][1];
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);
      var coeffB = round(a, options.precision);
      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    power: function power(data, options) {
      var sum = [0, 0, 0, 0, 0];
      var len = data.length;

      for (var n = 0; n < len; n++) {
        if (data[n][1] !== null) {
          sum[0] += Math.log(data[n][0]);
          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);
          sum[2] += Math.log(data[n][1]);
          sum[3] += Math.pow(Math.log(data[n][0]), 2);
        }
      }

      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));
      var a = (sum[2] - b * sum[0]) / len;
      var coeffA = round(Math.exp(a), options.precision);
      var coeffB = round(b, options.precision);

      var predict = function predict(x) {
        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      return {
        points: points,
        predict: predict,
        equation: [coeffA, coeffB],
        string: 'y = ' + coeffA + 'x^' + coeffB,
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    },
    polynomial: function polynomial(data, options) {
      var lhs = [];
      var rhs = [];
      var a = 0;
      var b = 0;
      var len = data.length;
      var k = options.order + 1;

      for (var i = 0; i < k; i++) {
        for (var l = 0; l < len; l++) {
          if (data[l][1] !== null) {
            a += Math.pow(data[l][0], i) * data[l][1];
          }
        }

        lhs.push(a);
        a = 0;

        var c = [];
        for (var j = 0; j < k; j++) {
          for (var _l = 0; _l < len; _l++) {
            if (data[_l][1] !== null) {
              b += Math.pow(data[_l][0], i + j);
            }
          }
          c.push(b);
          b = 0;
        }
        rhs.push(c);
      }
      rhs.push(lhs);

      var coefficients = gaussianElimination(rhs, k).map(function (v) {
        return round(v, options.precision);
      });

      var predict = function predict(x) {
        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
          return sum + coeff * Math.pow(x, power);
        }, 0), options.precision)];
      };

      var points = data.map(function (point) {
        return predict(point[0]);
      });

      var string = 'y = ';
      for (var _i = coefficients.length - 1; _i >= 0; _i--) {
        if (_i > 1) {
          string += coefficients[_i] + 'x^' + _i + ' + ';
        } else if (_i === 1) {
          string += coefficients[_i] + 'x + ';
        } else {
          string += coefficients[_i];
        }
      }

      return {
        string: string,
        points: points,
        predict: predict,
        equation: [].concat(_toConsumableArray(coefficients)).reverse(),
        r2: round(determinationCoefficient(data, points), options.precision)
      };
    }
  };

  function createWrapper() {
    var reduce = function reduce(accumulator, name) {
      return _extends({
        _round: round
      }, accumulator, _defineProperty({}, name, function (data, supplied) {
        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
      }));
    };

    return Object.keys(methods).reduce(reduce, {});
  }

  module.exports = createWrapper();
});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var frameFunctions_1 = __webpack_require__(33);
exports.filterDefs = function (_a) {
    var matte = _a.matte, key = _a.key, additionalDefs = _a.additionalDefs;
    return (React.createElement("defs", null,
        React.createElement("filter", { id: "paintyFilterHeavy" },
            React.createElement("feGaussianBlur", { id: "gaussblurrer", in: "SourceGraphic", stdDeviation: 4, colorInterpolationFilters: "sRGB", result: "blur" }),
            React.createElement("feColorMatrix", { in: "blur", mode: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7", result: "gooey" })),
        React.createElement("filter", { id: "paintyFilterLight" },
            React.createElement("feGaussianBlur", { id: "gaussblurrer", in: "SourceGraphic", stdDeviation: 2, colorInterpolationFilters: "sRGB", result: "blur" }),
            React.createElement("feColorMatrix", { in: "blur", mode: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7", result: "gooey" })),
        React.createElement("clipPath", { id: "matte-clip-" + key }, matte),
        additionalDefs));
};
exports.generateFinalDefs = function (_a) {
    var matte = _a.matte, size = _a.size, margin = _a.margin, frameKey = _a.frameKey, additionalDefs = _a.additionalDefs, name = _a.name;
    var marginGraphic;
    if (typeof matte === "function") {
        marginGraphic = matte({ size: size, margin: margin });
    }
    else if (React.isValidElement(matte)) {
        marginGraphic = matte;
    }
    else if (matte === true) {
        marginGraphic = (React.createElement("path", { fill: "white", transform: "translate(" + -margin.left + "," + -margin.top + ")", d: frameFunctions_1.drawMarginPath({
                margin: margin,
                size: size,
                inset: 0
            }), className: name + "-matte" }));
    }
    var finalFilterDefs = exports.filterDefs({
        matte: marginGraphic,
        key: matte && (frameKey || name),
        additionalDefs: additionalDefs
    });
    return { defs: finalFilterDefs, matte: marginGraphic };
};


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
var Annotation_1 = __importDefault(__webpack_require__(49));
var AnnotationCalloutRect_1 = __importDefault(__webpack_require__(172));
var AnnotationXYThreshold_1 = __importDefault(__webpack_require__(173));
var d3_shape_1 = __webpack_require__(18);
var d3_hierarchy_1 = __webpack_require__(98);
var d3_array_1 = __webpack_require__(3);
var baseRules_1 = __webpack_require__(51);
var SpanOrDiv_1 = __importDefault(__webpack_require__(41));
var multiAccessorUtils_1 = __webpack_require__(69);
var general_1 = __webpack_require__(85);
var pointsAlong = function (along) { return function (_a) {
    var d = _a.d, lines = _a.lines, points = _a.points, xScale = _a.xScale, yScale = _a.yScale, pointStyle = _a.pointStyle;
    var alongScale = along === "x" ? xScale : yScale;
    along = along === "yTop" && d.yMiddle ? "yMiddle" : along;
    if (d && d[along]) {
        var _b = d.threshold, threshold = _b === void 0 ? 1 : _b, _c = d.r, r_1 = _c === void 0 ? function () { return 4; } : _c, _d = d.styleFn, styleFn_1 = _d === void 0 ? pointStyle : _d;
        var foundPoints_1 = [];
        var halfThreshold_1 = threshold / 2;
        if (lines && lines.length > 0) {
            lines.forEach(function (linedata) {
                var linePoints = linedata.data.filter(function (p) {
                    var pAlong = alongScale(p[along]);
                    var dAlong = alongScale(d[along]);
                    return (pAlong <= dAlong + halfThreshold_1 && pAlong >= dAlong - halfThreshold_1);
                });
                foundPoints_1.push.apply(foundPoints_1, __spread(linePoints));
            });
        }
        if (points && points.length > 0) {
            var pointPoints = points.filter(function (p) {
                var pAlong = alongScale(p[along]);
                var dAlong = alongScale(d[along]);
                return (pAlong <= dAlong + halfThreshold_1 && pAlong >= dAlong - halfThreshold_1);
            });
            foundPoints_1.push.apply(foundPoints_1, __spread(pointPoints));
        }
        return foundPoints_1.map(function (p, i) { return (React.createElement("circle", { key: "found-circle-" + i, r: r_1(p, i), style: styleFn_1(p, i), cx: xScale(p.xMiddle || p.x), cy: yScale(p.yMiddle || p.yTop) })); });
    }
    return null;
}; };
exports.svgHorizontalPointsAnnotation = pointsAlong("yTop");
exports.svgVerticalPointsAnnotation = pointsAlong("x");
exports.svgHighlight = function (_a) {
    var d = _a.d, i = _a.i, _b = _a.points, points = _b === void 0 ? { data: [] } : _b, _c = _a.lines, lines = _c === void 0 ? { data: [], type: {} } : _c, _d = _a.summaries, summaries = _d === void 0 ? { data: [] } : _d, idAccessor = _a.idAccessor, xScale = _a.xScale, yScale = _a.yScale, xyFrameRender = _a.xyFrameRender, defined = _a.defined;
    var dID;
    var baseID = idAccessor(__assign(__assign({}, d), d.data), i);
    if (baseID !== undefined) {
        dID = baseID;
    }
    else if (d.parentLine && idAccessor(d.parentLine, i) !== undefined) {
        dID = idAccessor(d.parentLine, i);
    }
    else if (d.parentSummary && idAccessor(d.parentSummary, i) !== undefined) {
        dID = idAccessor(d.parentSummary, i);
    }
    var foundPoints = points.data
        .filter(function (p, q) { return idAccessor(__assign(__assign({}, p), p.data), q) === dID; })
        .map(function (p, q) {
        var baseStyle = xyFrameRender.points.styleFn(__assign(__assign({}, p), p.data));
        var highlightStyle = typeof d.style === "function"
            ? d.style(__assign(__assign({}, p), p.data), q)
            : d.style || {};
        return (React.createElement("circle", { key: "highlight-point-" + q, cx: xScale(p.x), cy: yScale(p.y), r: 5, fill: "none", stroke: "black", strokeWidth: 2, style: __assign(__assign({}, baseStyle), highlightStyle), className: "highlight-annotation " + ((d.class &&
                typeof d.class === "function" &&
                d.class(__assign(__assign({}, p), p.data), q)) ||
                (d.class && d.class) ||
                "") }));
    });
    var lineGenerator = d3_shape_1.area()
        .x(function (p) { return xScale(p.x); })
        .y0(function (p) { return yScale(p.yBottom); })
        .y1(function (p) { return yScale(p.yTop); });
    var interpolatorSetting = lines.type.interpolator || lines.type.curve;
    var actualInterpolator = typeof interpolatorSetting === "string"
        ? general_1.curveHash[interpolatorSetting]
        : interpolatorSetting;
    if (actualInterpolator) {
        lineGenerator.curve(actualInterpolator);
    }
    if (defined) {
        lineGenerator.defined(function (p, q) { return defined(p.data, q); });
    }
    var foundLines = lines.data
        .filter(function (p, q) { return idAccessor(p, q) === dID; })
        .map(function (p, q) {
        var baseStyle = xyFrameRender.lines.styleFn(p, q);
        var highlightStyle = typeof d.style === "function" ? d.style(p, q) : d.style || {};
        return (React.createElement("path", { className: "highlight-annotation " + ((d.class &&
                typeof d.class === "function" &&
                d.class(p, q)) ||
                (d.class && d.class) ||
                ""), key: "highlight-summary-" + q, d: lineGenerator(p.data), fill: "none", stroke: "black", strokeWidth: 1, style: __assign(__assign({}, baseStyle), highlightStyle) }));
    });
    var foundSummaries = summaries.data
        .filter(function (p, q) { return idAccessor(p, q) === dID; })
        .map(function (p, q) {
        var baseStyle = xyFrameRender.summaries.styleFn(p, q);
        var highlightStyle = typeof d.style === "function" ? d.style(p, q) : d.style || {};
        return (React.createElement("path", { className: "highlight-annotation " + ((d.class &&
                typeof d.class === "function" &&
                d.class(p, q)) ||
                (d.class && d.class) ||
                ""), key: "highlight-summary-" + q, d: "M" + p.coordinates.join("L"), fill: "none", stroke: "black", strokeWidth: 1, style: __assign(__assign({}, baseStyle), highlightStyle) }));
    });
    return __spread(foundSummaries, foundLines, foundPoints);
};
exports.svgXYAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, i = _a.i, d = _a.d;
    var inlineStyle;
    if (d.color)
        inlineStyle = { fill: d.color };
    var laLine = (React.createElement(semiotic_mark_1.Mark, { className: "annotation " + d.type + " " + (d.className || "") + " ", key: "annotationpoint" + i, markType: "circle", cx: screenCoordinates[0], cy: screenCoordinates[1], forceUpdate: true, style: inlineStyle, fill: "none", stroke: "black", r: 5 }));
    var laLabel;
    if (d.type === "xy") {
        laLabel = (React.createElement(semiotic_mark_1.Mark, { markType: "text", key: d.label + "annotationtext" + i, forceUpdate: true, x: screenCoordinates[0], y: 10 + screenCoordinates[1], className: "annotation annotation-xy-label " + (d.className || "") + " " }, d.label));
    }
    return [laLine, laLabel];
};
exports.basicReactAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, i = _a.i;
    var noteData = Object.assign({
        dx: 0,
        dy: 0,
        note: { label: d.label, orientation: d.orientation, align: d.align },
        connector: { end: "arrow" }
    }, d, {
        type: d.type,
        screenCoordinates: screenCoordinates,
        i: i
    });
    noteData.x = noteData.fixedX ? noteData.fixedX : screenCoordinates[0];
    noteData.y = noteData.fixedY ? noteData.fixedY : screenCoordinates[1];
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgXAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, i = _a.i, adjustedSize = _a.adjustedSize;
    var noteData = Object.assign({
        dx: 50,
        dy: 20,
        y: 0,
        note: { label: d.label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationXYThreshold_1.default,
        x: screenCoordinates[0],
        subject: {
            x: screenCoordinates[0],
            y1: 0,
            y2: adjustedSize[1]
        },
        i: i
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgYAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, i = _a.i, adjustedSize = _a.adjustedSize, adjustedPosition = _a.adjustedPosition;
    var xPosition = i * 25;
    var noteData = Object.assign({
        dx: 50,
        dy: -20,
        x: xPosition,
        note: { label: d.label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationXYThreshold_1.default,
        y: screenCoordinates[1],
        subject: {
            y: screenCoordinates[1],
            x1: 0,
            x2: adjustedSize[0] + adjustedPosition[0]
        },
        i: i
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgBoundsAnnotation = function (_a) {
    var d = _a.d, i = _a.i, adjustedSize = _a.adjustedSize, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor, xScale = _a.xScale, yScale = _a.yScale;
    var startXValue = multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d.bounds[0]);
    var startYValue = multiAccessorUtils_1.findFirstAccessorValue(yAccessor, d.bounds[0]);
    var endXValue = multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d.bounds[1]);
    var endYValue = multiAccessorUtils_1.findFirstAccessorValue(yAccessor, d.bounds[1]);
    var x0Position = startXValue ? xScale(startXValue) : 0;
    var y0Position = startYValue ? yScale(startYValue) : adjustedSize[1];
    var x1Position = endXValue ? xScale(endXValue) : adjustedSize[0];
    var y1Position = endYValue ? yScale(endYValue) : 0;
    var noteData = Object.assign({
        dx: 250,
        dy: -20,
        note: { label: d.label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationCalloutRect_1.default,
        x: Math.min(x0Position, x1Position),
        y: Math.min(y0Position, y1Position),
        subject: {
            width: Math.abs(x1Position - x0Position),
            height: Math.abs(y0Position - y1Position)
        },
        i: i
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgLineAnnotation = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates;
    var lineGenerator = d3_shape_1.line()
        .x(function (p) { return p[0]; })
        .y(function (p) { return p[1]; });
    var lineD = lineGenerator(screenCoordinates);
    var laLine = (React.createElement(semiotic_mark_1.Mark, { key: d.label + "annotationline" + i, markType: "path", d: lineD, className: "annotation annotation-line " + (d.className || "") + " " }));
    var laLabel = (React.createElement(semiotic_mark_1.Mark, { markType: "text", key: d.label + "annotationlinetext" + i, x: (screenCoordinates[0][0] + screenCoordinates[1][0]) / 2, y: (screenCoordinates[0][1] + screenCoordinates[1][1]) / 2, className: "annotation annotation-line-label " + (d.className || "") + " " }, d.label));
    return [laLine, laLabel];
};
exports.svgAreaAnnotation = function (_a) {
    var d = _a.d, i = _a.i, xScale = _a.xScale, xAccessor = _a.xAccessor, yScale = _a.yScale, yAccessor = _a.yAccessor, annotationLayer = _a.annotationLayer;
    var mappedCoordinates = "M" + d.coordinates
        .map(function (p) { return [
        xScale(multiAccessorUtils_1.findFirstAccessorValue(xAccessor, p)),
        yScale(multiAccessorUtils_1.findFirstAccessorValue(yAccessor, p))
    ]; })
        .join("L") + "Z";
    var xBounds = d3_array_1.extent(d.coordinates.map(function (p) { return xScale(multiAccessorUtils_1.findFirstAccessorValue(xAccessor, p)); }));
    var yBounds = d3_array_1.extent(d.coordinates.map(function (p) { return yScale(multiAccessorUtils_1.findFirstAccessorValue(yAccessor, p)); }));
    var xCenter = (xBounds[0] + xBounds[1]) / 2;
    var yCenter = (yBounds[0] + yBounds[1]) / 2;
    var laLine = (React.createElement(semiotic_mark_1.Mark, { key: d.label + "-annotation-area-" + i, markType: "path", d: mappedCoordinates, className: "annotation annotation-area " + (d.className || "") + " " }));
    var laLabel = (React.createElement(semiotic_mark_1.Mark, { markType: "text", key: d.label + "-annotationtext-" + i, forceUpdate: true, x: xCenter, y: yCenter, transform: "translate(" + annotationLayer.position + ")", className: "annotation annotation-area-label " + (d.className || "") + " ", style: { textAnchor: "middle" } }, d.label));
    return [laLine, laLabel];
};
exports.htmlTooltipAnnotation = function (_a) {
    //To string because React gives a DOM error if it gets a date
    var content = _a.content, screenCoordinates = _a.screenCoordinates, i = _a.i, d = _a.d, useSpans = _a.useSpans;
    return (React.createElement(SpanOrDiv_1.default, { span: useSpans, key: "xylabel-" + i, className: "annotation annotation-xy-label " + (d.className || "") + " ", style: {
            position: "absolute",
            top: screenCoordinates[1] + "px",
            left: screenCoordinates[0] + "px"
        } }, content));
};
exports.svgRectEncloseAnnotation = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates;
    var bboxNodes = screenCoordinates.map(function (p) {
        return {
            x0: p.x0 = p[0],
            x1: p.x1 = p[0],
            y0: p.y0 = p[1],
            y1: p.y1 = p[1]
        };
    });
    return baseRules_1.rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};
exports.svgEncloseAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, i = _a.i;
    var circle = d3_hierarchy_1.packEnclose(screenCoordinates.map(function (p) { return ({ x: p[0], y: p[1], r: 2 }); }));
    return baseRules_1.circleEnclosure({ d: d, circle: circle, i: i });
};
exports.svgHullEncloseAnnotation = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, i = _a.i;
    return baseRules_1.hullEnclosure({ points: screenCoordinates, d: d, i: i });
};


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _rect = _interopRequireDefault(__webpack_require__(278));

var _Subject2 = _interopRequireDefault(__webpack_require__(50));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectRect =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectRect, _Subject);

  function SubjectRect() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectRect);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectRect)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectRect");

    return _this;
  }

  _createClass(SubjectRect, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var _ref$width = _ref.width,
          width = _ref$width === void 0 ? 100 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 100 : _ref$height,
          editMode = _ref.editMode;
      var components = (0, _rect.default)({
        width: width,
        height: height,
        editMode: editMode
      });
      components.handleKeys = {
        width: width,
        height: height
      };

      components.handleFunction = function (h, data) {
        return _defineProperty({}, h.key, h.key === "width" ? width + data.oDeltaX : height + data.oDeltaY);
      };

      return components;
    }
  }]);

  return SubjectRect;
}(_Subject2.default);

exports.default = SubjectRect;
SubjectRect.propTypes = {
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  editMode: _propTypes.default.bool
};

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

exports.default = function (_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === undefined ? 100 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? 100 : _ref$height,
      editMode = _ref.editMode;

  var handles = [];

  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
  var rect = (0, _Builder.lineBuilder)({ data: data, className: "subject" });

  if (editMode) {
    handles = [{ x: width, y: height / 2, key: "width" }, { x: width / 2, y: height, key: "height" }];
  }
  rect.attrs["fill-opacity"] = 0.1;
  return { components: [rect], handles: handles };
};

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _threshold = _interopRequireDefault(__webpack_require__(280));

var _Subject2 = _interopRequireDefault(__webpack_require__(50));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectThreshold =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectThreshold, _Subject);

  function SubjectThreshold() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectThreshold);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectThreshold)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectThreshold");

    return _this;
  }

  _createClass(SubjectThreshold, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var x1 = _ref.x1,
          x2 = _ref.x2,
          y1 = _ref.y1,
          y2 = _ref.y2,
          x = _ref.x,
          y = _ref.y,
          editMode = _ref.editMode;
      return (0, _threshold.default)({
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        x: x,
        y: y,
        editMode: editMode
      });
    }
  }]);

  return SubjectThreshold;
}(_Subject2.default);

exports.default = SubjectThreshold;
SubjectThreshold.propTypes = {
  x: _propTypes.default.number,
  x1: _propTypes.default.number,
  x2: _propTypes.default.number,
  y: _propTypes.default.number,
  y1: _propTypes.default.number,
  y2: _propTypes.default.number,
  editMode: _propTypes.default.bool
};

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

exports.default = function (_ref) {
  var x1 = _ref.x1,
      x2 = _ref.x2,
      y1 = _ref.y1,
      y2 = _ref.y2,
      x = _ref.x,
      y = _ref.y;

  x1 = (x1 !== undefined ? x1 : x) - x;
  x2 = (x2 !== undefined ? x2 : x) - x;
  y1 = (y1 !== undefined ? y1 : y) - y;
  y2 = (y2 !== undefined ? y2 : y) - y;

  var data = [[x1, y1], [x2, y2]];
  return { components: [(0, _Builder.lineBuilder)({ data: data, className: "subject" })] };
};

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _circle = _interopRequireDefault(__webpack_require__(282));

var _Subject2 = _interopRequireDefault(__webpack_require__(50));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectCircle =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectCircle, _Subject);

  function SubjectCircle() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectCircle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectCircle)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectCircle");

    return _this;
  }

  _createClass(SubjectCircle, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 20 : _ref$radius,
          innerRadius = _ref.innerRadius,
          outerRadius = _ref.outerRadius,
          radiusPadding = _ref.radiusPadding,
          editMode = _ref.editMode;
      var components = (0, _circle.default)({
        radius: radius,
        radiusPadding: radiusPadding,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        editMode: editMode
      });
      components.handleKeys = {
        radius: radius,
        innerRadius: innerRadius,
        outerRadius: outerRadius
      };

      components.handleFunction = function (h, data) {
        return _defineProperty({}, h.key, components.handleKeys[h.key] + data.oDeltaX * Math.sqrt(2));
      };

      return components;
    }
  }]);

  return SubjectCircle;
}(_Subject2.default);

exports.default = SubjectCircle;
SubjectCircle.propTypes = {
  radius: _propTypes.default.number,
  innerRadius: _propTypes.default.number,
  outerRadius: _propTypes.default.number,
  radiusPadding: _propTypes.default.number,
  editMode: _propTypes.default.bool
};

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleHandles = undefined;

var _Builder = __webpack_require__(21);

var circleHandles = exports.circleHandles = function circleHandles(_ref) {
  var _ref$cx = _ref.cx,
      cx = _ref$cx === undefined ? 0 : _ref$cx,
      _ref$cy = _ref.cy,
      cy = _ref$cy === undefined ? 0 : _ref$cy,
      r1 = _ref.r1,
      r2 = _ref.r2,
      padding = _ref.padding;

  var h = { move: { x: cx, y: cy } };

  if (r1 !== undefined) {
    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
  }

  if (r2 !== undefined) {
    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
  }

  if (padding !== undefined) {
    h.padding = { x: cx + r1 + padding, y: cy };
  }

  return h;
};

exports.default = function (_ref2) {
  var radius = _ref2.radius,
      radiusPadding = _ref2.radiusPadding,
      outerRadius = _ref2.outerRadius,
      innerRadius = _ref2.innerRadius,
      editMode = _ref2.editMode;

  var handles = [];
  var c = (0, _Builder.arcBuilder)({
    data: { radius: radius, outerRadius: outerRadius, innerRadius: innerRadius },
    className: "subject"
  });

  if (editMode) {
    var h = circleHandles({
      r1: c.data.outerRadius || c.data.radius,
      r2: c.data.innerRadius,
      padding: radiusPadding
    });

    var cHandles = [{
      x: h.r1.x,
      y: h.r1.y,
      key: c.data.outerRadius ? "outerRadius" : "radius"
    }];

    if (innerRadius) {
      cHandles.push({ x: h.r2.x, y: h.r2.y, key: "innerRadius" });
    }
    handles = cHandles;
  }

  c.attrs["fill-opacity"] = 0;

  return { components: [c], handles: handles };
};

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCalloutCustom;

var _SubjectCustom = _interopRequireDefault(__webpack_require__(284));

var _ConnectorElbow = _interopRequireDefault(__webpack_require__(67));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCalloutCustom(props) {
  var className = (0, _classnames.default)("callout custom", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorElbow.default, {
    lineType: "horizontal"
  }, _SubjectCustom.default);
}

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Subject2 = _interopRequireDefault(__webpack_require__(50));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

var _Handle = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SubjectCustom =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectCustom, _Subject);

  function SubjectCustom() {
    _classCallCheck(this, SubjectCustom);

    return _possibleConstructorReturn(this, _getPrototypeOf(SubjectCustom).apply(this, arguments));
  }

  _createClass(SubjectCustom, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$custom = _this$props.custom,
          custom = _this$props$custom === void 0 ? "M0,0" : _this$props$custom,
          editMode = _this$props.editMode,
          transform = _this$props.transform;
      var handles;

      if (editMode) {
        handles = _react.default.createElement(_Handle.default, {
          handleStart: this.props.dragStart,
          handleStop: this.props.dragEnd,
          handleDrag: this.props.dragSubject
        });
      }

      return _react.default.createElement("g", {
        className: "annotation-subject"
      }, _react.default.createElement("g", {
        transform: transform
      }, typeof custom === "string" ? _react.default.createElement("path", {
        d: custom,
        pointerEvents: "none"
      }) : _react.default.createElement("g", {
        pointerEvents: "none"
      }, custom)), handles);
    }
  }]);

  return SubjectCustom;
}(_Subject2.default);

exports.default = SubjectCustom;
SubjectCustom.propTypes = {
  editMode: _propTypes.default.bool
};

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var Edge     = __webpack_require__(286);
var martinez = __webpack_require__(287);
var utils    = __webpack_require__(296);


var isArray     = utils.isArray;
var equals      = utils.equals;
var orientRings = utils.orientRings;


/**
 * Offset builder
 *
 * @param {Array.<Object>=} vertices
 * @param {Number=}        arcSegments
 * @constructor
 */
function Offset(vertices, arcSegments) {

  /**
   * @type {Array.<Object>}
   */
  this.vertices = null;

  /**
   * @type {Array.<Edge>}
   */
  this.edges = null;

  /**
   * @type {Boolean}
   */
  this._closed = false;


  /**
   * @type {Number}
   */
  this._distance = 0;

  if (vertices) {
    this.data(vertices);
  }

  /**
   * Segments in edge bounding arches
   * @type {Number}
   */
  this._arcSegments = arcSegments !== undefined ? arcSegments : 5;
}

/**
 * Change data set
 * @param  {Array.<Array>} vertices
 * @return {Offset}
 */
Offset.prototype.data = function(vertices) {
  this._edges = [];
  if (!isArray (vertices)) {
    throw new Error('Offset requires at least one coodinate to work with');
  }

  if (isArray(vertices) && typeof vertices[0] === 'number') {
    this.vertices = vertices;
  } else {
    this.vertices = orientRings(vertices);
    this._processContour(this.vertices, this._edges);
  }

  return this;
};


/**
 * Recursively process contour to create normals
 * @param  {*} contour
 * @param  {Array} edges
 */
Offset.prototype._processContour = function(contour, edges) {
  var i, len;
  if (isArray(contour[0]) && typeof contour[0][0] === 'number') {
    len = contour.length;
    if (equals(contour[0], contour[len - 1])) {
      len -= 1; // otherwise we get division by zero in normals
    }
    for (i = 0; i < len; i++) {
      edges.push(new Edge(contour[i], contour[(i + 1) % len]));
    }
  } else {
    for (i = 0, len = contour.length; i < len; i++) {
      edges.push([]);
      this._processContour(contour[i], edges[edges.length - 1]);
    }
  }
};


/**
 * @param  {Number} arcSegments
 * @return {Offset}
 */
Offset.prototype.arcSegments = function(arcSegments) {
  this._arcSegments = arcSegments;
  return this;
};


/**
 * Validates if the first and last points repeat
 * TODO: check CCW
 *
 * @param  {Array.<Object>} vertices
 */
Offset.prototype.validate = function(vertices) {
  var len = vertices.length;
  if (typeof vertices[0] === 'number') return [vertices];
  if (vertices[0][0] === vertices[len - 1][0] &&
    vertices[0][1] === vertices[len - 1][1]) {
    if (len > 1) {
      vertices = vertices.slice(0, len - 1);
      this._closed = true;
    }
  }
  return vertices;
};


/**
 * Creates arch between two edges
 *
 * @param  {Array.<Object>} vertices
 * @param  {Object}         center
 * @param  {Number}         radius
 * @param  {Object}         startVertex
 * @param  {Object}         endVertex
 * @param  {Number}         segments
 * @param  {Boolean}        outwards
 */
Offset.prototype.createArc = function(vertices, center, radius, startVertex,
    endVertex, segments, outwards) {

  var PI2 = Math.PI * 2,
      startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]),
      endAngle   = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);

  // odd number please
  if (segments % 2 === 0) {
    segments -= 1;
  }

  if (startAngle < 0) {
    startAngle += PI2;
  }

  if (endAngle < 0) {
    endAngle += PI2;
  }

  var angle = ((startAngle > endAngle) ?
               (startAngle - endAngle) :
               (startAngle + PI2 - endAngle)),
      segmentAngle = ((outwards) ? -angle : PI2 - angle) / segments;

  vertices.push(startVertex);
  for (var i = 1; i < segments; ++i) {
    angle = startAngle + segmentAngle * i;
    vertices.push([
      center[0] + Math.cos(angle) * radius,
      center[1] + Math.sin(angle) * radius
    ]);
  }
  vertices.push(endVertex);
  return vertices;
};


/**
 * @param  {Number}  dist
 * @param  {String=} units
 * @return {Offset}
 */
Offset.prototype.distance = function(dist, units) {
  this._distance = dist || 0;
  return this;
};


/**
 * @static
 * @param  {Number}  degrees
 * @param  {String=} units
 * @return {Number}
 */
Offset.degreesToUnits = function(degrees, units) {
  switch (units) {
    case 'miles':
      degrees = degrees / 69.047;
    break;
    case 'feet':
      degrees = degrees / 364568.0;
      break;
    case 'kilometers':
      degrees = degrees / 111.12;
      break;
    case 'meters':
    case 'metres':
      degrees = degrees / 111120.0;
      break;
    case 'degrees':
    case 'pixels':
    default:
      break;
  }
  return degrees;
};


/**
 * @param  {Array.<Object>} vertices
 * @return {Array.<Object>}
 */
Offset.prototype.ensureLastPoint = function(vertices) {
  if (!equals(vertices[0], vertices[vertices.length - 1])) {
    vertices.push([
      vertices[0][0],
      vertices[0][1]
    ]);
  }
  return vertices;
};


/**
 * Decides by the sign if it's a padding or a margin
 *
 * @param  {Number} dist
 * @return {Array.<Object>}
 */
Offset.prototype.offset = function(dist) {
  this.distance(dist);
  return this._distance === 0 ? this.vertices :
      (this._distance > 0 ? this.margin(this._distance) :
        this.padding(-this._distance));
};


/**
 * @param  {Array.<Array.<Number>>} vertices
 * @param  {Array.<Number>}         pt1
 * @param  {Array.<Number>}         pt2
 * @param  {Number}                 dist
 * @return {Array.<Array.<Number>>}
 */
Offset.prototype._offsetSegment = function(v1, v2, e1, dist) {
  var vertices = [];
  var offsets = [
    e1.offset(e1._inNormal[0] * dist, e1._inNormal[1] * dist),
    e1.inverseOffset(e1._outNormal[0] * dist, e1._outNormal[1] * dist)
  ];

  for (var i = 0, len = 2; i < len; i++) {
    var thisEdge = offsets[i],
        prevEdge = offsets[(i + len - 1) % len];
    this.createArc(
              vertices,
              i === 0 ? v1 : v2, // edges[i].current, // p1 or p2
              dist,
              prevEdge.next,
              thisEdge.current,
              this._arcSegments,
              true
            );
  }

  return vertices;
};


/**
 * @param  {Number} dist
 * @return {Array.<Number>}
 */
Offset.prototype.margin = function(dist) {
  this.distance(dist);

  if (typeof this.vertices[0] === 'number') { // point
    return this.offsetPoint(this._distance);
  }

  if (dist === 0) return this.vertices;

  var union = this.offsetLines(this._distance);
  //return union;
  union = martinez.union(this.vertices, union);
  return orientRings(union);
};


/**
 * @param  {Number} dist
 * @return {Array.<Number>}
 */
Offset.prototype.padding = function(dist) {
  this.distance(dist);

  if (this._distance === 0) return this.ensureLastPoint(this.vertices);
  if (this.vertices.length === 2 && typeof this.vertices[0] === 'number') {
    return this.vertices;
  }

  var union = this.offsetLines(this._distance);
  var diff = martinez.diff(this.vertices, union);
  return orientRings(diff);
};


/**
 * Creates margin polygon
 * @param  {Number} dist
 * @return {Array.<Object>}
 */
Offset.prototype.offsetLine = function(dist) {
  if (dist === 0) return this.vertices;
  return orientRings(this.offsetLines(dist));
};


/**
 * Just offsets lines, no fill
 * @param  {Number} dist
 * @return {Array.<Array.<Array.<Number>>>}
 */
Offset.prototype.offsetLines = function(dist) {
  if (dist < 0) throw new Error('Cannot apply negative margin to the line');
  var union;
  this.distance(dist);
  if (isArray(this.vertices[0]) && typeof this.vertices[0][0] !== 'number') {
    for (var i = 0, len = this._edges.length; i < len; i++) {
      union = (i === 0) ?
        this.offsetContour(this.vertices[i], this._edges[i]):
        martinez.union(union, this.offsetContour(this.vertices[i], this._edges[i]));
    }
  } else {
    union = (this.vertices.length === 1) ?
      this.offsetPoint() :
      this.offsetContour(this.vertices, this._edges);
  }

  return union;
};


/**
 * @param  {Array.<Array.<Number>>|Array.<Array.<...>>} curve
 * @param  {Array.<Edge>|Array.<Array.<...>>} edges
 * @return {Polygon}
 */
Offset.prototype.offsetContour = function(curve, edges) {
  var union, i, len;
  if (isArray(curve[0]) && typeof curve[0][0] === 'number') {
    // we have 1 less edge than vertices
    for (i = 0, len = curve.length - 1; i < len; i++) {
      var segment = this.ensureLastPoint(
        this._offsetSegment(curve[i], curve[i + 1], edges[i], this._distance)
      );
      union = (i === 0) ?
                [this.ensureLastPoint(segment)] :
                martinez.union(union, this.ensureLastPoint(segment));
    }
  } else {
    for (i = 0, len = edges.length; i < len; i++) {
      union = (i === 0) ?
        this.offsetContour(curve[i], edges[i]) :
        martinez.union(union, this.offsetContour(curve[i], edges[i]));
    }
  }
  return union;
};


/**
 * @param  {Number} distance
 * @return {Array.<Array.<Number>}
 */
Offset.prototype.offsetPoint = function(distance) {
  this.distance(distance);
  var vertices = this._arcSegments * 2;
  var points   = [];
  var center   = this.vertices;
  var radius   = this._distance;
  var angle    = 0;

  if (vertices % 2 === 0) vertices++;

  for (var i = 0; i < vertices; i++) {
    angle += (2 * Math.PI / vertices); // counter-clockwise
    points.push([
      center[0] + (radius * Math.cos(angle)),
      center[1] + (radius * Math.sin(angle))
    ]);
  }

  return orientRings([this.ensureLastPoint(points)]);
};


Offset.orientRings = orientRings;

module.exports = Offset;


/***/ }),
/* 286 */
/***/ (function(module, exports) {

/**
 * Offset edge of the polygon
 *
 * @param  {Object} current
 * @param  {Object} next
 * @constructor
 */
function Edge(current, next) {

  /**
   * @type {Object}
   */
  this.current = current;

  /**
   * @type {Object}
   */
  this.next = next;

  /**
   * @type {Object}
   */
  this._inNormal  = this.inwardsNormal();

  /**
   * @type {Object}
   */
  this._outNormal = this.outwardsNormal();
}

/**
 * Creates outwards normal
 * @return {Object}
 */
Edge.prototype.outwardsNormal = function() {
  var inwards = this.inwardsNormal();
  return [
    -inwards[0],
    -inwards[1]
  ];
};

/**
 * Creates inwards normal
 * @return {Object}
 */
Edge.prototype.inwardsNormal = function() {
  var dx = this.next[0] - this.current[0],
      dy = this.next[1] - this.current[1],
      edgeLength = Math.sqrt(dx * dx + dy * dy);

  if (edgeLength === 0) throw new Error('Vertices overlap');

  return [
    -dy / edgeLength,
     dx / edgeLength
  ];
};

/**
 * Offsets the edge by dx, dy
 * @param  {Number} dx
 * @param  {Number} dy
 * @return {Edge}
 */
Edge.prototype.offset = function(dx, dy) {
  return Edge.offsetEdge(this.current, this.next, dx, dy);
};


/**
 * @param  {Number} dx
 * @param  {Number} dy
 * @return {Edge}
 */
Edge.prototype.inverseOffset = function(dx, dy) {
  return Edge.offsetEdge(this.next, this.current, dx, dy);
};


/**
 * @static
 * @param  {Array.<Number>} current
 * @param  {Array.<Number>} next
 * @param  {Number}         dx
 * @param  {Number}         dy
 * @return {Edge}
 */
Edge.offsetEdge = function(current, next, dx, dy) {
  return new Edge([
    current[0] + dx,
    current[1] + dy
  ], [
    next[0] + dx,
    next[1] + dy
  ]);
};


/**
 *
 * @return {Edge}
 */
Edge.prototype.inverse = function () {
  return new Edge(this.next, this.current);
};


module.exports = Edge;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(288);


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var INTERSECTION    = 0;
var UNION           = 1;
var DIFFERENCE      = 2;
var XOR             = 3;

var EMPTY           = [];

var edgeType        = __webpack_require__(174);

var Queue           = __webpack_require__(289);
var Tree            = __webpack_require__(290).RBTree;
var SweepEvent      = __webpack_require__(293);

var compareEvents   = __webpack_require__(176);
var compareSegments = __webpack_require__(294);
var intersection    = __webpack_require__(295);
var equals          = __webpack_require__(177);

var max = Math.max;
var min = Math.min;

// global.Tree = Tree;
// global.compareSegments = compareSegments;
// global.SweepEvent = SweepEvent;
// global.signedArea = require('./signed_area');

/**
 * @param  {<Array.<Number>} s1
 * @param  {<Array.<Number>} s2
 * @param  {Boolean}         isSubject
 * @param  {Queue}           eventQueue
 * @param  {Array.<Number>}  bbox
 */
function processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {
  // Possible degenerate condition.
  // if (equals(s1, s2)) return;

  var e1 = new SweepEvent(s1, false, undefined, isSubject);
  var e2 = new SweepEvent(s2, false, e1,        isSubject);
  e1.otherEvent = e2;

  e1.contourId = e2.contourId = depth;

  if (compareEvents(e1, e2) > 0) {
    e2.left = true;
  } else {
    e1.left = true;
  }

  bbox[0] = min(bbox[0], s1[0]);
  bbox[1] = min(bbox[1], s1[1]);
  bbox[2] = max(bbox[2], s1[0]);
  bbox[3] = max(bbox[3], s1[1]);

  // Pushing it so the queue is sorted from left to right,
  // with object on the left having the highest priority.
  eventQueue.push(e1);
  eventQueue.push(e2);
}

var contourId = 0;

function processPolygon(polygon, isSubject, depth, queue, bbox) {
  var i, len;
  if (typeof polygon[0][0] === 'number') {
    for (i = 0, len = polygon.length - 1; i < len; i++) {
      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);
    }
  } else {
    for (i = 0, len = polygon.length; i < len; i++) {
      contourId++;
      processPolygon(polygon[i], isSubject, contourId, queue, bbox);
    }
  }
}


function fillQueue(subject, clipping, sbbox, cbbox) {
  var eventQueue = new Queue(null, compareEvents);
  contourId = 0;

  processPolygon(subject,  true,  0, eventQueue, sbbox);
  processPolygon(clipping, false, 0, eventQueue, cbbox);

  return eventQueue;
}


function computeFields(event, prev, sweepLine, operation) {
  // compute inOut and otherInOut fields
  if (prev === null) {
    event.inOut      = false;
    event.otherInOut = true;

  // previous line segment in sweepline belongs to the same polygon
  } else if (event.isSubject === prev.isSubject) {
    event.inOut      = !prev.inOut;
    event.otherInOut = prev.otherInOut;

  // previous line segment in sweepline belongs to the clipping polygon
  } else {
    event.inOut      = !prev.otherInOut;
    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
  }

  // compute prevInResult field
  if (prev) {
    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?
       prev.prevInResult : prev;
  }
  // check if the line segment belongs to the Boolean operation
  event.inResult = inResult(event, operation);
}


function inResult(event, operation) {
  switch (event.type) {
    case edgeType.NORMAL:
      switch (operation) {
        case INTERSECTION:
          return !event.otherInOut;
        case UNION:
          return event.otherInOut;
        case DIFFERENCE:
          return (event.isSubject && event.otherInOut) ||
                 (!event.isSubject && !event.otherInOut);
        case XOR:
          return true;
      }
    case edgeType.SAME_TRANSITION:
      return operation === INTERSECTION || operation === UNION;
    case edgeType.DIFFERENT_TRANSITION:
      return operation === DIFFERENCE;
    case edgeType.NON_CONTRIBUTING:
      return false;
  }
  return false;
}


/**
 * @param  {SweepEvent} se1
 * @param  {SweepEvent} se2
 * @param  {Queue}      queue
 * @return {Number}
 */
function possibleIntersection(se1, se2, queue) {
  // that disallows self-intersecting polygons,
  // did cost us half a day, so I'll leave it
  // out of respect
  // if (se1.isSubject === se2.isSubject) return;

  var inter = intersection(
    se1.point, se1.otherEvent.point,
    se2.point, se2.otherEvent.point
  );

  var nintersections = inter ? inter.length : 0;
  if (nintersections === 0) return 0; // no intersection

  // the line segments intersect at an endpoint of both line segments
  if ((nintersections === 1) &&
      (equals(se1.point, se2.point) ||
       equals(se1.otherEvent.point, se2.otherEvent.point))) {
    return 0;
  }

  if (nintersections === 2 && se1.isSubject === se2.isSubject){
    if(se1.contourId === se2.contourId){
    console.warn('Edges of the same polygon overlap',
      se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
    }
    //throw new Error('Edges of the same polygon overlap');
    return 0;
  }

  // The line segments associated to se1 and se2 intersect
  if (nintersections === 1) {

    // if the intersection point is not an endpoint of se1
    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
      divideSegment(se1, inter[0], queue);
    }

    // if the intersection point is not an endpoint of se2
    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
      divideSegment(se2, inter[0], queue);
    }
    return 1;
  }

  // The line segments associated to se1 and se2 overlap
  var events        = [];
  var leftCoincide  = false;
  var rightCoincide = false;

  if (equals(se1.point, se2.point)) {
    leftCoincide = true; // linked
  } else if (compareEvents(se1, se2) === 1) {
    events.push(se2, se1);
  } else {
    events.push(se1, se2);
  }

  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
    rightCoincide = true;
  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
    events.push(se2.otherEvent, se1.otherEvent);
  } else {
    events.push(se1.otherEvent, se2.otherEvent);
  }

  if ((leftCoincide && rightCoincide) || leftCoincide) {
    // both line segments are equal or share the left endpoint
    se1.type = edgeType.NON_CONTRIBUTING;
    se2.type = (se1.inOut === se2.inOut) ?
      edgeType.SAME_TRANSITION :
      edgeType.DIFFERENT_TRANSITION;

    if (leftCoincide && !rightCoincide) {
      // honestly no idea, but changing events selection from [2, 1]
      // to [0, 1] fixes the overlapping self-intersecting polygons issue
      divideSegment(events[0].otherEvent, events[1].point, queue);
    }
    return 2;
  }

  // the line segments share the right endpoint
  if (rightCoincide) {
    divideSegment(events[0], events[1].point, queue);
    return 3;
  }

  // no line segment includes totally the other one
  if (events[0] !== events[3].otherEvent) {
    divideSegment(events[0], events[1].point, queue);
    divideSegment(events[1], events[2].point, queue);
    return 3;
  }

  // one line segment includes the other one
  divideSegment(events[0], events[1].point, queue);
  divideSegment(events[3].otherEvent, events[2].point, queue);

  return 3;
}


/**
 * @param  {SweepEvent} se
 * @param  {Array.<Number>} p
 * @param  {Queue} queue
 * @return {Queue}
 */
function divideSegment(se, p, queue)  {
  var r = new SweepEvent(p, false, se,            se.isSubject);
  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);

  if (equals(se.point, se.otherEvent.point)) {
    console.warn('what is that?', se);
  }

  r.contourId = l.contourId = se.contourId;

  // avoid a rounding error. The left event would be processed after the right event
  if (compareEvents(l, se.otherEvent) > 0) {
    se.otherEvent.left = true;
    l.left = false;
  }

  // avoid a rounding error. The left event would be processed after the right event
  // if (compareEvents(se, r) > 0) {}

  se.otherEvent.otherEvent = l;
  se.otherEvent = r;

  queue.push(l);
  queue.push(r);

  return queue;
}


/* eslint-disable no-unused-vars, no-debugger */
function iteratorEquals(it1, it2) {
  return it1._cursor === it2._cursor;
}


function _renderSweepLine(sweepLine, pos, event) {
  var map = window.map;
  if (!map) return;
  if (window.sws) window.sws.forEach(function(p) {
    map.removeLayer(p);
  });
  window.sws = [];
  sweepLine.each(function(e) {
    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);
    window.sws.push(poly);
  });

  if (window.vt) map.removeLayer(window.vt);
  var v = pos.slice();
  var b = map.getBounds();
  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);

  if (window.ps) map.removeLayer(window.ps);
  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);
  debugger;
}
/* eslint-enable no-unused-vars, no-debugger */


function subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {
  var sortedEvents = [];
  var prev, next;

  var sweepLine = new Tree(compareSegments);
  var sortedEvents = [];

  var rightbound = min(sbbox[2], cbbox[2]);

  var prev, next;

  while (eventQueue.length) {
    var event = eventQueue.pop();
    sortedEvents.push(event);

    // optimization by bboxes for intersection and difference goes here
    if ((operation === INTERSECTION && event.point[0] > rightbound) ||
        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {
      break;
    }

    if (event.left) {
      sweepLine.insert(event);
      // _renderSweepLine(sweepLine, event.point, event);

      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);
      event.iterator = sweepLine.findIter(event);

      // Cannot get out of the tree what we just put there
      if (!prev || !next) {
        console.log('brute');
        var iterators = findIterBrute(sweepLine);
        prev = iterators[0];
        next = iterators[1];
      }

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.iterator(); //findIter(sweepLine.max());
        prev.prev();
        prev.next();
      }
      next.next();

      computeFields(event, prev.data(), sweepLine, operation);

      if (next.data()) {
        if (possibleIntersection(event, next.data(), eventQueue) === 2) {
          computeFields(event, prev.data(), sweepLine, operation);
          computeFields(event, next.data(), sweepLine, operation);
        }
      }

      if (prev.data()) {
        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {
          var prevprev = sweepLine.findIter(prev.data());
          if (prevprev.data() !== sweepLine.min()) {
            prevprev.prev();
          } else {
            prevprev = sweepLine.findIter(sweepLine.max());
            prevprev.next();
          }
          computeFields(prev.data(), prevprev.data(), sweepLine, operation);
          computeFields(event, prev.data(), sweepLine, operation);
        }
      }
    } else {
      event = event.otherEvent;
      next = sweepLine.findIter(event);
      prev = sweepLine.findIter(event);

      // _renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (!(prev && next)) continue;

      if (prev.data() !== sweepLine.min()) {
        prev.prev();
      } else {
        prev = sweepLine.iterator();
        prev.prev(); // sweepLine.findIter(sweepLine.max());
        prev.next();
      }
      next.next();
      sweepLine.remove(event);

      //_renderSweepLine(sweepLine, event.otherEvent.point, event);

      if (next.data() && prev.data()) {
        possibleIntersection(prev.data(), next.data(), eventQueue);
      }
    }
  }
  return sortedEvents;
}

function findIterBrute(sweepLine, q) {
  var prev = sweepLine.iterator();
  var next = sweepLine.iterator();
  var it   = sweepLine.iterator(), data;
  while((data = it.next()) !== null) {
    prev.next();
    next.next();
    if (data === event) {
      break;
    }
  }
  return [prev, next];
}


function swap (arr, i, n) {
  var temp = arr[i];
  arr[i] = arr[n];
  arr[n] = temp;
}


function changeOrientation(contour) {
  return contour.reverse();
}


function isArray (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
}


function addHole(contour, idx) {
  if (isArray(contour[0]) && !isArray(contour[0][0])) {
    contour = [contour];
  }
  contour[idx] = [];
  return contour;
}


/**
 * @param  {Array.<SweepEvent>} sortedEvents
 * @return {Array.<SweepEvent>}
 */
function orderEvents(sortedEvents) {
  var event, i, len;
  var resultEvents = [];
  for (i = 0, len = sortedEvents.length; i < len; i++) {
    event = sortedEvents[i];
    if ((event.left && event.inResult) ||
      (!event.left && event.otherEvent.inResult)) {
      resultEvents.push(event);
    }
  }

  // Due to overlapping edges the resultEvents array can be not wholly sorted
  var sorted = false;
  while (!sorted) {
    sorted = true;
    for (i = 0, len = resultEvents.length; i < len; i++) {
      if ((i + 1) < len &&
        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
        swap(resultEvents, i, i + 1);
        sorted = false;
      }
    }
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    resultEvents[i].pos = i;
  }

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (!resultEvents[i].left) {
      var temp = resultEvents[i].pos;
      resultEvents[i].pos = resultEvents[i].otherEvent.pos;
      resultEvents[i].otherEvent.pos = temp;
    }
  }

  return resultEvents;
}


/**
 * @param  {Array.<SweepEvent>} sortedEvents
 * @return {Array.<*>} polygons
 */
function connectEdges(sortedEvents) {
  var i, len;
  var resultEvents = orderEvents(sortedEvents);


  // "false"-filled array
  var processed = Array(resultEvents.length);
  var result = [];

  var depth  = [];
  var holeOf = [];
  var isHole = {};

  for (i = 0, len = resultEvents.length; i < len; i++) {
    if (processed[i]) continue;

    var contour = [];
    result.push(contour);

    var ringId = result.length - 1;
    depth.push(0);
    holeOf.push(-1);


    if (resultEvents[i].prevInResult) {
      var lowerContourId = resultEvents[i].prevInResult.contourId;
      if (!resultEvents[i].prevInResult.resultInOut) {
        addHole(result[lowerContourId], ringId);
        holeOf[ringId] = lowerContourId;
        depth[ringId]  = depth[lowerContourId] + 1;
        isHole[ringId] = true;
      } else if (isHole[lowerContourId]) {
        addHole(result[holeOf[lowerContourId]], ringId);
        holeOf[ringId] = holeOf[lowerContourId];
        depth[ringId]  = depth[lowerContourId];
        isHole[ringId] = true;
      }
    }

    var pos = i;
    var initial = resultEvents[i].point;
    contour.push(initial);

    while (pos >= i) {
      processed[pos] = true;

      if (resultEvents[pos].left) {
        resultEvents[pos].resultInOut = false;
        resultEvents[pos].contourId   = ringId;
      } else {
        resultEvents[pos].otherEvent.resultInOut = true;
        resultEvents[pos].otherEvent.contourId   = ringId;
      }

      pos = resultEvents[pos].pos;
      processed[pos] = true;

      contour.push(resultEvents[pos].point);
      pos = nextPos(pos, resultEvents, processed);
    }

    pos = pos === -1 ? i : pos;

    processed[pos] = processed[resultEvents[pos].pos] = true;
    resultEvents[pos].otherEvent.resultInOut = true;
    resultEvents[pos].otherEvent.contourId   = ringId;


    // depth is even
    /* eslint-disable no-bitwise */
    if (depth[ringId] & 1) {
      changeOrientation(contour);
    }
    /* eslint-enable no-bitwise */
  }

  return result;
}


/**
 * @param  {Number} pos
 * @param  {Array.<SweepEvent>} resultEvents
 * @param  {Array.<Boolean>}    processed
 * @return {Number}
 */
function nextPos(pos, resultEvents, processed) {
  var newPos = pos + 1;
  var length = resultEvents.length;
  while (newPos < length &&
         equals(resultEvents[newPos].point, resultEvents[pos].point)) {
    if (!processed[newPos]) {
      return newPos;
    } else {
      newPos = newPos + 1;
    }
  }

  newPos = pos - 1;

  while (processed[newPos]) {
    newPos = newPos - 1;
  }
  return newPos;
}


function trivialOperation(subject, clipping, operation) {
  var result = null;
  if (subject.length * clipping.length === 0) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = (subject.length === 0) ? clipping : subject;
    }
  }
  return result;
}


function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
  var result = null;
  if (sbbox[0] > cbbox[2] ||
      cbbox[0] > sbbox[2] ||
      sbbox[1] > cbbox[3] ||
      cbbox[1] > sbbox[3]) {
    if (operation === INTERSECTION) {
      result = EMPTY;
    } else if (operation === DIFFERENCE) {
      result = subject;
    } else if (operation === UNION || operation === XOR) {
      result = subject.concat(clipping);
    }
  }
  return result;
}


function boolean(subject, clipping, operation) {
  var trivial = trivialOperation(subject, clipping, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];

  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);

  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);
  if (trivial) {
    return trivial === EMPTY ? null : trivial;
  }
  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);
  return connectEdges(sortedEvents);
}


module.exports = boolean;


module.exports.union = function(subject, clipping) {
  return boolean(subject, clipping, UNION);
};


module.exports.diff = function(subject, clipping) {
  return boolean(subject, clipping, DIFFERENCE);
};


module.exports.xor = function(subject, clipping) {
  return boolean(subject, clipping, XOR);
};


module.exports.intersection = function(subject, clipping) {
  return boolean(subject, clipping, INTERSECTION);
};


/**
 * @enum {Number}
 */
module.exports.operations = {
  INTERSECTION: INTERSECTION,
  DIFFERENCE:   DIFFERENCE,
  UNION:        UNION,
  XOR:          XOR
};


// for testing
module.exports.fillQueue            = fillQueue;
module.exports.computeFields        = computeFields;
module.exports.subdivideSegments    = subdivideSegments;
module.exports.divideSegment        = divideSegment;
module.exports.possibleIntersection = possibleIntersection;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = TinyQueue;
module.exports.default = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        if (this.length === 0) return undefined;

        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
            this.data[0] = this.data[this.length];
            this._down(0);
        }
        this.data.pop();

        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
            var parent = (pos - 1) >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    },

    _down: function (pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var right = left + 1;
            var best = data[left];

            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    RBTree: __webpack_require__(291),
    BinTree: __webpack_require__(292)
};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {


var TreeBase = __webpack_require__(175);

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function RBTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

RBTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
RBTree.prototype.insert = function(data) {
    var ret = false;

    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        ret = true;
        this.size++;
    }
    else {
        var head = new Node(undefined); // fake tree root

        var dir = 0;
        var last = 0;

        // setup
        var gp = null; // grandparent
        var ggp = head; // grand-grand-parent
        var p = null; // parent
        var node = this._root;
        ggp.right = this._root;

        // search down
        while(true) {
            if(node === null) {
                // insert new node at the bottom
                node = new Node(data);
                p.set_child(dir, node);
                ret = true;
                this.size++;
            }
            else if(is_red(node.left) && is_red(node.right)) {
                // color flip
                node.red = true;
                node.left.red = false;
                node.right.red = false;
            }

            // fix red violation
            if(is_red(node) && is_red(p)) {
                var dir2 = ggp.right === gp;

                if(node === p.get_child(last)) {
                    ggp.set_child(dir2, single_rotate(gp, !last));
                }
                else {
                    ggp.set_child(dir2, double_rotate(gp, !last));
                }
            }

            var cmp = this._comparator(node.data, data);

            // stop if found
            if(cmp === 0) {
                break;
            }

            last = dir;
            dir = cmp < 0;

            // update helpers
            if(gp !== null) {
                ggp = gp;
            }
            gp = p;
            p = node;
            node = node.get_child(dir);
        }

        // update root
        this._root = head.right;
    }

    // make root black
    this._root.red = false;

    return ret;
};

// returns true if removed, false if not found
RBTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var gp = null; // grand parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        var last = dir;

        // update helpers
        gp = p;
        p = node;
        node = node.get_child(dir);

        var cmp = this._comparator(data, node.data);

        dir = cmp > 0;

        // save found node
        if(cmp === 0) {
            found = node;
        }

        // push the red node down
        if(!is_red(node) && !is_red(node.get_child(dir))) {
            if(is_red(node.get_child(!dir))) {
                var sr = single_rotate(node, dir);
                p.set_child(last, sr);
                p = sr;
            }
            else if(!is_red(node.get_child(!dir))) {
                var sibling = p.get_child(!last);
                if(sibling !== null) {
                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                        // color flip
                        p.red = false;
                        sibling.red = true;
                        node.red = true;
                    }
                    else {
                        var dir2 = gp.right === p;

                        if(is_red(sibling.get_child(last))) {
                            gp.set_child(dir2, double_rotate(p, last));
                        }
                        else if(is_red(sibling.get_child(!last))) {
                            gp.set_child(dir2, single_rotate(p, last));
                        }

                        // ensure correct coloring
                        var gpc = gp.get_child(dir2);
                        gpc.red = true;
                        node.red = true;
                        gpc.left.red = false;
                        gpc.right.red = false;
                    }
                }
            }
        }
    }

    // replace and remove if found
    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
    }

    // update root and make it black
    this._root = head.right;
    if(this._root !== null) {
        this._root.red = false;
    }

    return found !== null;
};

function is_red(node) {
    return node !== null && node.red;
}

function single_rotate(root, dir) {
    var save = root.get_child(!dir);

    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);

    root.red = true;
    save.red = false;

    return save;
}

function double_rotate(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
}

module.exports = RBTree;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {


var TreeBase = __webpack_require__(175);

function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}

Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
};

Node.prototype.set_child = function(dir, val) {
    if(dir) {
        this.right = val;
    }
    else {
        this.left = val;
    }
};

function BinTree(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
}

BinTree.prototype = new TreeBase();

// returns true if inserted, false if duplicate
BinTree.prototype.insert = function(data) {
    if(this._root === null) {
        // empty tree
        this._root = new Node(data);
        this.size++;
        return true;
    }

    var dir = 0;

    // setup
    var p = null; // parent
    var node = this._root;

    // search down
    while(true) {
        if(node === null) {
            // insert new node at the bottom
            node = new Node(data);
            p.set_child(dir, node);
            ret = true;
            this.size++;
            return true;
        }

        // stop if found
        if(this._comparator(node.data, data) === 0) {
            return false;
        }

        dir = this._comparator(node.data, data) < 0;

        // update helpers
        p = node;
        node = node.get_child(dir);
    }
};

// returns true if removed, false if not found
BinTree.prototype.remove = function(data) {
    if(this._root === null) {
        return false;
    }

    var head = new Node(undefined); // fake tree root
    var node = head;
    node.right = this._root;
    var p = null; // parent
    var found = null; // found item
    var dir = 1;

    while(node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;

        if(cmp === 0) {
            found = node;
        }
    }

    if(found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));

        this._root = head.right;
        this.size--;
        return true;
    }
    else {
        return false;
    }
};

module.exports = BinTree;



/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var signedArea = __webpack_require__(126);
var EdgeType   = __webpack_require__(174);


/**
 * Sweepline event
 *
 * @param {Array.<Number>}  point
 * @param {Boolean}         left
 * @param {SweepEvent=}     otherEvent
 * @param {Boolean}         isSubject
 * @param {Number}          edgeType
 */
function SweepEvent(point, left, otherEvent, isSubject, edgeType) {

  /**
   * Is left endpoint?
   * @type {Boolean}
   */
  this.left = left;

  /**
   * @type {Array.<Number>}
   */
  this.point = point;

  /**
   * Other edge reference
   * @type {SweepEvent}
   */
  this.otherEvent = otherEvent;

  /**
   * Belongs to source or clipping polygon
   * @type {Boolean}
   */
  this.isSubject = isSubject;

  /**
   * Edge contribution type
   * @type {Number}
   */
  this.type = edgeType || EdgeType.NORMAL;


  /**
   * In-out transition for the sweepline crossing polygon
   * @type {Boolean}
   */
  this.inOut = false;


  /**
   * @type {Boolean}
   */
  this.otherInOut = false;

  /**
   * Previous event in result?
   * @type {SweepEvent}
   */
  this.prevInResult = null;

  /**
   * Does event belong to result?
   * @type {Boolean}
   */
  this.inResult = false;


  // connection step

  /**
   * @type {Boolean}
   */
  this.resultInOut = false;
}


SweepEvent.prototype = {

  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isBelow: function(p) {
    return this.left ?
      signedArea (this.point, this.otherEvent.point, p) > 0 :
      signedArea (this.otherEvent.point, this.point, p) > 0;
  },


  /**
   * @param  {Array.<Number>}  p
   * @return {Boolean}
   */
  isAbove: function(p) {
    return !this.isBelow(p);
  },


  /**
   * @return {Boolean}
   */
  isVertical: function() {
    return this.point[0] === this.otherEvent.point[0];
  }
};

module.exports = SweepEvent;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var signedArea    = __webpack_require__(126);
var compareEvents = __webpack_require__(176);
var equals        = __webpack_require__(177);


/**
 * @param  {SweepEvent} le1
 * @param  {SweepEvent} le2
 * @return {Number}
 */
module.exports = function compareSegments(le1, le2) {
  if (le1 === le2) return 0;

  // Segments are not collinear
  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||
    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {

    // If they share their left endpoint use the right endpoint to sort
    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;

    // Different left endpoint: use the left endpoint to sort
    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;

    // has the line segment associated to e1 been inserted
    // into S after the line segment associated to e2 ?
    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;

    // The line segment associated to e2 has been inserted
    // into S after the line segment associated to e1
    return le1.isBelow(le2.point) ? -1 : 1;
  }

  if (le1.isSubject === le2.isSubject) { // same polygon
    if (equals(le1.point, le2.point)) {
      if (equals(le1.otherEvent.point, le2.otherEvent.point)) {
        return 0;
      } else {
        return le1.contourId > le2.contourId ? 1 : -1;
      }
    }
  } else { // Segments are collinear, but belong to separate polygons
    return le1.isSubject ? -1 : 1;
  }

  return compareEvents(le1, le2) === 1 ? 1 : -1;
};


/***/ }),
/* 295 */
/***/ (function(module, exports) {

var EPSILON = 1e-9;

/**
 * Finds the magnitude of the cross product of two vectors (if we pretend
 * they're in three dimensions)
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The magnitude of the cross product
 */
function krossProduct(a, b) {
  return a[0] * b[1] - a[1] * b[0];
}

/**
 * Finds the dot product of two vectors.
 *
 * @param {Object} a First vector
 * @param {Object} b Second vector
 * @private
 * @returns {Number} The dot product
 */
function dotProduct(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Finds the intersection (if any) between two line segments a and b, given the
 * line segments' end points a1, a2 and b1, b2.
 *
 * This algorithm is based on Schneider and Eberly.
 * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
 * Page 244.
 *
 * @param {Array.<Number>} a1 point of first line
 * @param {Array.<Number>} a2 point of first line
 * @param {Array.<Number>} b1 point of second line
 * @param {Array.<Number>} b2 point of second line
 * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
 *                                         (meaning connected segments) as
 *                                         intersections
 * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
 * intersection. If they overlap, the two end points of the overlapping segment.
 * Otherwise, null.
 */
module.exports = function(a1, a2, b1, b2, noEndpointTouch) {
  // The algorithm expects our lines in the form P + sd, where P is a point,
  // s is on the interval [0, 1], and d is a vector.
  // We are passed two points. P can be the first point of each pair. The
  // vector, then, could be thought of as the distance (in x and y components)
  // from the first point to the second point.
  // So first, let's make our vectors:
  var va = [a2[0] - a1[0], a2[1] - a1[1]];
  var vb = [b2[0] - b1[0], b2[1] - b1[1]];
  // We also define a function to convert back to regular point form:

  /* eslint-disable arrow-body-style */

  function toPoint(p, s, d) {
    return [
      p[0] + s * d[0],
      p[1] + s * d[1]
    ];
  }

  /* eslint-enable arrow-body-style */

  // The rest is pretty much a straight port of the algorithm.
  var e = [b1[0] - a1[0], b1[1] - a1[1]];
  var kross = krossProduct(va, vb);
  var sqrKross = kross * kross;
  var sqrLenA = dotProduct(va, va);
  var sqrLenB = dotProduct(vb, vb);

  // Check for line intersection. This works because of the properties of the
  // cross product -- specifically, two vectors are parallel if and only if the
  // cross product is the 0 vector. The full calculation involves relative error
  // to account for possible very small line segments. See Schneider & Eberly
  // for details.
  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {
    // If they're not parallel, then (because these are line segments) they
    // still might not actually intersect. This code checks that the
    // intersection point of the lines is actually on both line segments.
    var s = krossProduct(e, vb) / kross;
    if (s < 0 || s > 1) {
      // not on line segment a
      return null;
    }
    var t = krossProduct(e, va) / kross;
    if (t < 0 || t > 1) {
      // not on line segment b
      return null;
    }
    return noEndpointTouch ? null : [toPoint(a1, s, va)];
  }

  // If we've reached this point, then the lines are either parallel or the
  // same, but the segments could overlap partially or fully, or not at all.
  // So we need to find the overlap, if any. To do that, we can use e, which is
  // the (vector) difference between the two initial points. If this is parallel
  // with the line itself, then the two lines are the same line, and there will
  // be overlap.
  var sqrLenE = dotProduct(e, e);
  kross = krossProduct(e, va);
  sqrKross = kross * kross;

  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {
    // Lines are just parallel, not the same. No overlap.
    return null;
  }

  var sa = dotProduct(va, e) / sqrLenA;
  var sb = sa + dotProduct(va, vb) / sqrLenA;
  var smin = Math.min(sa, sb);
  var smax = Math.max(sa, sb);

  // this is, essentially, the FindIntersection acting on floats from
  // Schneider & Eberly, just inlined into this function.
  if (smin <= 1 && smax >= 0) {

    // overlap on an end point
    if (smin === 1) {
      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
    }

    if (smax === 0) {
      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
    }

    if (noEndpointTouch && smin === 0 && smax === 1) return null;

    // There's overlap on a segment -- two points of intersection. Return both.
    return [
      toPoint(a1, smin > 0 ? smin : 0, va),
      toPoint(a1, smax < 1 ? smax : 1, va),
    ];
  }

  return null;
};


/***/ }),
/* 296 */
/***/ (function(module, exports) {

/**
 * @param  {*} arr
 * @return {Boolean}
 */
var isArray = module.exports.isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) === '[object Array]';
};


/**
 * @param  {Array.<Number>} p1
 * @param  {Array.<Number>} p2
 * @return {Boolean}
 */
module.exports.equals = function equals(p1, p2) {
  return p1[0] === p2[0] && p1[1] === p2[1];
};


/**
 * @param  {*}       coordinates
 * @param  {Number=} depth
 * @return {*}
 */
module.exports.orientRings = function orientRings(coordinates, depth, isHole) {
  depth = depth || 0;
  var i, len;
  if (isArray(coordinates) && typeof coordinates[0][0] === 'number') {
    var area = 0;
    var ring = coordinates;

    for (i = 0, len = ring.length; i < len; i++) {
      var pt1 = ring[i];
      var pt2 = ring[(i + 1) % len];
      area += pt1[0] * pt2[1];
      area -= pt2[0] * pt1[1];
    }
    if ((!isHole && area > 0) || (isHole && area < 0)) {
      ring.reverse();
    }
  } else {
    for (i = 0, len = coordinates.length; i < len; i++) {
      orientRings(coordinates[i], depth + 1, i > 0);
    }
  }

  return coordinates;
};

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var simpleTypeDistill = function (typeProp) {
    if (typeProp && typeProp.type) {
        return typeProp.type;
    }
    return typeProp;
};
exports.basicPropDiffing = function (previousProp, nextProp) {
    return simpleTypeDistill(previousProp) !== simpleTypeDistill(nextProp);
};
exports.basicDataChangeCheck = function (prevData, newData) {
    return prevData !== newData ||
        (Array.isArray(prevData) &&
            Array.isArray(newData) &&
            !!prevData.find(function (p) { return newData.indexOf(p) === -1; }));
};


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_scale_1 = __webpack_require__(24);
var Axis_1 = __importDefault(__webpack_require__(82));
var axis_1 = __webpack_require__(122);
var dataFunctions_1 = __webpack_require__(52);
var AnnotationCallout_1 = __importDefault(__webpack_require__(299));
var general_1 = __webpack_require__(85);
var frameFunctions_1 = __webpack_require__(33);
var screenScales = function (_a) {
    var xExtent = _a.xExtent, yExtent = _a.yExtent, adjustedSize = _a.adjustedSize, xScaleType = _a.xScaleType, yScaleType = _a.yScaleType;
    var xDomain = [0, adjustedSize[0]];
    var yDomain = [adjustedSize[1], 0];
    var xScale = xScaleType;
    var yScale = yScaleType;
    if (xScaleType.domain) {
        xScaleType.domain(xExtent);
    }
    if (yScaleType.domain) {
        yScaleType.domain(yExtent);
    }
    xScaleType.range(xDomain);
    yScaleType.range(yDomain);
    return { xScale: xScale, yScale: yScale };
};
var naturalLanguageLineType = {
    line: { items: "line", chart: "line chart" },
    area: { items: "summary", chart: "summary chart" },
    summary: { items: "summary", chart: "summary chart" },
    cumulative: { items: "line", chart: "cumulative chart" },
    "cumulative-reverse": { items: "line", chart: "cumulative chart" },
    linepercent: { items: "line", chart: "line chart" },
    stackedarea: { items: "stacked area", chart: "stacked area chart" },
    "stackedarea-invert": { items: "stacked area", chart: "stacked area chart" },
    stackedpercent: { items: "stacked area", chart: "stacked area chart" },
    "stackedpercent-invert": {
        items: "stacked area",
        chart: "stacked area chart"
    },
    bumparea: { items: "ranked area", chart: "ranked area chart" },
    "bumparea-invert": { items: "ranked area", chart: "ranked area chart" },
    bumpline: { items: "ranked line", chart: "ranked line chart" },
    difference: {
        items: "line",
        chart: "difference chart"
    }
};
var emptyObjectReturnFunction = function () { return ({}); };
var emptyStringReturnFunction = function () { return ""; };
exports.calculateXYFrame = function (currentProps, prevState, updateData) {
    var _a, _b, _c;
    var legend = currentProps.legend, lines = currentProps.lines, lineClass = currentProps.lineClass, pointStyle = currentProps.pointStyle, pointRenderMode = currentProps.pointRenderMode, pointClass = currentProps.pointClass, summaryClass = currentProps.summaryClass, canvasLines = currentProps.canvasLines, canvasPoints = currentProps.canvasPoints, canvasSummaries = currentProps.canvasSummaries, defined = currentProps.defined, size = currentProps.size, renderKey = currentProps.renderKey, lineType = currentProps.lineType, summaryType = currentProps.summaryType, customLineMark = currentProps.customLineMark, customPointMark = currentProps.customPointMark, customSummaryMark = currentProps.customSummaryMark, summaryStyle = currentProps.summaryStyle, summaryRenderMode = currentProps.summaryRenderMode, lineStyle = currentProps.lineStyle, lineRenderMode = currentProps.lineRenderMode, baseXExtent = currentProps.xExtent, baseYExtent = currentProps.yExtent, title = currentProps.title, _d = currentProps.xScaleType, baseXScaleType = _d === void 0 ? d3_scale_1.scaleLinear() : _d, _e = currentProps.yScaleType, baseYScaleType = _e === void 0 ? d3_scale_1.scaleLinear() : _e, lineIDAccessor = currentProps.lineIDAccessor, invertX = currentProps.invertX, invertY = currentProps.invertY, showLinePoints = currentProps.showLinePoints, showSummaryPoints = currentProps.showSummaryPoints, points = currentProps.points, lineDataAccessor = currentProps.lineDataAccessor, summaryDataAccessor = currentProps.summaryDataAccessor, yAccessor = currentProps.yAccessor, xAccessor = currentProps.xAccessor, useSummariesAsInteractionLayer = currentProps.useSummariesAsInteractionLayer, baseMarkProps = currentProps.baseMarkProps, filterRenderedLines = currentProps.filterRenderedLines, filterRenderedSummaries = currentProps.filterRenderedSummaries, filterRenderedPoints = currentProps.filterRenderedPoints, annotations = currentProps.annotations;
    var projectedLines = currentProps.projectedLines, projectedPoints = currentProps.projectedPoints, projectedSummaries = currentProps.projectedSummaries, summaries = currentProps.summaries, fullDataset = currentProps.fullDataset;
    if (summaryType && points && !summaries) {
        summaries = [{ coordinates: points }];
    }
    else if (summaryType &&
        summaryType.type === "linebounds" &&
        lines &&
        !summaries) {
        summaries = lines;
    }
    var castXScaleType = baseXScaleType;
    var xScaleType = baseXScaleType.domain ? baseXScaleType : castXScaleType();
    var castYScaleType = baseYScaleType;
    var yScaleType = baseYScaleType.domain ? baseYScaleType : castYScaleType();
    var annotatedSettings = {
        xAccessor: dataFunctions_1.stringToArrayFn(xAccessor, function (d) { return d[0]; }),
        yAccessor: dataFunctions_1.stringToArrayFn(yAccessor, function (d) { return d[1]; }),
        summaryDataAccessor: dataFunctions_1.stringToArrayFn(summaryDataAccessor, function (d) { return (Array.isArray(d) ? d : d.coordinates); }),
        lineDataAccessor: dataFunctions_1.stringToArrayFn(lineDataAccessor, function (d) { return (Array.isArray(d) ? d : d.coordinates); }),
        renderKeyFn: dataFunctions_1.stringToFn(renderKey, function (d, i) { return "line-" + i; }, true),
        lineType: frameFunctions_1.objectifyType(lineType),
        summaryType: frameFunctions_1.objectifyType(summaryType),
        lineIDAccessor: dataFunctions_1.stringToFn(lineIDAccessor, function (l) { return l.semioticLineID; }),
        summaries: !summaries || (Array.isArray(summaries) && summaries.length === 0)
            ? undefined
            : !Array.isArray(summaries)
                ? [summaries]
                : !summaryDataAccessor && !summaries[0].coordinates
                    ? [{ coordinates: summaries }]
                    : summaries,
        lines: !lines || (Array.isArray(lines) && lines.length === 0)
            ? undefined
            : !Array.isArray(lines)
                ? [lines]
                : !lineDataAccessor && !lines[0].coordinates
                    ? [{ coordinates: lines }]
                    : lines,
        title: typeof title === "object" &&
            !React.isValidElement(title) &&
            title !== null
            ? title
            : { title: title, orient: "top" },
        xExtent: Array.isArray(baseXExtent)
            ? baseXExtent
            : !baseXExtent
                ? undefined
                : baseXExtent.extent,
        yExtent: Array.isArray(baseYExtent)
            ? baseYExtent
            : !baseYExtent
                ? undefined
                : baseYExtent.extent
    };
    if (annotatedSettings.lineType.type === "area") {
        annotatedSettings.lineType.y1 = function () { return 0; };
        annotatedSettings.lineType.simpleLine = false;
    }
    var summaryStyleFn = dataFunctions_1.stringToFn(summaryStyle, emptyObjectReturnFunction, true);
    var summaryClassFn = dataFunctions_1.stringToFn(summaryClass, emptyStringReturnFunction, true);
    var summaryRenderModeFn = dataFunctions_1.stringToFn(summaryRenderMode, undefined, true);
    var generatedAxes = currentProps.axes &&
        currentProps.axes.map(function (axisFnOrObject) {
            return typeof axisFnOrObject === "function"
                ? axisFnOrObject({ size: currentProps.size })
                : axisFnOrObject;
        });
    var margin = frameFunctions_1.calculateMargin({
        margin: currentProps.margin,
        axes: generatedAxes,
        title: annotatedSettings.title,
        size: currentProps.size
    });
    var _f = frameFunctions_1.adjustedPositionSize({
        size: currentProps.size,
        margin: margin
    }), adjustedPosition = _f.adjustedPosition, adjustedSize = _f.adjustedSize;
    var calculatedXExtent = [], calculatedYExtent = [], yExtent, xExtent, xExtentSettings, yExtentSettings;
    if (typeof baseXExtent === "object") {
        xExtentSettings = baseXExtent;
    }
    else {
        xExtentSettings = { extent: baseXExtent };
    }
    if (typeof baseYExtent === "object") {
        yExtentSettings = baseYExtent;
    }
    else {
        yExtentSettings = { extent: baseYExtent };
    }
    var xScale, yScale;
    if (updateData ||
        (currentProps.dataVersion &&
            currentProps.dataVersion !== prevState.dataVersion)) {
        //This will always fire at this point because xExtent/yExtent are just defined up there so revisit this logic
        if (!xExtent ||
            !yExtent ||
            !fullDataset ||
            (!projectedLines && !projectedPoints && !projectedSummaries)) {
            ;
            (_a = dataFunctions_1.calculateDataExtent({
                lineDataAccessor: annotatedSettings.lineDataAccessor,
                summaryDataAccessor: annotatedSettings.summaryDataAccessor,
                xAccessor: annotatedSettings.xAccessor,
                yAccessor: annotatedSettings.yAccessor,
                lineType: annotatedSettings.lineType,
                summaryType: annotatedSettings.summaryType,
                summaries: annotatedSettings.summaries,
                points: points,
                lines: annotatedSettings.lines,
                showLinePoints: showLinePoints,
                showSummaryPoints: showSummaryPoints,
                xExtent: baseXExtent,
                yExtent: baseYExtent,
                invertX: invertX,
                invertY: invertY,
                adjustedSize: adjustedSize,
                margin: margin,
                baseMarkProps: baseMarkProps,
                summaryStyleFn: summaryStyleFn,
                summaryClassFn: summaryClassFn,
                summaryRenderModeFn: summaryRenderModeFn,
                chartSize: size,
                xScaleType: xScaleType,
                yScaleType: yScaleType,
                defined: defined,
                filterRenderedLines: filterRenderedLines,
                filterRenderedSummaries: filterRenderedSummaries,
                filterRenderedPoints: filterRenderedPoints,
                annotations: annotations
            }), xExtent = _a.xExtent, yExtent = _a.yExtent, projectedLines = _a.projectedLines, projectedPoints = _a.projectedPoints, projectedSummaries = _a.projectedSummaries, fullDataset = _a.fullDataset, calculatedXExtent = _a.calculatedXExtent, calculatedYExtent = _a.calculatedYExtent);
        }
        ;
        (_b = screenScales({
            xExtent: xExtent,
            yExtent: yExtent,
            adjustedSize: adjustedSize,
            xScaleType: xScaleType.copy(),
            yScaleType: yScaleType.copy()
        }), xScale = _b.xScale, yScale = _b.yScale);
    }
    else {
        ;
        (xExtent = prevState.xExtent, yExtent = prevState.yExtent, projectedLines = prevState.projectedLines, projectedPoints = prevState.projectedPoints, projectedSummaries = prevState.projectedSummaries, fullDataset = prevState.fullDataset, calculatedXExtent = prevState.calculatedXExtent, calculatedYExtent = prevState.calculatedYExtent);
        if (adjustedSize[0] === prevState.adjustedSize[0] &&
            adjustedSize[1] === prevState.adjustedSize[1]) {
            xScale = prevState.xScale;
            yScale = prevState.yScale;
        }
        else {
            ;
            (_c = screenScales({
                xExtent: xExtent,
                yExtent: yExtent,
                adjustedSize: adjustedSize,
                xScaleType: xScaleType,
                yScaleType: yScaleType
            }), xScale = _c.xScale, yScale = _c.yScale);
        }
    }
    xExtent =
        Array.isArray(xExtentSettings.extent) && xExtentSettings.extent.length === 2
            ? xExtentSettings.extent
            : xExtent;
    yExtent =
        Array.isArray(yExtentSettings.extent) && yExtentSettings.extent.length === 2
            ? yExtentSettings.extent
            : yExtent;
    var canvasDrawing = [];
    var axes;
    var axesTickLines;
    var existingBaselines = {};
    if (generatedAxes) {
        axesTickLines = [];
        axes = generatedAxes.map(function (d, i) {
            var axisClassname = d.className || "";
            axisClassname += " axis";
            var axisScale = yScale;
            if (existingBaselines[d.orient]) {
                d.baseline = d.baseline || false;
            }
            existingBaselines[d.orient] = true;
            if (d.orient === "top" || d.orient === "bottom") {
                axisClassname += " x";
                axisScale = xScale;
            }
            else {
                axisClassname += " y";
            }
            axisClassname += " " + d.orient;
            var tickValues;
            if (d.tickValues && Array.isArray(d.tickValues)) {
                tickValues = d.tickValues;
            }
            else if (d.tickValues instanceof Function) {
                //otherwise assume a function
                tickValues = d.tickValues(fullDataset, currentProps.size, axisScale);
            }
            var axisSize = [adjustedSize[0], adjustedSize[1]];
            var axisParts = axis_1.axisPieces({
                padding: d.padding,
                tickValues: tickValues,
                scale: axisScale,
                ticks: d.ticks,
                orient: d.orient,
                size: axisSize,
                footer: d.footer,
                tickSize: d.tickSize,
                jaggedBase: d.jaggedBase
            });
            var axisTickLines = (React.createElement("g", { key: "axes-tick-lines-" + i, className: "axis " + axisClassname },
                axis_1.axisLines({
                    axisParts: axisParts,
                    orient: d.orient,
                    tickLineGenerator: d.tickLineGenerator,
                    baseMarkProps: baseMarkProps,
                    className: axisClassname,
                    jaggedBase: d.jaggedBase,
                    scale: axisScale,
                    showOutboundTickLines: d.showOutboundTickLines
                }),
                d.baseline === "under" &&
                    axis_1.baselineGenerator(d.orient, adjustedSize, d.className)));
            axesTickLines.push(axisTickLines);
            return (React.createElement(Axis_1.default, __assign({}, d, { key: d.key || "axis-" + i, annotationFunction: d.axisAnnotationFunction, axisParts: axisParts, size: axisSize, margin: margin, tickValues: tickValues, scale: axisScale, className: axisClassname, xyPoints: fullDataset })));
        });
    }
    var legendSettings;
    if (legend) {
        legendSettings = legend === true ? {} : legend;
        if (projectedLines && !legendSettings.legendGroups) {
            var typeString = annotatedSettings.lineType.type;
            var type = typeof typeString === "string" &&
                ["stackedarea", "stackedpercent", "bumparea"].indexOf(typeString) === -1
                ? "line"
                : "fill";
            var legendGroups = [
                {
                    styleFn: currentProps.lineStyle,
                    type: type,
                    items: projectedLines.map(function (d) {
                        return Object.assign({ label: annotatedSettings.lineIDAccessor(d) }, d);
                    })
                }
            ];
            legendSettings.legendGroups = legendGroups;
        }
    }
    var areaAnnotations = [];
    if (annotatedSettings.summaryType.label && projectedSummaries) {
        projectedSummaries.forEach(function (d, i) {
            if (d.bounds) {
                var bounds = Array.isArray(d.bounds) ? d.bounds : [d.bounds];
                bounds.forEach(function (labelBounds) {
                    var label = typeof annotatedSettings.summaryType.label === "function"
                        ? annotatedSettings.summaryType.label(d)
                        : annotatedSettings.summaryType.label;
                    if (label && label !== null) {
                        var labelPosition = label.position || "center";
                        var labelCenter = [
                            xScale(labelBounds[labelPosition][0]),
                            yScale(labelBounds[labelPosition][1])
                        ] || false;
                        var labelContent = label.content || (function (p) { return p.value || p.id || i; });
                        areaAnnotations.push({
                            x: labelCenter[0],
                            y: labelCenter[1],
                            dx: label.dx,
                            dy: label.dy,
                            className: label.className,
                            type: label.type || AnnotationCallout_1.default,
                            note: label.note || { title: labelContent(d) },
                            subject: label.subject || { text: labelContent(d) },
                            connector: label.connector
                        });
                    }
                });
            }
        });
    }
    var lineAriaLabel = annotatedSettings.lineType.type !== undefined &&
        typeof annotatedSettings.lineType.type === "string" &&
        naturalLanguageLineType[annotatedSettings.lineType.type];
    var xyFrameRender = {
        lines: {
            accessibleTransform: function (data, i) { return (__assign(__assign({}, data[i].data[data[i].data.length - 1]), { type: "frame-hover" })); },
            data: projectedLines,
            styleFn: dataFunctions_1.stringToFn(lineStyle, emptyObjectReturnFunction, true),
            classFn: dataFunctions_1.stringToFn(lineClass, emptyStringReturnFunction, true),
            renderMode: dataFunctions_1.stringToFn(lineRenderMode, undefined, true),
            canvasRender: dataFunctions_1.stringToFn(canvasLines, undefined, true),
            customMark: customLineMark,
            type: annotatedSettings.lineType,
            defined: defined,
            renderKeyFn: annotatedSettings.renderKeyFn,
            ariaLabel: lineAriaLabel,
            axesData: generatedAxes,
            behavior: general_1.createLines
        },
        summaries: {
            accessibleTransform: function (data, i) { return (__assign(__assign({}, data[i]), { type: "frame-hover" })); },
            data: projectedSummaries,
            styleFn: summaryStyleFn,
            classFn: summaryClassFn,
            renderMode: summaryRenderModeFn,
            canvasRender: dataFunctions_1.stringToFn(canvasSummaries, undefined, true),
            customMark: customSummaryMark,
            type: annotatedSettings.summaryType,
            renderKeyFn: annotatedSettings.renderKeyFn,
            behavior: general_1.createSummaries
        },
        points: {
            accessibleTransform: function (data, i) { return (__assign({ type: "frame-hover" }, (data[i].data || data[i]))); },
            data: projectedPoints,
            styleFn: dataFunctions_1.stringToFn(pointStyle, emptyObjectReturnFunction, true),
            classFn: dataFunctions_1.stringToFn(pointClass, emptyStringReturnFunction, true),
            renderMode: dataFunctions_1.stringToFn(pointRenderMode, undefined, true),
            canvasRender: dataFunctions_1.stringToFn(canvasPoints, undefined, true),
            customMark: customPointMark,
            renderKeyFn: annotatedSettings.renderKeyFn,
            showLinePoints: showLinePoints,
            behavior: general_1.createPoints
        }
    };
    if (xExtentSettings.onChange &&
        prevState.calculatedXExtent.join(",") !== calculatedXExtent.join(",")) {
        xExtentSettings.onChange(calculatedXExtent);
    }
    if (yExtentSettings.onChange &&
        prevState.calculatedYExtent.join(",") !== calculatedYExtent.join(",")) {
        yExtentSettings.onChange(calculatedYExtent);
    }
    var overlay = undefined;
    if (useSummariesAsInteractionLayer && projectedSummaries) {
        overlay = general_1.createSummaries({
            xScale: xScale,
            yScale: yScale,
            data: projectedSummaries
        }).map(function (m, i) { return (__assign(__assign({}, m.props), { style: { fillOpacity: 0 }, overlayData: projectedSummaries && projectedSummaries[i] // luckily createSummaries is a map fn
         })); });
    }
    return {
        lineData: currentProps.lines,
        pointData: currentProps.points,
        summaryData: currentProps.summaries,
        dataVersion: currentProps.dataVersion,
        projectedLines: projectedLines,
        projectedPoints: projectedPoints,
        projectedSummaries: projectedSummaries,
        canvasDrawing: canvasDrawing,
        fullDataset: fullDataset,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        axesData: generatedAxes,
        axes: axes,
        axesTickLines: axesTickLines,
        renderNumber: prevState.renderNumber + 1,
        xScale: xScale,
        yScale: yScale,
        xAccessor: annotatedSettings.xAccessor,
        yAccessor: annotatedSettings.yAccessor,
        xExtent: [
            xExtent[0] === undefined ? calculatedXExtent[0] : xExtent[0],
            xExtent[1] === undefined ? calculatedXExtent[1] : xExtent[1]
        ],
        yExtent: [
            yExtent[0] === undefined ? calculatedYExtent[0] : yExtent[0],
            yExtent[1] === undefined ? calculatedYExtent[1] : yExtent[1]
        ],
        calculatedXExtent: calculatedXExtent,
        calculatedYExtent: calculatedYExtent,
        margin: margin,
        legendSettings: legendSettings,
        areaAnnotations: areaAnnotations,
        xyFrameRender: xyFrameRender,
        size: size,
        annotatedSettings: annotatedSettings,
        overlay: overlay,
        props: currentProps
    };
};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationCallout;

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

var _ConnectorLine = _interopRequireDefault(__webpack_require__(116));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationCallout(props) {
  var className = (0, _classnames.default)("callout", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    className: className
  }), _ConnectorLine.default, {
    lineType: "horizontal"
  });
}

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
var Annotation_1 = __importDefault(__webpack_require__(49));
var AnnotationCalloutCircle_1 = __importDefault(__webpack_require__(125));
var AnnotationBracket_1 = __importDefault(__webpack_require__(301));
var AnnotationXYThreshold_1 = __importDefault(__webpack_require__(173));
var d3_hierarchy_1 = __webpack_require__(98);
var d3_array_1 = __webpack_require__(3);
var pieceDrawing_1 = __webpack_require__(84);
var baseRules_1 = __webpack_require__(51);
var SpanOrDiv_1 = __importDefault(__webpack_require__(41));
var multiAccessorUtils_1 = __webpack_require__(69);
var d3_shape_1 = __webpack_require__(18);
var general_1 = __webpack_require__(85);
var TooltipPositioner_1 = __importDefault(__webpack_require__(124));
var derivePieceValue = function (accessor, piece) {
    var pieceVal = accessor(piece);
    return pieceVal && pieceVal.toString && pieceVal.toString() || pieceVal;
};
function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;
    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
    };
}
function pieContentGenerator(_a) {
    var column = _a.column, useSpans = _a.useSpans;
    return (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" },
        React.createElement("p", { key: "or-annotation-1" }, column.name),
        React.createElement("p", { key: "or-annotation-2" }, (column.pct * 100).toFixed(0) + "%")));
}
function arcBracket(_a) {
    var x = _a.x, y = _a.y, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle, inset = _a.inset, outset = _a.outset, _b = _a.curly, curly = _b === void 0 ? true : _b;
    var start = polarToCartesian(x, y, radius + outset, endAngle);
    var end = polarToCartesian(x, y, radius + outset, startAngle);
    var innerStart = polarToCartesian(x, y, radius + outset - inset, endAngle);
    var innerEnd = polarToCartesian(x, y, radius + outset - inset, startAngle);
    var angleSize = endAngle - startAngle;
    var largeArcFlag = angleSize <= 180 ? "0" : "1";
    var d;
    if (curly) {
        var curlyOffset = Math.min(10, angleSize / 4);
        var middleLeft = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 + curlyOffset);
        var middle = polarToCartesian(x, y, radius + outset + 10, (startAngle + endAngle) / 2);
        var middleRight = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 - curlyOffset);
        d = [
            "M",
            innerStart.x,
            innerStart.y,
            "L",
            start.x,
            start.y,
            "A",
            radius + outset,
            radius + outset,
            0,
            0,
            0,
            middleLeft.x,
            middleLeft.y,
            "A",
            radius + outset,
            radius + outset,
            1,
            0,
            1,
            middle.x,
            middle.y,
            "A",
            radius + outset,
            radius + outset,
            1,
            0,
            1,
            middleRight.x,
            middleRight.y,
            "A",
            radius + outset,
            radius + outset,
            0,
            0,
            0,
            end.x,
            end.y,
            "L",
            innerEnd.x,
            innerEnd.y
        ].join(" ");
    }
    else {
        d = [
            "M",
            innerStart.x,
            innerStart.y,
            "L",
            start.x,
            start.y,
            "A",
            radius + outset,
            radius + outset,
            0,
            largeArcFlag,
            0,
            end.x,
            end.y,
            "L",
            innerEnd.x,
            innerEnd.y
        ].join(" ");
    }
    var midAngle = (startAngle + endAngle) / 2;
    var textOffset, largeTextArcFlag, finalTextEnd, finalTextStart, arcFlip;
    var lowerArc = midAngle > 90 && midAngle < 270;
    if (lowerArc) {
        textOffset = 12;
        largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        arcFlip = 0;
    }
    else {
        largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        textOffset = 5;
        arcFlip = 1;
    }
    textOffset += curly ? 10 : 0;
    var textStart = polarToCartesian(x, y, radius + outset + textOffset, endAngle);
    var textEnd = polarToCartesian(x, y, radius + outset + textOffset, startAngle);
    if (lowerArc) {
        finalTextStart = textStart;
        finalTextEnd = textEnd;
    }
    else {
        finalTextStart = textEnd;
        finalTextEnd = textStart;
    }
    var textD = [
        "M",
        finalTextStart.x,
        finalTextStart.y,
        "A",
        radius + outset + textOffset,
        radius + outset + textOffset,
        arcFlip,
        largeTextArcFlag,
        arcFlip,
        finalTextEnd.x,
        finalTextEnd.y
    ].join(" ");
    return { arcPath: d, textArcPath: textD };
}
exports.getColumnScreenCoordinates = function (_a) {
    var d = _a.d, projectedColumns = _a.projectedColumns, oAccessor = _a.oAccessor, summaryType = _a.summaryType, type = _a.type, projection = _a.projection, adjustedPosition = _a.adjustedPosition, adjustedSize = _a.adjustedSize;
    var column = typeof d.column === "object" ? d.column :
        projectedColumns[d.facetColumn] ||
            projectedColumns[multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d)];
    if (!column) {
        return { coordinates: [0, 0], pieces: undefined, column: undefined };
    }
    var pieces = column.pieceData || column.pieces;
    var positionValue = (summaryType.type && summaryType.type !== "none") ||
        ["swarm", "point", "clusterbar", "timeline"].find(function (p) { return p === type.type; })
        ? d3_array_1.max(pieces.map(function (p) { return p.scaledValue; }))
        : projection === "horizontal"
            ? d3_array_1.max(pieces.map(function (p) { return p.value >= 0 ? p.scaledValue + p.bottom : p.bottom; }))
            : d3_array_1.min(pieces.map(function (p) { return p.value >= 0 ? p.bottom - p.scaledValue : p.bottom; }));
    var xPosition = column.middle + adjustedPosition[0];
    var yPosition = projection === "horizontal"
        ? adjustedSize[0] - positionValue
        : (summaryType.type && summaryType.type !== "none") ||
            ["swarm", "point", "clusterbar", , "timeline"].find(function (p) { return p === type.type; })
            ? adjustedSize[1] - positionValue
            : positionValue;
    yPosition += 10;
    if (projection === "horizontal") {
        yPosition = column.middle;
        xPosition = positionValue + adjustedPosition[0];
    }
    else if (projection === "radial") {
        var pieArc = column.pieArc;
        var translate = pieArc.translate, outerPoint = pieArc.outerPoint, centroid = pieArc.centroid;
        xPosition = (centroid[0] + outerPoint[0]) / 2 + translate[0];
        yPosition = (centroid[1] + outerPoint[1]) / 2 + translate[1];
    }
    return { coordinates: [xPosition, yPosition], pieces: pieces, column: column };
};
exports.svgHighlightRule = function (_a) {
    var d = _a.d, pieceIDAccessor = _a.pieceIDAccessor, orFrameRender = _a.orFrameRender, oAccessor = _a.oAccessor;
    var thisID = pieceIDAccessor(d);
    var thisO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d);
    var pieces = orFrameRender.pieces;
    var styleFn = pieces.styleFn;
    var foundPieces = (pieces &&
        pieces.data
            .filter(function (p) {
            return ((thisID === undefined ||
                pieceIDAccessor(__assign(__assign({}, p.piece), p.piece.data)) === thisID) &&
                (thisO === undefined ||
                    multiAccessorUtils_1.findFirstAccessorValue(oAccessor, p.piece.data) === thisO));
        })
            .map(function (p, q) {
            var styleObject = {
                style: styleFn(__assign(__assign({}, p.piece), p.piece.data))
            };
            if (d.style && typeof d.style === "function") {
                styleObject = {
                    style: __assign(__assign({}, styleObject), d.style(__assign(__assign({}, p.piece), p.piece.data)))
                };
            }
            else if (d.style) {
                styleObject = { style: __assign(__assign({}, styleObject), d.style) };
            }
            var styledD = __assign(__assign({}, p.renderElement), styleObject);
            var className = "highlight-annotation " + ((d.class &&
                typeof d.class === "function" &&
                d.class(p.piece.data, q)) ||
                (d.class && d.class) ||
                "");
            if (React.isValidElement(p.renderElement)) {
                return React.cloneElement(p.renderElement, __assign(__assign({}, styleObject), { className: className }));
            }
            return (React.createElement(semiotic_mark_1.Mark, __assign({ fill: "none", stroke: "black", strokeWidth: "2px", key: "highlight-piece-" + q }, styledD, { className: className })));
        })) ||
        [];
    return __spread(foundPieces);
};
exports.findIDPiece = function (pieceIDAccessor, oColumn, d) {
    var foundIDValue = pieceIDAccessor(d);
    var pieceID = foundIDValue === "" && d.rName ? d.rName : foundIDValue;
    var basePieces = oColumn &&
        oColumn.pieceData.filter(function (r) { return r.rName === pieceID || pieceIDAccessor(r.data) === pieceID; });
    if (pieceID === "" ||
        basePieces === undefined ||
        basePieces === false ||
        basePieces.length !== 1)
        return d;
    var basePiece = basePieces[0];
    var reactAnnotationProps = [
        "type",
        "label",
        "note",
        "connector",
        "disabled",
        "color",
        "subject"
    ];
    if (basePiece) {
        reactAnnotationProps.forEach(function (prop) {
            if (d[prop])
                basePiece[prop] = d[prop];
        });
    }
    return basePiece;
};
exports.screenProject = function (_a) {
    var p = _a.p, adjustedSize = _a.adjustedSize, rScale = _a.rScale, oColumn = _a.oColumn, rAccessor = _a.rAccessor, idPiece = _a.idPiece, projection = _a.projection, rScaleType = _a.rScaleType;
    var basePValue = multiAccessorUtils_1.findFirstAccessorValue(rAccessor, p) || p.value;
    var pValue = Array.isArray(basePValue) ? Math.max.apply(Math, __spread(basePValue)) : basePValue;
    var o;
    if (oColumn) {
        o = oColumn.middle;
    }
    else {
        o = 0;
    }
    if (oColumn && projection === "radial") {
        return pieceDrawing_1.pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], oColumn.pct_middle, idPiece && (idPiece.x || idPiece.scaledValue)
            ? idPiece.x / 2 || (idPiece.bottom + idPiece.scaledValue / 2) / 2
            : pValue / 2);
    }
    if (projection === "horizontal") {
        return [
            idPiece && idPiece.scaledEndValue ? idPiece.scaledEndValue :
                idPiece && idPiece.scaledValue
                    ? (idPiece.value >= 0 ? idPiece.bottom + idPiece.scaledValue : idPiece.bottom)
                    : rScale(pValue),
            o
        ];
    }
    var newScale = rScaleType
        .copy()
        .domain(rScale.domain())
        .range(rScale.range().reverse());
    return [
        o,
        idPiece && (idPiece.x || idPiece.scaledValue)
            ? idPiece.y === undefined
                ? (idPiece.value >= 0 ? idPiece.bottom - idPiece.scaledValue
                    : idPiece.bottom)
                : idPiece.y
            : newScale(pValue)
    ];
};
exports.svgORRule = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates, projection = _a.projection;
    return (React.createElement(semiotic_mark_1.Mark, { markType: "text", key: d.label + "annotationtext" + i, forceUpdate: true, x: screenCoordinates[0] + (projection === "horizontal" ? 10 : 0), y: screenCoordinates[1] + (projection === "vertical" ? 10 : 0), className: "annotation annotation-or-label " + (d.className || ""), textAnchor: "middle" }, d.label));
};
exports.basicReactAnnotationRule = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates;
    var noteData = Object.assign({
        dx: 0,
        dy: 0,
        note: { label: d.label, orientation: d.orientation, align: d.align },
        connector: { end: "arrow" }
    }, d, {
        x: screenCoordinates[0],
        y: screenCoordinates[1],
        type: typeof d.type === "function" ? d.type : undefined,
        screenCoordinates: screenCoordinates
    });
    if (d.fixedX)
        noteData.x = d.fixedX;
    if (d.fixedY)
        noteData.y = d.fixedY;
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgEncloseRule = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates;
    var circle = d3_hierarchy_1.packEnclose(screenCoordinates.map(function (p) { return ({ x: p[0], y: p[1], r: 2 }); }));
    return baseRules_1.circleEnclosure({ d: d, i: i, circle: circle });
};
exports.svgRRule = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates, rScale = _a.rScale, rAccessor = _a.rAccessor, adjustedSize = _a.adjustedSize, adjustedPosition = _a.adjustedPosition, projection = _a.projection;
    var x, y, xPosition, yPosition, subject, dx, dy;
    if (projection === "radial") {
        return (React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: Object.assign({
                dx: 50,
                dy: 50,
                note: { label: d.label },
                connector: { end: "arrow" }
            }, d, {
                type: AnnotationCalloutCircle_1.default,
                subject: {
                    radius: rScale(multiAccessorUtils_1.findFirstAccessorValue(rAccessor, d)) / 2,
                    radiusPadding: 0
                },
                x: adjustedSize[0] / 2,
                y: adjustedSize[1] / 2
            }) }));
    }
    else if (projection === "horizontal") {
        dx = 50;
        dy = 50;
        yPosition = d.offset || i * 25;
        x = screenCoordinates[0];
        y = yPosition;
        subject = {
            x: x,
            y1: 0,
            y2: adjustedSize[1] + adjustedPosition[1]
        };
    }
    else {
        dx = 50;
        dy = -20;
        xPosition = d.offset || i * 25;
        y = screenCoordinates[1];
        x = xPosition;
        subject = {
            y: y,
            x1: 0,
            x2: adjustedSize[0] + adjustedPosition[0]
        };
    }
    var noteData = Object.assign({
        dx: dx,
        dy: dy,
        note: { label: d.label },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationXYThreshold_1.default,
        x: x,
        y: y,
        subject: subject
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgCategoryRule = function (_a) {
    var projection = _a.projection, d = _a.d, i = _a.i, categories = _a.categories, adjustedSize = _a.adjustedSize;
    var _b = d.bracketType, bracketType = _b === void 0 ? "curly" : _b, _c = d.position, position = _c === void 0 ? projection === "vertical" ? "top" : "left" : _c, _d = d.depth, depth = _d === void 0 ? 30 : _d, _e = d.offset, offset = _e === void 0 ? 0 : _e, _f = d.padding, padding = _f === void 0 ? 0 : _f;
    var actualCategories = Array.isArray(d.categories)
        ? d.categories
        : [d.categories];
    var cats = actualCategories.map(function (c) { return categories[c]; });
    if (projection === "radial") {
        var arcPadding_1 = padding / adjustedSize[1];
        var leftX = d3_array_1.min(cats.map(function (p) { return p.pct_start + p.pct_padding / 2 + arcPadding_1 / 2; }));
        var rightX = d3_array_1.max(cats.map(function (p) { return p.pct_start + p.pct - p.pct_padding / 2 - arcPadding_1 / 2; }));
        var chartSize = Math.min(adjustedSize[0], adjustedSize[1]) / 2;
        var centerX = adjustedSize[0] / 2;
        var centerY = adjustedSize[1] / 2;
        var _g = arcBracket({
            x: 0,
            y: 0,
            radius: chartSize,
            startAngle: leftX * 360,
            endAngle: rightX * 360,
            inset: depth,
            outset: offset,
            curly: bracketType === "curly"
        }), arcPath = _g.arcPath, textArcPath = _g.textArcPath;
        var textPathID = "text-path-" + i + "-" + Math.random();
        return (React.createElement("g", { className: "category-annotation annotation", transform: "translate(" + centerX + "," + centerY + ")" },
            React.createElement("path", { d: arcPath, fill: "none", stroke: "black" }),
            React.createElement("path", { id: textPathID, d: textArcPath, style: { display: "none" } }),
            React.createElement("text", { "font-size": "12.5" },
                React.createElement("textPath", { startOffset: "50%", textAnchor: "middle", xlinkHref: "#" + textPathID }, d.label))));
    }
    else {
        var leftX = d3_array_1.min(cats.map(function (p) { return p.x; }));
        var rightX = d3_array_1.max(cats.map(function (p) { return p.x + p.width; }));
        if (projection === "vertical") {
            var yPosition = position === "top" ? 0 : adjustedSize[1];
            yPosition += position === "top" ? -offset : offset;
            var noteData = {
                type: AnnotationBracket_1.default,
                y: yPosition,
                x: leftX - padding,
                note: {
                    title: d.title || d.label,
                    label: d.title ? d.label : undefined
                },
                subject: {
                    type: bracketType,
                    width: rightX - leftX + padding * 2,
                    depth: position === "top" ? -depth : depth
                }
            };
            return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
        }
        else if (projection === "horizontal") {
            var yPosition = position === "left" ? 0 : adjustedSize[0];
            yPosition += position === "left" ? -offset : offset;
            var noteData = {
                type: AnnotationBracket_1.default,
                x: yPosition,
                y: leftX - padding,
                note: {
                    title: d.title || d.label,
                    label: d.title ? d.label : undefined
                },
                subject: {
                    type: bracketType,
                    height: rightX - leftX + padding * 2,
                    depth: position === "left" ? -depth : depth
                }
            };
            return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
        }
    }
};
exports.htmlFrameHoverRule = function (_a) {
    var d = _a.d, i = _a.i, rAccessor = _a.rAccessor, oAccessor = _a.oAccessor, projection = _a.projection, tooltipContent = _a.tooltipContent, optimizeCustomTooltipPosition = _a.optimizeCustomTooltipPosition, useSpans = _a.useSpans, pieceIDAccessor = _a.pieceIDAccessor, projectedColumns = _a.projectedColumns, adjustedSize = _a.adjustedSize, rScale = _a.rScale, type = _a.type, rScaleType = _a.rScaleType;
    tooltipContent =
        tooltipContent === "pie"
            ? function () {
                return pieContentGenerator({
                    column: d.column,
                    useSpans: useSpans
                });
            }
            : tooltipContent;
    //To string because React gives a DOM error if it gets a date
    var contentFill;
    var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d) || d.column;
    var oColumn = projectedColumns[pO];
    var idPiece = exports.findIDPiece(pieceIDAccessor, oColumn, d);
    if (!idPiece) {
        return null;
    }
    var screenCoordinates = ((type.type === "clusterbar" ||
        type.type === "point" ||
        type.type === "swarm") &&
        d.x !== undefined &&
        d.y !== undefined) ||
        d.isSummaryData
        ? [d.x, d.y]
        : exports.screenProject({
            p: d,
            adjustedSize: adjustedSize,
            rScale: rScale,
            oColumn: oColumn,
            rAccessor: rAccessor,
            idPiece: idPiece,
            projection: projection,
            rScaleType: rScaleType
        });
    if (d.isSummaryData) {
        var summaryContent_1 = d.label;
        if (d.pieces && d.pieces.length !== 0) {
            if (d.pieces.length === 1) {
                summaryContent_1 = [];
                rAccessor.forEach(function (actualRAccessor) {
                    summaryContent_1.push(actualRAccessor(d.pieces[0].data));
                });
            }
            else {
                summaryContent_1 = [];
                rAccessor.forEach(function (actualRAccessor) {
                    var pieceData = d3_array_1.extent(d.pieces.map(function (p) { return p.data; }).map(actualRAccessor));
                    summaryContent_1.push("From " + pieceData[0] + " to " + pieceData[1]);
                });
            }
        }
        var summaryLabel = React.createElement("p", { key: "html-annotation-content-2" }, summaryContent_1);
        contentFill = [
            React.createElement("p", { key: "html-annotation-content-1" }, d.key),
            summaryLabel,
            React.createElement("p", { key: "html-annotation-content-3" }, d.value)
        ];
    }
    else if (d.data) {
        contentFill = [];
        oAccessor.forEach(function (actualOAccessor, i) {
            if (idPiece.data) {
                var pieceOVal = derivePieceValue(actualOAccessor, idPiece.data);
                contentFill.push(React.createElement("p", { key: "html-annotation-content-o-" + i }, pieceOVal));
            }
        });
        rAccessor.forEach(function (actualRAccessor, i) {
            if (idPiece.data) {
                var pieceRVal = derivePieceValue(actualRAccessor, idPiece.data);
                contentFill.push(React.createElement("p", { key: "html-annotation-content-r-" + i }, pieceRVal));
            }
        });
    }
    else if (d.label) {
        contentFill = d.label;
    }
    var content = (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" }, contentFill));
    if (d.type === "frame-hover" && tooltipContent && idPiece) {
        var tooltipContentArgs = __assign(__assign({}, idPiece), idPiece.data);
        content = optimizeCustomTooltipPosition ? (React.createElement(TooltipPositioner_1.default, { tooltipContent: tooltipContent, tooltipContentArgs: tooltipContentArgs })) : tooltipContent(tooltipContentArgs);
    }
    return (React.createElement(SpanOrDiv_1.default, { span: useSpans, key: "xylabel-" + i, className: "annotation annotation-or-label " + projection + " " + (d.className ||
            ""), style: {
            position: "absolute",
            top: screenCoordinates[1] + "px",
            left: screenCoordinates[0] + "px"
        } }, content));
};
exports.htmlColumnHoverRule = function (_a) {
    var d = _a.d, i = _a.i, summaryType = _a.summaryType, oAccessor = _a.oAccessor, type = _a.type, adjustedPosition = _a.adjustedPosition, adjustedSize = _a.adjustedSize, projection = _a.projection, tooltipContent = _a.tooltipContent, optimizeCustomTooltipPosition = _a.optimizeCustomTooltipPosition, useSpans = _a.useSpans, projectedColumns = _a.projectedColumns;
    //we need to ignore negative pieces to make sure the hover behavior populates on top of the positive bar
    var _b = exports.getColumnScreenCoordinates({
        d: d,
        projectedColumns: projectedColumns,
        oAccessor: oAccessor,
        summaryType: summaryType,
        type: type,
        projection: projection,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize
    }), _c = __read(_b.coordinates, 2), xPosition = _c[0], yPosition = _c[1], pieces = _b.pieces, column = _b.column;
    if (column === undefined) {
        return null;
    }
    //To string because React gives a DOM error if it gets a date
    var oContent = [];
    oAccessor.forEach(function (actualOAccessor, i) {
        if (pieces[0].data) {
            var pieceOVal = derivePieceValue(actualOAccessor, pieces[0].data);
            oContent.push(React.createElement("p", { key: "or-annotation-o-" + i }, pieceOVal));
        }
    });
    var content = (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" },
        oContent,
        React.createElement("p", { key: "or-annotation-2" }, d3_array_1.sum(pieces.map(function (p) { return p.value; }).filter(function (p) { return p > 0; })))));
    if (d.type === "column-hover" && tooltipContent) {
        if (tooltipContent === "pie") {
            tooltipContent = pieContentGenerator;
        }
        var tooltipContentArgs = __assign(__assign({}, d), { pieces: pieces.map(function (p) { return p.data; }), column: column,
            oAccessor: oAccessor });
        content = optimizeCustomTooltipPosition ? (React.createElement(TooltipPositioner_1.default, { tooltipContent: tooltipContent, tooltipContentArgs: tooltipContentArgs })) : tooltipContent(tooltipContentArgs);
    }
    else if (d.label) {
        content = (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" }, d.label));
    }
    return (React.createElement(SpanOrDiv_1.default, { span: useSpans, key: "orlabel-" + i, className: "annotation annotation-or-label " + projection + " " + (d.className ||
            ""), style: {
            position: "absolute",
            top: yPosition + "px",
            left: xPosition + "px"
        } }, content));
};
exports.svgRectEncloseRule = function (_a) {
    var d = _a.d, i = _a.i, screenCoordinates = _a.screenCoordinates;
    var bboxNodes = screenCoordinates.map(function (p) {
        return {
            x0: p.x0 = p[0],
            x1: p.x1 = p[0],
            y0: p.y0 = p[1],
            y1: p.y1 = p[1]
        };
    });
    return baseRules_1.rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};
exports.svgOrdinalLine = function (_a) {
    var screenCoordinates = _a.screenCoordinates, d = _a.d, voronoiHover = _a.voronoiHover;
    var lineGenerator = d3_shape_1.line()
        .x(function (d) { return d[0]; })
        .y(function (d) { return d[1]; });
    if (d.curve) {
        var interpolator = general_1.curveHash[d.curve] || d.curve;
        lineGenerator.curve(interpolator);
    }
    var lineStyle = typeof d.lineStyle === "function" ? d.lineStyle(d) : d.lineStyle || {};
    return (React.createElement("g", { key: "ordinal-line-annotation" },
        React.createElement("path", { stroke: "black", fill: "none", style: lineStyle, d: lineGenerator(screenCoordinates) }),
        (d.points || d.interactive) &&
            screenCoordinates.map(function (p, q) {
                var pointStyle = typeof d.pointStyle === "function"
                    ? d.pointStyle(d.coordinates[q], q)
                    : d.pointStyle || {};
                return (React.createElement("g", { transform: "translate(" + p[0] + "," + p[1] + ")", key: "ordinal-line-point-" + q },
                    d.points && (React.createElement("circle", { style: pointStyle, r: d.radius || 5, fill: "black" })),
                    d.interactive && (React.createElement("circle", { style: { pointerEvents: "all" }, r: d.hoverRadius || 15, opacity: 0, onMouseEnter: function () {
                            return voronoiHover(__assign(__assign({ type: "frame-hover" }, d.coordinates[q]), { data: d.coordinates[q] }));
                        }, onMouseOut: function () { return voronoiHover(); } }))));
            })));
};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnnotationBracket;

var _SubjectBracket = _interopRequireDefault(__webpack_require__(302));

var _BracketNote = _interopRequireDefault(__webpack_require__(304));

var _classnames = _interopRequireDefault(__webpack_require__(31));

var _Type = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function AnnotationBracket(props) {
  var className = (0, _classnames.default)("bracket", props.className);
  return (0, _Type.default)(_objectSpread({}, props, {
    disable: ["connector"],
    className: className
  }), null, null, _SubjectBracket.default, {
    depth: 20
  }, _BracketNote.default);
}

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(0));

var _bracket = _interopRequireDefault(__webpack_require__(303));

var _Subject2 = _interopRequireDefault(__webpack_require__(50));

var _propTypes = _interopRequireDefault(__webpack_require__(1));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SubjectBracket =
/*#__PURE__*/
function (_Subject) {
  _inherits(SubjectBracket, _Subject);

  function SubjectBracket() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, SubjectBracket);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SubjectBracket)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", "SubjectBracket");

    return _this;
  }

  _createClass(SubjectBracket, [{
    key: "getComponents",
    value: function getComponents(_ref) {
      var height = _ref.height,
          width = _ref.width,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 20 : _ref$depth,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? "square" : _ref$type,
          editMode = _ref.editMode;
      var components = (0, _bracket.default)({
        height: height,
        width: width,
        depth: depth,
        type: type,
        editMode: editMode
      });
      var handleKeys = {
        height: height,
        width: width,
        depth: depth
      };

      components.handleFunction = function (h, data) {
        if (h.key === "depth") {
          return {
            depth: depth + data["oDelta".concat(h.type)]
          };
        } else {
          return _defineProperty({}, h.key, handleKeys[h.key] + data[h.key === "width" ? "oDeltaX" : "oDeltaY"]);
        }
      };

      return components;
    }
  }]);

  return SubjectBracket;
}(_Subject2.default);

exports.default = SubjectBracket;
SubjectBracket.propTypes = {
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  depth: _propTypes.default.number,
  editMode: _propTypes.default.bool
};

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Builder = __webpack_require__(21);

//This curly brace function was
//made by Alex Hornbake
//http://bl.ocks.org/alexhornbake/6005176
function makeCurlyBrace(x1, y1, x2, y2, w, q) {
  //Calculate unit vector
  var dx = x1 - x2;
  var dy = y1 - y2;
  var len = Math.sqrt(dx * dx + dy * dy);
  dx = dx / len;
  dy = dy / len;

  //Calculate Control Points of path,
  var qx1 = x1 + q * w * dy;
  var qy1 = y1 - q * w * dx;
  var qx2 = x1 - 0.25 * len * dx + (1 - q) * w * dy;
  var qy2 = y1 - 0.25 * len * dy - (1 - q) * w * dx;
  var tx1 = x1 - 0.5 * len * dx + w * dy;
  var ty1 = y1 - 0.5 * len * dy - w * dx;
  var qx3 = x2 + q * w * dy;
  var qy3 = y2 - q * w * dx;
  var qx4 = x1 - 0.75 * len * dx + (1 - q) * w * dy;
  var qy4 = y1 - 0.75 * len * dy - (1 - q) * w * dx;

  return "M " + x1 + " " + y1 + " Q " + qx1 + " " + qy1 + " " + qx2 + " " + qy2 + " T " + tx1 + " " + ty1 + " M " + x2 + " " + y2 + " Q " + qx3 + " " + qy3 + " " + qx4 + " " + qy4 + " T " + tx1 + " " + ty1;
}

exports.default = function (_ref) {
  var height = _ref.height,
      width = _ref.width,
      depth = _ref.depth,
      type = _ref.type,
      editMode = _ref.editMode;

  var handles = [];
  var data = void 0;
  var bracket = void 0;

  var w = 0,
      h = 0;

  if (height && height > 0) {
    h = height;
  } else if (width && width > 0) {
    w = width;
  }

  if (type === "square") {
    if (h) {
      data = [[0, 0], [depth, 0], [depth, h], [0, h]];
    } else if (w) {
      data = [[0, 0], [0, depth], [w, depth], [w, 0]];
    }
    bracket = (0, _Builder.lineBuilder)({ data: data, className: "subject" });
  } else if (type === "curly") {
    bracket = (0, _Builder.pathBuilder)({
      d: makeCurlyBrace(0, 0, w, h, h > 0 || w < 0 ? -depth : depth, 0.55),
      className: "subject"
    });
  }

  if (editMode) {
    handles = [{
      x: h ? depth : w / 2,
      y: h ? h / 2 : depth,
      key: "depth",
      type: h ? "X" : "Y"
    }, {
      x: w || 0,
      y: h || 0,
      key: h ? "height" : "width"
    }];
  }

  bracket.attrs["fill-opacity"] = 0.1;
  return { components: [bracket], handles: handles };
};

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BracketNote;

var _react = _interopRequireDefault(__webpack_require__(0));

var _Note = _interopRequireDefault(__webpack_require__(164));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function BracketNote(_ref) {
  var width = _ref.width,
      height = _ref.height,
      depth = _ref.depth,
      rest = _objectWithoutProperties(_ref, ["width", "height", "depth"]);

  var dx = rest.dx,
      orientation,
      align = "middle",
      dy = rest.dy;

  if (height) {
    if (!dy) dy = height / 2;
    if (!dx) dx = depth;
    orientation = "leftRight";
  } else if (width) {
    if (!dx) dx = width / 2;
    if (!dy) dy = depth;
    orientation = "topBottom";
  }

  return _react.default.createElement(_Note.default, _extends({
    align: align,
    orientation: orientation,
    padding: 10
  }, rest, {
    editMode: false,
    dx: dx,
    dy: dy
  }));
}

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_collection_1 = __webpack_require__(27);
var d3_array_1 = __webpack_require__(3);
var d3_shape_1 = __webpack_require__(18);
var frameFunctions_1 = __webpack_require__(33);
var pieceDrawing_1 = __webpack_require__(84);
var summaryLayouts_1 = __webpack_require__(123);
var pieceLayouts_1 = __webpack_require__(306);
var dataFunctions_1 = __webpack_require__(52);
var functions_1 = __webpack_require__(129);
var d3_scale_1 = __webpack_require__(24);
var layoutHash = {
    clusterbar: pieceLayouts_1.clusterBarLayout,
    bar: pieceLayouts_1.barLayout,
    point: pieceLayouts_1.pointLayout,
    swarm: pieceLayouts_1.swarmLayout,
    timeline: pieceLayouts_1.timelineLayout
};
var midMod = function (d) { return (d.middle ? d.middle : 0); };
var zeroFunction = functions_1.genericFunction(0);
var twoPI = Math.PI * 2;
var naturalLanguageTypes = {
    bar: { items: "bar", chart: "bar chart" },
    clusterbar: { items: "bar", chart: "grouped bar chart" },
    swarm: { items: "point", chart: "swarm plot" },
    point: { items: "point", chart: "point plot" },
    timeline: { items: "bar", chart: "timeline" }
};
exports.calculateMappedMiddles = function (oScale, middleMax, padding) {
    var oScaleDomainValues = oScale.domain();
    var mappedMiddles = {};
    oScaleDomainValues.forEach(function (p, q) {
        var base = oScale(p) - padding;
        var next = oScaleDomainValues[q + 1]
            ? oScale(oScaleDomainValues[q + 1])
            : middleMax;
        var diff = (next - base) / 2;
        mappedMiddles[p] = base + diff;
    });
    return mappedMiddles;
};
exports.calculateOrdinalFrame = function (currentProps, currentState) {
    var oLabels;
    var projectedColumns = {};
    var _a = currentProps.oPadding, padding = _a === void 0 ? 0 : _a, baseSummaryType = currentProps.summaryType, baseType = currentProps.type, baseConnectorType = currentProps.connectorType, baseOAccessor = currentProps.oAccessor, baseRAccessor = currentProps.rAccessor, baseConnectorStyle = currentProps.connectorStyle, baseStyle = currentProps.style, baseRExtent = currentProps.rExtent, oSort = currentProps.oSort, basePieceClass = currentProps.pieceClass, baseSummaryStyle = currentProps.summaryStyle, baseSummaryClass = currentProps.summaryClass, dynamicColumnWidth = currentProps.dynamicColumnWidth, projection = currentProps.projection, customHoverBehavior = currentProps.customHoverBehavior, customClickBehavior = currentProps.customClickBehavior, customDoubleClickBehavior = currentProps.customDoubleClickBehavior, size = currentProps.size, pixelColumnWidth = currentProps.pixelColumnWidth, baseTitle = currentProps.title, oLabel = currentProps.oLabel, hoverAnnotation = currentProps.hoverAnnotation, pieceHoverAnnotation = currentProps.pieceHoverAnnotation, summaryHoverAnnotation = currentProps.summaryHoverAnnotation, backgroundGraphics = currentProps.backgroundGraphics, foregroundGraphics = currentProps.foregroundGraphics, oScaleType = currentProps.oScaleType, rScaleType = currentProps.rScaleType, legend = currentProps.legend, baseRenderKey = currentProps.renderKey, data = currentProps.data, baseMargin = currentProps.margin, baseOExtent = currentProps.oExtent, baseAxes = currentProps.axes, basePieceIDAccessor = currentProps.pieceIDAccessor, multiAxis = currentProps.multiAxis, _b = currentProps.baseMarkProps, baseMarkProps = _b === void 0 ? {} : _b, annotations = currentProps.annotations, sketchyRenderingEngine = currentProps.sketchyRenderingEngine;
    var summaryType = frameFunctions_1.objectifyType(baseSummaryType);
    var pieceType = frameFunctions_1.objectifyType(baseType);
    var connectorType = frameFunctions_1.objectifyType(baseConnectorType);
    var oAccessor = dataFunctions_1.stringToArrayFn(baseOAccessor, function (d) { return d.renderKey; });
    var rAccessor = dataFunctions_1.stringToArrayFn(baseRAccessor, function (d) { return d.value || 1; });
    var renderKey = dataFunctions_1.stringToFn(baseRenderKey, function (d, i) { return i; });
    var eventListenersGenerator = function () { return ({}); };
    var connectorStyle = dataFunctions_1.stringToFn(baseConnectorStyle, function () { return ({}); }, true);
    var summaryStyle = dataFunctions_1.stringToFn(baseSummaryStyle, function () { return ({}); }, true);
    var pieceStyle = dataFunctions_1.stringToFn(baseStyle, function () { return ({}); }, true);
    var pieceClass = dataFunctions_1.stringToFn(basePieceClass, function () { return ""; }, true);
    var summaryClass = dataFunctions_1.stringToFn(baseSummaryClass, function () { return ""; }, true);
    var title = typeof baseTitle === "object" &&
        !React.isValidElement(baseTitle) &&
        baseTitle !== null
        ? baseTitle
        : { title: baseTitle, orient: "top" };
    var pieceIDAccessor = dataFunctions_1.stringToFn(basePieceIDAccessor, function () { return ""; });
    var originalRAccessor = Array.isArray(baseRAccessor)
        ? baseRAccessor
        : [baseRAccessor];
    var originalOAccessor = Array.isArray(baseOAccessor)
        ? baseOAccessor
        : [baseOAccessor];
    var _c = frameFunctions_1.keyAndObjectifyBarData({
        data: data,
        renderKey: renderKey,
        oAccessor: oAccessor,
        rAccessor: rAccessor,
        originalRAccessor: originalRAccessor,
        originalOAccessor: originalOAccessor,
        multiAxis: multiAxis
    }), allData = _c.allData, multiExtents = _c.multiExtents;
    var columnOverlays;
    var prevProps = currentState.props;
    var shouldRecalculateOverlay = currentProps.data !== prevProps.data
        || currentProps.size[0] !== prevProps.size[0]
        || currentProps.size[1] !== prevProps.size[1]
        || currentProps.margin !== prevProps.margin
        || (!currentState.columnOverlays || currentState.columnOverlays.length === 0)
        || currentProps.customClickBehavior !== prevProps.customClickBehavior
        || currentProps.customDoubleClickBehavior !== prevProps.customDoubleClickBehavior
        || currentProps.customHoverBehavior !== prevProps.customHoverBehavior;
    var arrayWrappedAxis;
    if (Array.isArray(baseAxes)) {
        arrayWrappedAxis = baseAxes.map(function (axisFnOrObject) {
            return typeof axisFnOrObject === "function"
                ? axisFnOrObject({ size: currentProps.size })
                : axisFnOrObject;
        });
    }
    else if (baseAxes) {
        arrayWrappedAxis = [baseAxes].map(function (axisFnOrObject) {
            return typeof axisFnOrObject === "function"
                ? axisFnOrObject({ size: currentProps.size })
                : axisFnOrObject;
        });
    }
    if (multiExtents && baseAxes) {
        arrayWrappedAxis.forEach(function (d, i) {
            d.extentOverride = multiExtents[i];
        });
    }
    var margin = frameFunctions_1.calculateMargin({
        margin: baseMargin,
        axes: arrayWrappedAxis,
        title: title,
        oLabel: oLabel,
        projection: projection,
        size: size
    });
    var _d = frameFunctions_1.adjustedPositionSize({
        size: size,
        margin: margin,
        projection: projection
    }), adjustedPosition = _d.adjustedPosition, adjustedSize = _d.adjustedSize;
    var oExtentSettings = baseOExtent === undefined || Array.isArray(baseOExtent)
        ? { extent: baseOExtent }
        : baseOExtent;
    var calculatedOExtent = allData.reduce(function (p, c) {
        var baseOValue = c.column;
        var oValue = baseOValue !== undefined ? String(baseOValue) : baseOValue;
        if (p.indexOf(oValue) === -1) {
            p.push(oValue);
        }
        return p;
    }, []);
    var oExtent = oExtentSettings.extent || calculatedOExtent;
    if (pieceType.type === "barpercent") {
        var oExtentSums_1 = oExtent
            .map(function (d) {
            return allData
                .filter(function (p) { return String(p.column) === d; })
                .reduce(function (p, c) { return p + c.value; }, 0);
        })
            .reduce(function (p, c, i) {
            p[oExtent[i]] = c;
            return p;
        }, {});
        allData.forEach(function (d) {
            d.value =
                (oExtentSums_1[d.column] && d.value / oExtentSums_1[d.column]) || 0;
        });
        pieceType.type = "bar";
    }
    if (pixelColumnWidth) {
        if (projection === "radial") {
            console.error("pixelColumnWidth is not honored in radial mode");
        }
        else if (projection === "vertical") {
            adjustedSize[0] = oExtent.length * pixelColumnWidth;
        }
        else {
            adjustedSize[1] = oExtent.length * pixelColumnWidth;
        }
    }
    var oDomain = (projection === "vertical" && [0, adjustedSize[0]]) || [
        0,
        adjustedSize[1]
    ];
    var cwHash = oExtent.reduce(function (p, c) {
        p[c] = (1 / oExtent.length) * oDomain[1];
        p.total += p[c];
        return p;
    }, { total: 0 });
    var castOScaleType = oScaleType;
    var oScale = dynamicColumnWidth ? d3_scale_1.scaleOrdinal() : castOScaleType();
    oScale.domain(oExtent);
    var maxColumnValues;
    if (dynamicColumnWidth) {
        var columnValueCreator_1;
        if (typeof dynamicColumnWidth === "string") {
            columnValueCreator_1 = function (d) { return d3_array_1.sum(d.map(function (p) { return p.data[dynamicColumnWidth]; })); };
        }
        else {
            columnValueCreator_1 = function (d) { return dynamicColumnWidth(d.map(function (p) { return p.data; })); };
        }
        var thresholdDomain_1 = [0];
        maxColumnValues = 0;
        var columnValues_1 = [];
        oExtent.forEach(function (d) {
            var oValues = allData.filter(function (p) { return p.column === d; });
            var columnValue = columnValueCreator_1(oValues);
            columnValues_1.push(columnValue);
            maxColumnValues += columnValue;
        });
        cwHash.total = 0;
        oExtent.forEach(function (d, i) {
            var oValue = columnValues_1[i];
            var stepValue = (oValue / maxColumnValues) * (oDomain[1] - oDomain[0]);
            cwHash[d] = stepValue;
            cwHash.total += stepValue;
            if (i !== oExtent.length - 1) {
                thresholdDomain_1.push(stepValue + thresholdDomain_1[i]);
            }
        });
        oScale.range(thresholdDomain_1);
    }
    else {
        oScale.range(oDomain);
    }
    var rExtentSettings = baseRExtent === undefined || Array.isArray(baseRExtent)
        ? { extent: baseRExtent, onChange: undefined, includeAnnotations: false }
        : baseRExtent;
    var rExtent = rExtentSettings.extent;
    var subZeroRExtent = [0, 0];
    if (pieceType.type === "bar" &&
        summaryType.type &&
        summaryType.type !== "none") {
        pieceType.type = "none";
    }
    var annotationsForExtent = [];
    if (rExtentSettings.includeAnnotations && annotations) {
        rAccessor.forEach(function (actualRAccessor) {
            annotations.forEach(function (annotation, annotationIndex) {
                var r = actualRAccessor(annotation, annotationIndex);
                if (isFinite(r)) {
                    annotationsForExtent.push(r);
                }
            });
        });
    }
    if (pieceType.type === "timeline") {
        var rData = allData.map(function (d) { return d.value; });
        var leftExtent = d3_array_1.extent(rData.map(function (d) { return d[0]; }));
        var rightExtent = d3_array_1.extent(rData.map(function (d) { return d[1]; }));
        rExtent = d3_array_1.extent(__spread(leftExtent, rightExtent, annotationsForExtent));
    }
    else if (pieceType.type !== "bar") {
        rExtent = d3_array_1.extent(__spread(allData.map(function (d) { return d.value; }), annotationsForExtent));
    }
    else {
        var positiveData = allData.filter(function (d) { return d.value >= 0; });
        var negativeData = allData.filter(function (d) { return d.value < 0; });
        var nestedPositiveData = d3_collection_1.nest()
            .key(function (d) { return d.column; })
            .rollup(function (leaves) { return d3_array_1.sum(leaves.map(function (d) { return d.value; })); })
            .entries(positiveData);
        var nestedNegativeData = d3_collection_1.nest()
            .key(function (d) { return d.column; })
            .rollup(function (leaves) { return d3_array_1.sum(leaves.map(function (d) { return d.value; })); })
            .entries(negativeData);
        var positiveAnnotations = annotationsForExtent.filter(function (d) { return d > 0; });
        rExtent = [
            0,
            nestedPositiveData.length === 0 && positiveAnnotations.length === 0
                ? 0
                : Math.max(d3_array_1.max(__spread(nestedPositiveData.map(function (d) { return d.value; }), positiveAnnotations)), 0)
        ];
        var negativeAnnotations = annotationsForExtent.filter(function (d) { return d < 0; });
        subZeroRExtent = [
            0,
            nestedNegativeData.length === 0
                ? 0
                : Math.min(d3_array_1.min(__spread(nestedNegativeData.map(function (d) { return d.value; }), negativeAnnotations)), 0)
        ];
        rExtent = [subZeroRExtent[1], rExtent[1]];
    }
    if ((pieceType.type === "clusterbar" || multiAxis) && rExtent[0] > 0) {
        rExtent[0] = 0;
    }
    var calculatedRExtent = rExtent;
    if (rExtentSettings.extent &&
        rExtentSettings.extent[0] !== undefined &&
        rExtentSettings.extent[1] !== undefined) {
        rExtent = rExtentSettings.extent;
    }
    else {
        if (rExtentSettings.extent &&
            rExtentSettings.extent[1] !== undefined &&
            rExtentSettings.extent[0] === undefined) {
            rExtent[1] = rExtentSettings.extent[1];
        }
        if (rExtentSettings.extent &&
            rExtentSettings.extent[0] !== undefined &&
            rExtentSettings.extent[1] === undefined) {
            rExtent[0] = rExtentSettings.extent[0];
        }
    }
    if (currentProps.invertR ||
        (rExtentSettings.extent &&
            rExtentSettings.extent[0] > rExtentSettings.extent[1])) {
        rExtent = [rExtent[1], rExtent[0]];
    }
    var nestedPieces = {};
    d3_collection_1.nest()
        .key(function (d) { return d.column; })
        .entries(allData)
        .forEach(function (d) {
        nestedPieces[d.key] = d.values;
    });
    if (oSort !== undefined) {
        oExtent = oExtent.sort(function (a, b) {
            return oSort(a, b, nestedPieces[a].map(function (d) { return d.data; }), nestedPieces[b].map(function (d) { return d.data; }));
        });
        oScale.domain(oExtent);
    }
    var rDomain = (projection === "vertical" && [0, adjustedSize[1]]) || [
        0,
        adjustedSize[0]
    ];
    var castRScaleType = rScaleType;
    var instantiatedRScaleType = rScaleType.domain
        ? rScaleType
        : castRScaleType();
    var zeroCheck = instantiatedRScaleType(0);
    if (rExtentSettings.extent &&
        rExtentSettings.extent[0] !== undefined && (isNaN(zeroCheck) || zeroCheck === -Infinity || zeroCheck === Infinity)) {
        rExtent[0] = rExtentSettings.extent[0];
    }
    var rScale = instantiatedRScaleType
        .copy()
        .domain(rExtent)
        .range(rDomain);
    var rScaleReverse = d3_scale_1.scaleLinear()
        .domain(rDomain)
        .range(rDomain.reverse());
    var rScaleVertical = instantiatedRScaleType
        .copy()
        .domain(rExtent)
        .range(rDomain);
    var columnWidth = cwHash ? 0 : oScale.bandwidth();
    var pieceData = [];
    var mappedMiddleSize = adjustedSize[1];
    if (projection === "vertical") {
        mappedMiddleSize = adjustedSize[0];
    }
    var mappedMiddles = exports.calculateMappedMiddles(oScale, mappedMiddleSize, padding);
    pieceData = oExtent.map(function (d) { return (nestedPieces[d] ? nestedPieces[d] : []); });
    var zeroValue = projection === "vertical" ? rScaleReverse(rScale(0)) : rScale(0);
    if ((isNaN(zeroValue) || zeroValue === -Infinity || zeroValue === Infinity) && rExtentSettings.extent &&
        rExtentSettings.extent[0] !== undefined && (zeroCheck === -Infinity || zeroCheck === Infinity)) {
        zeroValue = projection === "vertical" ? rScaleReverse(rScale(rExtentSettings.extent[0])) : rScale(rExtentSettings.extent[0]);
    }
    oExtent.forEach(function (o, i) {
        projectedColumns[o] = {
            name: o,
            padding: padding,
            pieceData: pieceData[i],
            pieces: pieceData[i]
        };
        projectedColumns[o].x = oScale(o) + padding / 2;
        projectedColumns[o].y = 0;
        projectedColumns[o].middle = mappedMiddles[o] + padding / 2;
        var negativeOffset = zeroValue;
        var positiveOffset = zeroValue;
        var negativeBaseValue = 0;
        var positiveBaseValue = 0;
        projectedColumns[o].pieceData.forEach(function (piece) {
            var valPosition;
            if (pieceType.type === "timeline") {
                piece.scaledValue = rScale(piece.value[0]);
                piece.scaledEndValue = rScale(piece.value[1]);
                piece.scaledVerticalValue = rScaleVertical(piece.value[0]);
            }
            else if (pieceType.type !== "bar" &&
                pieceType.type !== "clusterbar") {
                piece.scaledValue = rScale(piece.value);
                piece.scaledVerticalValue = rScaleVertical(piece.value);
            }
            else if (pieceType.type === "clusterbar") {
                valPosition =
                    projection === "vertical"
                        ? rScaleReverse(rScale(piece.value))
                        : rScale(piece.value);
                piece.scaledValue = Math.abs(zeroValue - valPosition);
            }
            piece.x = projectedColumns[o].x;
            if (piece.value >= 0) {
                if (pieceType.type === "bar") {
                    piece.scaledValue =
                        projection === "vertical"
                            ? positiveOffset -
                                rScaleReverse(rScale(positiveBaseValue + piece.value))
                            : rScale(positiveBaseValue + piece.value) - positiveOffset;
                    positiveBaseValue += piece.value;
                }
                piece.base = zeroValue;
                piece.bottom = pieceType.type === "bar" ? positiveOffset : 0;
                piece.middle = piece.scaledValue / 2 + positiveOffset;
                positiveOffset =
                    projection === "vertical"
                        ? positiveOffset - piece.scaledValue
                        : positiveOffset + piece.scaledValue;
                piece.negative = false;
            }
            else {
                if (pieceType.type === "bar") {
                    piece.scaledValue =
                        projection === "vertical"
                            ? Math.abs(rScale(piece.value) - rScale(0))
                            : Math.abs(rScale(piece.value) - zeroValue);
                    negativeBaseValue += piece.value;
                }
                piece.base = zeroValue;
                piece.bottom = pieceType.type === "bar" ? negativeOffset : 0;
                piece.middle = negativeOffset - piece.scaledValue / 2;
                negativeOffset =
                    projection === "vertical"
                        ? negativeOffset + piece.scaledValue
                        : negativeOffset - piece.scaledValue;
                piece.negative = true;
            }
        });
        if (cwHash) {
            projectedColumns[o].width = cwHash[o] - padding;
            if (currentProps.ordinalAlign === "center") {
                if (i === 0) {
                    projectedColumns[o].x =
                        projectedColumns[o].x - projectedColumns[o].width / 2;
                    projectedColumns[o].middle =
                        projectedColumns[o].middle - projectedColumns[o].width / 2;
                }
                else {
                    projectedColumns[o].x =
                        projectedColumns[oExtent[i - 1]].x +
                            projectedColumns[oExtent[i - 1]].width;
                    projectedColumns[o].middle =
                        projectedColumns[o].x + projectedColumns[o].width / 2;
                }
            }
            projectedColumns[o].pct = cwHash[o] / cwHash.total;
            projectedColumns[o].pct_start =
                (projectedColumns[o].x - oDomain[0]) / cwHash.total;
            projectedColumns[o].pct_padding = padding / cwHash.total;
            projectedColumns[o].pct_middle =
                (projectedColumns[o].middle - oDomain[0]) / cwHash.total;
        }
        else {
            projectedColumns[o].width = columnWidth - padding;
            if (currentProps.ordinalAlign === "center") {
                projectedColumns[o].x =
                    projectedColumns[o].x - projectedColumns[o].width / 2;
                projectedColumns[o].middle =
                    projectedColumns[o].middle - projectedColumns[o].width / 2;
            }
            projectedColumns[o].pct = columnWidth / adjustedSize[1];
            projectedColumns[o].pct_start =
                (projectedColumns[o].x - oDomain[0]) / adjustedSize[1];
            projectedColumns[o].pct_padding = padding / adjustedSize[1];
            projectedColumns[o].pct_middle =
                (projectedColumns[o].middle - oDomain[0]) / adjustedSize[1];
        }
    });
    var labelArray = [];
    var pieArcs = [];
    var labelSettings = typeof oLabel === "object"
        ? Object.assign({ label: true, padding: 5 }, oLabel)
        : { orient: "default", label: oLabel, padding: 5 };
    if (oLabel || hoverAnnotation) {
        var offsetPct_1 = (pieceType.offsetAngle && pieceType.offsetAngle / 360) || 0;
        var rangePct = (pieceType.angleRange &&
            pieceType.angleRange.map(function (d) { return d / 360; })) || [0, 1];
        var rangeMod_1 = rangePct[1] - rangePct[0];
        var adjustedPct_1 = rangeMod_1 < 1
            ? d3_scale_1.scaleLinear()
                .domain([0, 1])
                .range(rangePct)
            : function (d) { return d; };
        oExtent.forEach(function (d) {
            var arcGenerator = d3_shape_1.arc()
                .innerRadius(0)
                .outerRadius(rScale.range()[1] / 2);
            var angle = projectedColumns[d].pct * rangeMod_1;
            var startAngle = adjustedPct_1(projectedColumns[d].pct_start + offsetPct_1);
            var endAngle = startAngle + angle;
            var midAngle = startAngle + angle / 2;
            var markD = arcGenerator({
                startAngle: startAngle * twoPI,
                endAngle: endAngle * twoPI
            });
            var translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
            var centroid = arcGenerator.centroid({
                startAngle: startAngle * twoPI,
                endAngle: endAngle * twoPI
            });
            var addedPadding = centroid[1] > 0 &&
                (!labelSettings.orient ||
                    labelSettings.orient === "default" ||
                    labelSettings.orient === "edge")
                ? 8
                : 0;
            var outerPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, rScale.range()[1] / 2 + labelSettings.padding + addedPadding);
            var pieArc = {
                startAngle: startAngle,
                endAngle: endAngle,
                midAngle: midAngle,
                markD: markD,
                translate: translate,
                centroid: centroid,
                outerPoint: outerPoint
            };
            projectedColumns[d].pieArc = pieArc;
            pieArcs.push(pieArc);
        });
    }
    if (currentProps.oLabel) {
        var labelingFn_1;
        if (labelSettings.label === true) {
            var labelStyle_1 = {
                textAnchor: "middle"
            };
            if (projection === "horizontal" && labelSettings.orient === "right") {
                labelStyle_1.textAnchor = "start";
            }
            else if (projection === "horizontal") {
                labelStyle_1.textAnchor = "end";
            }
            labelingFn_1 = function (d, p, i) {
                var additionalStyle = {};
                var transformRotate;
                if (projection === "radial" && labelSettings.orient === "stem") {
                    transformRotate = "rotate(" + (pieArcs[i].outerPoint[0] < 0
                        ? pieArcs[i].midAngle * 360 + 90
                        : pieArcs[i].midAngle * 360 - 90) + ")";
                }
                else if (projection === "radial" &&
                    labelSettings.orient !== "center") {
                    transformRotate = "rotate(" + (pieArcs[i].outerPoint[1] < 0
                        ? pieArcs[i].midAngle * 360
                        : pieArcs[i].midAngle * 360 + 180) + ")";
                }
                if (projection === "radial" &&
                    labelSettings.orient === "stem" &&
                    ((pieArcs[i].outerPoint[0] > 0 && labelSettings.padding < 0) ||
                        (pieArcs[i].outerPoint[0] < 0 && labelSettings.padding >= 0))) {
                    additionalStyle.textAnchor = "end";
                }
                else if (projection === "radial" &&
                    labelSettings.orient === "stem") {
                    additionalStyle.textAnchor = "start";
                }
                return (React.createElement("text", __assign({}, labelStyle_1, additionalStyle, { transform: transformRotate }), d));
            };
        }
        else if (typeof labelSettings.label === "function") {
            labelingFn_1 = labelSettings.label;
        }
        oExtent.forEach(function (d, i) {
            var xPosition = projectedColumns[d].middle;
            var yPosition = 0;
            if (projection === "horizontal") {
                yPosition = projectedColumns[d].middle;
                if (labelSettings.orient === "right") {
                    xPosition = adjustedSize[0] + 3;
                }
                else {
                    xPosition = -3;
                }
            }
            else if (projection === "radial") {
                if (labelSettings.orient === "center") {
                    xPosition = pieArcs[i].centroid[0] + pieArcs[i].translate[0];
                    yPosition = pieArcs[i].centroid[1] + pieArcs[i].translate[1];
                }
                else {
                    xPosition = pieArcs[i].outerPoint[0] + pieArcs[i].translate[0];
                    yPosition = pieArcs[i].outerPoint[1] + pieArcs[i].translate[1];
                }
            }
            var label = labelingFn_1(d, projectedColumns[d].pieceData.map(function (d) { return d.data; }), i
            //          ,{ arc: pieArcs[i], data: projectedColumns[d] }
            );
            labelArray.push(React.createElement("g", { key: "olabel-" + i, transform: "translate(" + xPosition + "," + yPosition + ")" }, label));
        });
        if (projection === "vertical") {
            var labelY = void 0;
            if (labelSettings.orient === "top") {
                labelY = -15;
            }
            else {
                labelY = 15 + rScale.range()[1];
            }
            oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels", transform: "translate(0," + labelY + ")" }, labelArray));
        }
        else if (projection === "horizontal") {
            oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels" }, labelArray));
        }
        else if (projection === "radial") {
            oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels" }, labelArray));
        }
    }
    if (!currentProps.pieceHoverAnnotation && !currentProps.summaryHoverAnnotation && (currentProps.hoverAnnotation || currentProps.customClickBehavior || currentProps.customDoubleClickBehavior || currentProps.customHoverBehavior)) {
        if (shouldRecalculateOverlay) {
            columnOverlays = oExtent.map(function (d, i) {
                var barColumnWidth = projectedColumns[d].width;
                var xPosition = projectedColumns[d].x;
                var yPosition = 0;
                var height = rScale.range()[1];
                var width = barColumnWidth + padding;
                if (projection === "horizontal") {
                    yPosition = projectedColumns[d].x;
                    xPosition = 0;
                    width = rScale.range()[1];
                    height = barColumnWidth;
                }
                if (projection === "radial") {
                    var _a = pieArcs[i], markD = _a.markD, centroid = _a.centroid, translate = _a.translate, midAngle = _a.midAngle;
                    var radialMousePackage_1 = {
                        type: "column-hover",
                        column: projectedColumns[d],
                        pieces: projectedColumns[d].pieceData,
                        summary: projectedColumns[d].pieceData,
                        arcAngles: {
                            centroid: centroid,
                            translate: translate,
                            midAngle: midAngle,
                            length: rScale.range()[1] / 2
                        }
                    };
                    return {
                        markType: "path",
                        key: "hover" + d,
                        d: markD,
                        transform: "translate(" + translate.join(",") + ")",
                        style: { opacity: 0 },
                        overlayData: radialMousePackage_1,
                        onDoubleClick: customDoubleClickBehavior &&
                            (function () {
                                customDoubleClickBehavior(radialMousePackage_1);
                            }),
                        onClick: customClickBehavior &&
                            (function () {
                                customClickBehavior(radialMousePackage_1);
                            }),
                        onMouseEnter: customHoverBehavior &&
                            (function () {
                                customHoverBehavior(radialMousePackage_1);
                            }),
                        onMouseLeave: customHoverBehavior &&
                            (function () {
                                customHoverBehavior();
                            })
                    };
                }
                var baseMousePackage = {
                    type: "column-hover",
                    column: projectedColumns[d],
                    pieces: projectedColumns[d].pieceData,
                    summary: projectedColumns[d].pieceData
                };
                return {
                    markType: "rect",
                    key: "hover-" + d,
                    x: xPosition,
                    y: yPosition,
                    height: height,
                    width: width,
                    style: { opacity: 0 },
                    onDoubleClick: customDoubleClickBehavior &&
                        (function () {
                            customDoubleClickBehavior(baseMousePackage);
                        }),
                    onClick: customClickBehavior &&
                        (function () {
                            customClickBehavior(baseMousePackage);
                        }),
                    onMouseEnter: customHoverBehavior &&
                        (function () {
                            customHoverBehavior(baseMousePackage);
                        }),
                    onMouseLeave: function () { return ({}); },
                    overlayData: baseMousePackage
                };
            });
        }
        else {
            columnOverlays = currentState.columnOverlays;
        }
    }
    var renderMode = currentProps.renderMode, canvasSummaries = currentProps.canvasSummaries, summaryRenderMode = currentProps.summaryRenderMode, connectorClass = currentProps.connectorClass, connectorRenderMode = currentProps.connectorRenderMode, canvasConnectors = currentProps.canvasConnectors, canvasPieces = currentProps.canvasPieces;
    var pieceDataXY;
    var pieceRenderMode = dataFunctions_1.stringToFn(renderMode, undefined, true);
    var pieceCanvasRender = dataFunctions_1.stringToFn(canvasPieces, undefined, true);
    var summaryCanvasRender = dataFunctions_1.stringToFn(canvasSummaries, undefined, true);
    var connectorCanvasRender = dataFunctions_1.stringToFn(canvasConnectors, undefined, true);
    var pieceTypeForXY = pieceType.type && pieceType.type !== "none" ? pieceType.type : "point";
    var pieceTypeLayout = typeof pieceTypeForXY === "function"
        ? pieceTypeForXY
        : layoutHash[pieceTypeForXY];
    var calculatedPieceData = pieceTypeLayout({
        type: pieceType,
        data: projectedColumns,
        renderMode: pieceRenderMode,
        eventListenersGenerator: eventListenersGenerator,
        styleFn: pieceStyle,
        projection: projection,
        classFn: pieceClass,
        adjustedSize: adjustedSize,
        chartSize: size,
        margin: margin,
        rScale: rScale,
        baseMarkProps: __assign(__assign({}, baseMarkProps), { sketchyGenerator: sketchyRenderingEngine && sketchyRenderingEngine.generator }),
    });
    var keyedData = calculatedPieceData.reduce(function (p, c) {
        if (c.o) {
            if (!p[c.o]) {
                p[c.o] = [];
            }
            p[c.o].push(c);
        }
        return p;
    }, {});
    Object.keys(projectedColumns).forEach(function (d) {
        projectedColumns[d].xyData = keyedData[d] || [];
    });
    var calculatedSummaries = {};
    if (summaryType.type && summaryType.type !== "none") {
        calculatedSummaries = summaryLayouts_1.drawSummaries({
            data: projectedColumns,
            type: summaryType,
            renderMode: dataFunctions_1.stringToFn(summaryRenderMode, undefined, true),
            styleFn: dataFunctions_1.stringToFn(summaryStyle, function () { return ({}); }, true),
            classFn: dataFunctions_1.stringToFn(summaryClass, function () { return ""; }, true),
            //        canvasRender: stringToFn<boolean>(canvasSummaries, undefined, true),
            projection: projection,
            eventListenersGenerator: eventListenersGenerator,
            adjustedSize: adjustedSize,
            baseMarkProps: __assign(__assign({}, baseMarkProps), { sketchyGenerator: sketchyRenderingEngine && sketchyRenderingEngine.generator }),
            //        chartSize: size,
            margin: margin
        });
        calculatedSummaries.originalData = projectedColumns;
    }
    var yMod = projection === "horizontal" ? midMod : zeroFunction;
    var xMod = projection === "vertical" ? midMod : zeroFunction;
    var basePieceData = calculatedPieceData.map(function (d) {
        if (d.piece && d.xy) {
            return __assign(__assign({}, d.piece), { type: "frame-hover", x: d.xy.x + xMod(d.xy), y: d.xy.y + yMod(d.xy) });
        }
        return null;
    }).filter(function (d) { return d; });
    if ((pieceHoverAnnotation &&
        ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) === -1) ||
        summaryHoverAnnotation) {
        if (summaryHoverAnnotation && calculatedSummaries.xyPoints) {
            pieceDataXY = calculatedSummaries.xyPoints.map(function (d) {
                return Object.assign({}, d, {
                    type: "frame-hover",
                    isSummaryData: true,
                    x: d.x,
                    y: d.y
                });
            });
        }
        else if (pieceHoverAnnotation && calculatedPieceData) {
            pieceDataXY = basePieceData;
        }
    }
    var _e = frameFunctions_1.orFrameAxisGenerator({
        axis: arrayWrappedAxis,
        data: allData,
        projection: projection,
        adjustedSize: adjustedSize,
        size: size,
        rScale: rScale,
        rScaleType: instantiatedRScaleType.copy(),
        pieceType: pieceType,
        rExtent: rExtent,
        maxColumnValues: maxColumnValues,
        xyData: basePieceData,
        margin: margin
    }), axis = _e.axis, axesTickLines = _e.axesTickLines;
    if (pieceHoverAnnotation &&
        ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) !== -1) {
        var yMod_1 = projection === "horizontal" ? midMod : zeroFunction;
        var xMod_1 = projection === "vertical" ? midMod : zeroFunction;
        if (shouldRecalculateOverlay) {
            columnOverlays = calculatedPieceData.map(function (d, i) {
                var mousePackage = __assign(__assign({}, d.piece), { x: d.xy.x + xMod_1(d.xy), y: d.xy.y + yMod_1(d.xy) });
                if (React.isValidElement(d.renderElement)) {
                    return {
                        renderElement: d.renderElement,
                        overlayData: mousePackage
                    };
                }
                return __assign(__assign({}, d.renderElement), { key: "hover-" + i, type: "frame-hover", style: { opacity: 0 }, overlayData: mousePackage, onClick: customClickBehavior &&
                        (function () {
                            customClickBehavior(mousePackage.data);
                        }), onDoubleClick: customDoubleClickBehavior &&
                        (function () {
                            customDoubleClickBehavior(mousePackage.data);
                        }), onMouseEnter: customHoverBehavior &&
                        (function () {
                            customHoverBehavior(mousePackage.data);
                        }), onMouseLeave: customHoverBehavior &&
                        (function () {
                            customHoverBehavior();
                        }) });
            });
        }
        else {
            columnOverlays = currentState.columnOverlays;
        }
    }
    var typeAriaLabel = (pieceType.type !== undefined &&
        typeof pieceType.type !== "function" &&
        naturalLanguageTypes[pieceType.type]) || {
        items: "piece",
        chart: "ordinal chart"
    };
    var orFrameRender = {
        connectors: {
            accessibleTransform: function (data, i) { return data[i]; },
            projection: projection,
            data: keyedData,
            styleFn: dataFunctions_1.stringToFn(connectorStyle, function () { return ({}); }, true),
            classFn: dataFunctions_1.stringToFn(connectorClass, function () { return ""; }, true),
            renderMode: dataFunctions_1.stringToFn(connectorRenderMode, undefined, true),
            canvasRender: connectorCanvasRender,
            behavior: frameFunctions_1.orFrameConnectionRenderer,
            type: connectorType,
            eventListenersGenerator: eventListenersGenerator,
            pieceType: pieceType
        },
        summaries: {
            accessibleTransform: function (data, i) {
                var columnName = oExtent[i];
                var summaryPackage = {
                    type: "column-hover",
                    column: projectedColumns[columnName],
                    pieces: projectedColumns[columnName].pieceData,
                    summary: projectedColumns[columnName].pieceData,
                    oAccessor: oAccessor
                };
                return summaryPackage;
            },
            data: calculatedSummaries.marks,
            behavior: summaryLayouts_1.renderLaidOutSummaries,
            canvasRender: summaryCanvasRender,
            styleFn: dataFunctions_1.stringToFn(summaryStyle, function () { return ({}); }, true),
            classFn: dataFunctions_1.stringToFn(summaryClass, function () { return ""; }, true)
        },
        pieces: {
            accessibleTransform: function (data, i) { return (__assign(__assign({}, (data[i].piece ? __assign(__assign({}, data[i].piece), data[i].xy) : data[i])), { type: "frame-hover" })); },
            shouldRender: pieceType.type && pieceType.type !== "none",
            data: calculatedPieceData,
            behavior: pieceDrawing_1.renderLaidOutPieces,
            canvasRender: pieceCanvasRender,
            styleFn: dataFunctions_1.stringToFn(pieceStyle, function () { return ({}); }, true),
            classFn: dataFunctions_1.stringToFn(pieceClass, function () { return ""; }, true),
            axis: arrayWrappedAxis,
            ariaLabel: typeAriaLabel
        }
    };
    if (rExtentSettings.onChange &&
        (currentState.calculatedRExtent || []).join(",") !==
            (calculatedRExtent || []).join(",")) {
        rExtentSettings.onChange(calculatedRExtent);
    }
    if (oExtentSettings.onChange &&
        (currentState.calculatedOExtent || []).join(",") !==
            (calculatedOExtent || []).join(",")) {
        oExtentSettings.onChange(calculatedOExtent);
    }
    var legendSettings;
    if (legend) {
        legendSettings = legend === true ? {} : legend;
    }
    return {
        pieceDataXY: pieceDataXY,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: foregroundGraphics,
        axisData: arrayWrappedAxis,
        axes: axis,
        axesTickLines: axesTickLines,
        oLabels: { labels: oLabels },
        title: title,
        columnOverlays: columnOverlays,
        renderNumber: currentState.renderNumber + 1,
        oAccessor: oAccessor,
        rAccessor: rAccessor,
        oScaleType: oScaleType,
        rScaleType: instantiatedRScaleType,
        oExtent: oExtent,
        rExtent: rExtent,
        oScale: oScale,
        rScale: rScale,
        calculatedOExtent: calculatedOExtent,
        calculatedRExtent: calculatedRExtent,
        projectedColumns: projectedColumns,
        margin: margin,
        legendSettings: legendSettings,
        orFrameRender: orFrameRender,
        summaryType: summaryType,
        type: pieceType,
        pieceIDAccessor: pieceIDAccessor,
        props: currentProps
    };
};


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var d3_force_1 = __webpack_require__(226);
var d3_shape_1 = __webpack_require__(18);
var svg_path_bounding_box_1 = __importDefault(__webpack_require__(179));
var semiotic_mark_1 = __webpack_require__(15);
var d3_scale_1 = __webpack_require__(24);
var SvgHelper_1 = __webpack_require__(71);
var twoPI = Math.PI * 2;
var radialBarFeatureGenerator = function (_a) {
    var type = _a.type, ordset = _a.ordset, adjustedSize = _a.adjustedSize, piece = _a.piece, i = _a.i;
    var innerRadius = type.innerRadius;
    var _b = type.offsetAngle, offsetAngle = _b === void 0 ? 0 : _b, _c = type.angleRange, angleRange = _c === void 0 ? [0, 360] : _c;
    var offsetPct = offsetAngle / 360;
    var rangePct = angleRange.map(function (d) { return d / 360; });
    var rangeMod = rangePct[1] - rangePct[0];
    var adjustedPct = rangeMod < 1
        ? d3_scale_1.scaleLinear()
            .domain([0, 1])
            .range(rangePct)
        : function (d) { return d; };
    var innerSize = type.type === "clusterbar"
        ? 0
        : type.type === "timeline"
            ? piece.scaledValue / 2
            : piece.bottom / 2;
    var outerSize = type.type === "clusterbar"
        ? piece.scaledValue / 2
        : type.type === "timeline"
            ? piece.scaledEndValue / 2
            : piece.scaledValue / 2 + piece.bottom / 2;
    if (innerRadius) {
        innerRadius = parseInt(innerRadius, 10);
        var canvasRadius = adjustedSize[0] / 2;
        var donutMod = (canvasRadius - innerRadius) / canvasRadius;
        innerSize = innerSize * donutMod + innerRadius;
        outerSize = outerSize * donutMod + innerRadius;
    }
    var arcGenerator = d3_shape_1.arc()
        .innerRadius(innerSize)
        .outerRadius(outerSize);
    var angle = (type.type === "clusterbar"
        ? (ordset.pct - ordset.pct_padding) / ordset.pieceData.length
        : ordset.pct) * rangeMod;
    var startAngle = adjustedPct(type.type === "clusterbar"
        ? ordset.pct_start +
            (i / ordset.pieceData.length) * (ordset.pct - ordset.pct_padding)
        : ordset.pct === 1
            ? 0
            : ordset.pct_start + offsetPct);
    var endAngle = ordset.pct === 1
        ? rangePct[1]
        : Math.max(startAngle, startAngle + angle - ordset.pct_padding / 2);
    var startAngleFinal = startAngle * twoPI;
    var endAngleFinal = endAngle * twoPI;
    var markD = arcGenerator({
        startAngle: startAngleFinal,
        endAngle: endAngleFinal
    });
    var centroid = arcGenerator.centroid({
        startAngle: startAngleFinal,
        endAngle: endAngleFinal
    });
    var xOffset = adjustedSize[0] / 2;
    var yOffset = adjustedSize[1] / 2;
    var xPosition = centroid[0] + xOffset;
    var yPosition = centroid[1] + yOffset;
    var outerPoint = pointOnArcAtAngle([0, 0], (startAngle + endAngle) / 2, piece.scaledValue / 2);
    var xy = {
        arcGenerator: arcGenerator,
        startAngle: startAngleFinal,
        endAngle: endAngleFinal,
        dx: outerPoint[0],
        dy: outerPoint[1]
    };
    var translate = "translate(" + xOffset + "," + yOffset + ")";
    return {
        xPosition: xPosition,
        yPosition: yPosition,
        xy: xy,
        translate: translate,
        markProps: {
            markType: "path",
            d: markD,
            tx: xOffset,
            ty: yOffset,
            transform: translate,
            customTween: {
                fn: SvgHelper_1.arcTweener,
                props: {
                    startAngle: startAngleFinal,
                    endAngle: endAngleFinal,
                    innerRadius: innerSize,
                    outerRadius: outerSize
                }
            }
        }
    };
};
var iconBarCustomMark = function (_a) {
    var type = _a.type, projection = _a.projection, finalHeight = _a.finalHeight, finalWidth = _a.finalWidth, styleFn = _a.styleFn, renderValue = _a.renderValue, classFn = _a.classFn;
    return function (piece, i, xy) {
        var iconD = typeof type.icon === "string" ? type.icon : type.icon(piece.data, i);
        var _a = type.iconPadding, iconPadding = _a === void 0 ? 1 : _a, _b = type.resize, resize = _b === void 0 ? "auto" : _b;
        var iconBounds = svg_path_bounding_box_1.default(iconD);
        var iconTranslate = [
            0 - iconBounds.x1 + iconPadding,
            0 - iconBounds.y1 + iconPadding
        ];
        iconBounds.height += iconPadding * 2;
        iconBounds.width += iconPadding * 2;
        var icons = [];
        var stackedIconSize = iconBounds.height;
        var stackedIconNumber = 1;
        var iconScale = 1;
        var spaceToUse = projection === "horizontal" ? finalHeight : finalWidth;
        var sizeToFit = projection === "horizontal" ? iconBounds.height : iconBounds.width;
        var sizeToPad = projection === "horizontal" ? iconBounds.width : iconBounds.height;
        var spaceToFill = projection === "horizontal" ? xy.width : xy.height;
        var spaceToStackFill = projection === "horizontal" ? xy.height : xy.width;
        if (resize === "auto") {
            stackedIconSize = spaceToUse / sizeToFit;
            if (stackedIconSize < 1) {
                iconScale = stackedIconSize;
            }
            else {
                stackedIconNumber = Math.floor(stackedIconSize);
                iconScale = 1 + (stackedIconSize - stackedIconNumber) / stackedIconNumber;
            }
        }
        else if (resize === "fixed") {
            iconScale = spaceToUse / sizeToFit;
        }
        //  const finalIconWidth = iconBounds.width * iconScale;
        var finalIconHeight = iconBounds.height * iconScale;
        var spaceToStep = sizeToPad * iconScale;
        var spaceToStackStep = sizeToFit * iconScale;
        iconTranslate[0] = iconTranslate[0] * iconScale;
        iconTranslate[1] = iconTranslate[1] * iconScale;
        var randoClipID = "iso-clip-" + i + "-" + Math.random();
        var clipPath = "url(#" + randoClipID + ")";
        if (xy.width > 0) {
            icons.push(React.createElement("clipPath", { key: randoClipID, id: randoClipID },
                React.createElement("rect", { x: 0, y: 0, width: xy.width, height: xy.height })));
            var iconPieces = [];
            var stepStart = projection === "horizontal" ? 0 : xy.height - finalIconHeight;
            var stepper = projection === "horizontal" ? spaceToStep : -spaceToStep;
            var stepTest = projection === "horizontal"
                ? function (step, spaceToFillValue) { return step < spaceToFillValue; }
                : function (step, spaceToFillValue, stepperValue) { return step > 0 + stepperValue; };
            for (var step = stepStart; stepTest(step, spaceToFill, stepper); step += stepper) {
                for (var stack = 0; stack < spaceToStackFill; stack += spaceToStackStep) {
                    var stepX = projection === "horizontal" ? step : stack;
                    var stepY = projection === "horizontal" ? stack : step;
                    var paddedX = stepX + iconTranslate[0];
                    var paddedY = stepY + iconTranslate[1];
                    iconPieces.push(React.createElement(semiotic_mark_1.Mark, { forceUpdate: true, markType: "path", key: "icon-" + step + "-" + stack, transform: "translate(" + paddedX + "," + paddedY + ") scale(" + iconScale + ")", vectorEffect: "non-scaling-stroke", d: iconD, style: styleFn(__assign(__assign({}, piece), piece.data), i), renderMode: renderValue, className: classFn(__assign(__assign({}, piece), piece.data), i) }));
                }
            }
            icons.push(React.createElement("g", { key: "clipped-region-" + i, clipPath: clipPath }, iconPieces));
        }
        return icons;
    };
};
function pointOnArcAtAngle(center, angle, distance) {
    var radians = Math.PI * (angle + 0.75) * 2;
    var xPosition = center[0] + distance * Math.cos(radians);
    var yPosition = center[1] + distance * Math.sin(radians);
    return [xPosition, yPosition];
}
exports.pointOnArcAtAngle = pointOnArcAtAngle;
function clusterBarLayout(_a) {
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, projection = _a.projection, classFn = _a.classFn, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, rScale = _a.rScale;
    var allCalculatedPieces = [];
    var keys = Object.keys(data);
    keys.forEach(function (key, ordsetI) {
        var ordset = data[key];
        var barColumnWidth = Math.max(ordset.width, 1);
        var clusterWidth = barColumnWidth / ordset.pieceData.length;
        var currentX = 0;
        var currentY = 0;
        var calculatedPieces = ordset.pieceData.map(function (piece, i) {
            var _a;
            var renderValue = renderMode && renderMode(piece.data, i);
            var xPosition = piece.x;
            var yPosition = piece.base;
            var finalWidth = clusterWidth;
            var finalHeight = piece.scaledValue;
            var xy = { x: 0, y: 0 };
            if (!piece.negative) {
                yPosition -= piece.scaledValue;
            }
            if (projection === "horizontal") {
                //TODO: NEGATIVE FOR HORIZONTAL
                yPosition = piece.x;
                xPosition = piece.base;
                finalHeight = clusterWidth;
                finalWidth = piece.scaledValue;
                xy.x = piece.scaledValue;
                if (piece.negative) {
                    xPosition -= piece.scaledValue;
                    xy.x = xPosition;
                }
            }
            var translate, markProps = {};
            if (projection === "radial") {
                ;
                (_a = radialBarFeatureGenerator({
                    type: type,
                    ordset: ordset,
                    adjustedSize: adjustedSize,
                    piece: piece,
                    i: i
                }), xPosition = _a.xPosition, yPosition = _a.yPosition, markProps = _a.markProps, xy = _a.xy);
                xy.x = xPosition;
            }
            else {
                xPosition += currentX;
                yPosition += currentY;
                markProps = {
                    markType: "rect",
                    x: xPosition,
                    y: yPosition,
                    width: Math.max(0, finalWidth),
                    height: Math.max(0, finalHeight),
                    rx: 0,
                    ry: 0
                };
                if (projection === "vertical") {
                    xy.x = xPosition;
                }
            }
            var eventListeners = eventListenersGenerator(piece, i);
            xy.y = yPosition;
            xy.middle = clusterWidth / 2;
            xy.height = finalHeight;
            xy.width = finalWidth;
            if (type.icon && projection !== "radial") {
                type.customMark = iconBarCustomMark({
                    type: type,
                    projection: projection,
                    finalHeight: finalHeight,
                    finalWidth: finalWidth,
                    styleFn: styleFn,
                    renderValue: renderValue,
                    classFn: classFn
                });
            }
            else if (type.icon && projection === "radial") {
                console.error("Icons are currently unsupported on radial charts");
            }
            var renderElementObject = type.customMark ? (React.createElement("g", { key: "piece-" + piece.renderKey, transform: translate ? translate : "translate(" + xPosition + "," + yPosition + ")" }, type.customMark(__assign(__assign(__assign({}, piece.data), piece), { x: xPosition, y: yPosition }), i, __assign(__assign({}, xy), { baseMarkProps: baseMarkProps,
                renderMode: renderMode,
                styleFn: styleFn,
                classFn: classFn,
                adjustedSize: adjustedSize,
                chartSize: chartSize,
                margin: margin,
                rScale: rScale })))) : (__assign(__assign({ className: classFn(__assign(__assign({}, piece), piece.data), i), renderMode: renderValue, key: "piece-" + piece.renderKey, transform: translate, style: styleFn(__assign(__assign({}, piece), piece.data), ordsetI) }, markProps), eventListeners));
            var calculatedPiece = {
                o: key,
                xy: xy,
                piece: piece,
                renderElement: renderElementObject
            };
            if (projection === "horizontal") {
                currentY += finalHeight;
            }
            else {
                currentX += finalWidth;
            }
            //        currentOffset += pieceSize
            return calculatedPiece;
        });
        allCalculatedPieces = __spread(allCalculatedPieces, calculatedPieces);
    });
    return allCalculatedPieces;
}
exports.clusterBarLayout = clusterBarLayout;
function barLayout(_a) {
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, projection = _a.projection, classFn = _a.classFn, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, rScale = _a.rScale;
    var keys = Object.keys(data);
    var allCalculatedPieces = [];
    keys.forEach(function (key, ordsetI) {
        var ordset = data[key];
        var barColumnWidth = Math.max(ordset.width, 1);
        var calculatedPieces = ordset.pieceData.map(function (piece, i) {
            var _a;
            var pieceSize = piece.scaledValue;
            var renderValue = renderMode && renderMode(piece.data, i);
            var xPosition = piece.x;
            var yPosition = piece.bottom;
            var finalWidth = barColumnWidth;
            var finalHeight = pieceSize;
            var xy = {};
            if (!piece.negative) {
                yPosition -= piece.scaledValue;
            }
            if (projection === "vertical") {
                xy = {
                    x: xPosition,
                    y: yPosition,
                    middle: barColumnWidth / 2,
                    height: finalHeight,
                    width: finalWidth
                };
            }
            else if (projection === "horizontal") {
                yPosition = piece.x;
                xPosition = piece.bottom;
                finalHeight = barColumnWidth;
                finalWidth = pieceSize;
                xy = {
                    x: xPosition + piece.scaledValue,
                    y: yPosition,
                    middle: barColumnWidth / 2,
                    height: finalHeight,
                    width: finalWidth
                };
                if (piece.negative) {
                    xPosition = piece.bottom - piece.scaledValue;
                }
            }
            var markProps;
            if (projection === "radial") {
                ;
                (_a = radialBarFeatureGenerator({
                    type: type,
                    ordset: ordset,
                    adjustedSize: adjustedSize,
                    piece: piece,
                    i: i
                }), markProps = _a.markProps, xPosition = _a.xPosition, yPosition = _a.yPosition);
                finalHeight = undefined;
                finalWidth = undefined;
                xy = {
                    x: xPosition,
                    y: yPosition,
                    middle: barColumnWidth / 2,
                    height: finalHeight,
                    width: finalWidth
                };
            }
            else {
                markProps = {
                    markType: "rect",
                    x: xPosition,
                    y: yPosition,
                    width: Math.max(0, finalWidth),
                    height: Math.max(0, finalHeight),
                    rx: 0,
                    ry: 0
                };
            }
            var eventListeners = eventListenersGenerator(piece, i);
            if (type.icon && projection !== "radial") {
                type.customMark = iconBarCustomMark({
                    type: type,
                    projection: projection,
                    finalHeight: finalHeight,
                    finalWidth: finalWidth,
                    styleFn: styleFn,
                    renderValue: renderValue,
                    classFn: classFn
                });
            }
            else if (type.icon && projection !== "horizontal") {
                console.error("Icons are currently unsupported in radial charts");
            }
            var renderElementObject = type.customMark ? (React.createElement("g", { key: "piece-" + piece.renderKey, transform: "translate(" + xPosition + "," + yPosition + ")", role: "img", tabIndex: -1 }, type.customMark(__assign(__assign(__assign({}, piece.data), piece), { x: xPosition, y: yPosition }), i, __assign(__assign({}, xy), { baseMarkProps: baseMarkProps,
                renderMode: renderMode,
                styleFn: styleFn,
                classFn: classFn,
                adjustedSize: adjustedSize,
                chartSize: chartSize,
                margin: margin,
                rScale: rScale })))) : (__assign(__assign({ className: classFn(__assign(__assign({}, piece), piece.data), i), renderMode: renderValue, key: "piece-" + piece.renderKey, style: styleFn(__assign(__assign({}, piece), piece.data), ordsetI) }, eventListeners), markProps));
            var calculatedPiece = {
                o: key,
                xy: xy,
                piece: piece,
                renderElement: renderElementObject
            };
            return calculatedPiece;
        });
        allCalculatedPieces = __spread(allCalculatedPieces, calculatedPieces);
    });
    return allCalculatedPieces;
}
exports.barLayout = barLayout;
function timelineLayout(_a) {
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, projection = _a.projection, classFn = _a.classFn, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, rScale = _a.rScale;
    var allCalculatedPieces = [];
    var keys = Object.keys(data);
    keys.forEach(function (key, ordsetI) {
        var ordset = data[key];
        var calculatedPieces = [];
        ordset.pieceData.forEach(function (piece, i) {
            var scaledValue, scaledBottom;
            var renderValue = renderMode && renderMode(piece.data, i);
            var xPosition = ordset.x;
            var height = piece.scaledEndValue - piece.scaledValue;
            var yPosition = piece.scaledVerticalValue - height;
            var width = ordset.width;
            var markProps = {
                markType: "rect",
                height: height < 0 ? -height : height,
                width: width,
                x: xPosition,
                y: height < 0 ? yPosition + height : yPosition
            };
            if (projection === "horizontal") {
                yPosition = ordset.x;
                xPosition = piece.scaledValue;
                scaledValue = piece.scaledEndValue - piece.scaledValue;
                scaledBottom = piece.scaledBottom;
                width = piece.scaledEndValue - piece.scaledValue;
                height = ordset.width;
                markProps = {
                    markType: "rect",
                    height: height,
                    width: width < 0 ? -width : width,
                    x: width < 0 ? xPosition + width : xPosition,
                    y: yPosition
                };
            }
            else if (projection === "radial") {
                ;
                (markProps = radialBarFeatureGenerator({
                    piece: piece,
                    type: type,
                    ordset: ordset,
                    adjustedSize: adjustedSize,
                    i: i
                }).markProps);
            }
            //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type
            var eventListeners = eventListenersGenerator(piece, i);
            var xy = {
                x: xPosition,
                y: yPosition,
                scaledValue: scaledValue,
                scaledBottom: scaledBottom,
                height: height
            };
            var renderElementObject = type.customMark ? (React.createElement("g", { key: "piece-" + piece.renderKey, transform: "translate(" + xPosition + "," + (yPosition + height) + ")" }, type.customMark(__assign(__assign(__assign({}, piece.data), piece), { x: xPosition, y: yPosition }), i, __assign(__assign({}, xy), { baseMarkProps: baseMarkProps,
                renderMode: renderMode,
                styleFn: styleFn,
                classFn: classFn,
                adjustedSize: adjustedSize,
                chartSize: chartSize,
                margin: margin,
                rScale: rScale })))) : (__assign(__assign({ className: classFn(__assign(__assign({}, piece), piece.data), i), renderMode: renderValue, key: "piece-" + piece.renderKey, style: styleFn(__assign(__assign({}, piece), piece.data), ordsetI) }, markProps), eventListeners));
            var calculatedPiece = {
                o: key,
                xy: xy,
                piece: piece,
                renderElement: renderElementObject
            };
            calculatedPieces.push(calculatedPiece);
        });
        allCalculatedPieces = __spread(allCalculatedPieces, calculatedPieces);
    });
    return allCalculatedPieces;
}
exports.timelineLayout = timelineLayout;
function pointLayout(_a) {
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, projection = _a.projection, classFn = _a.classFn, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, rScale = _a.rScale;
    var circleRadius = type.r || 3;
    var allCalculatedPieces = [];
    var keys = Object.keys(data);
    keys.forEach(function (key, ordsetI) {
        var ordset = data[key];
        var calculatedPieces = [];
        ordset.pieceData.forEach(function (piece, i) {
            var renderValue = renderMode && renderMode(piece.data, i);
            var xPosition = ordset.middle;
            var yPosition = piece.scaledVerticalValue;
            if (projection === "horizontal") {
                yPosition = ordset.middle;
                xPosition = piece.scaledValue;
            }
            else if (projection === "radial") {
                var angle = ordset.pct_middle;
                var rPosition = piece.scaledValue / 2;
                var baseCentroid = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], angle, rPosition);
                xPosition = baseCentroid[0];
                yPosition = baseCentroid[1];
            }
            //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type
            var actualCircleRadius = typeof circleRadius === "function"
                ? circleRadius(piece, i)
                : circleRadius;
            var eventListeners = eventListenersGenerator(piece, i);
            var renderElementObject = type.customMark ? (React.createElement("g", { key: "piece-" + piece.renderKey, transform: "translate(" + xPosition + "," + yPosition + ")" }, type.customMark(__assign(__assign(__assign({}, piece.data), piece), { x: xPosition, y: yPosition }), i, {
                r: circleRadius,
                x: xPosition,
                y: yPosition,
                baseMarkProps: baseMarkProps,
                renderMode: renderMode,
                styleFn: styleFn,
                classFn: classFn,
                adjustedSize: adjustedSize,
                chartSize: chartSize,
                margin: margin,
                rScale: rScale
            }))) : (__assign({ className: classFn(__assign(__assign({}, piece), piece.data), i), markType: "rect", renderMode: renderValue, key: "piece-" + piece.renderKey, height: actualCircleRadius * 2, width: actualCircleRadius * 2, x: xPosition - actualCircleRadius, y: yPosition - actualCircleRadius, rx: actualCircleRadius, ry: actualCircleRadius, style: styleFn(__assign(__assign({}, piece), piece.data), ordsetI) }, eventListeners));
            var calculatedPiece = {
                o: key,
                xy: {
                    x: xPosition,
                    y: yPosition
                },
                piece: piece,
                renderElement: renderElementObject
            };
            calculatedPieces.push(calculatedPiece);
        });
        allCalculatedPieces = __spread(allCalculatedPieces, calculatedPieces);
    });
    return allCalculatedPieces;
}
exports.pointLayout = pointLayout;
function swarmLayout(_a) {
    var type = _a.type, data = _a.data, renderMode = _a.renderMode, eventListenersGenerator = _a.eventListenersGenerator, styleFn = _a.styleFn, projection = _a.projection, classFn = _a.classFn, adjustedSize = _a.adjustedSize, chartSize = _a.chartSize, margin = _a.margin, baseMarkProps = _a.baseMarkProps, rScale = _a.rScale;
    var allCalculatedPieces = [];
    var iterations = type.iterations || 120;
    var columnKeys = Object.keys(data);
    columnKeys.forEach(function (key, ordsetI) {
        var oColumn = data[key];
        var anglePiece = 1 / columnKeys.length;
        var oData = oColumn.pieceData;
        var adjustedColumnWidth = oColumn.width;
        var circleRadius = type.r ||
            Math.max(2, Math.min(5, (4 * adjustedColumnWidth) / oData.length));
        var simulation = d3_force_1.forceSimulation(oData)
            .force("y", d3_force_1.forceY(function (d) { return d.scaledValue; }).strength(type.strength || 2))
            .force("x", d3_force_1.forceX(oColumn.middle))
            .force("collide", d3_force_1.forceCollide(circleRadius))
            .stop();
        if (projection === "vertical") {
            simulation.force("y", d3_force_1.forceY(function (d) { return d.scaledVerticalValue; }).strength(type.strength || 2));
        }
        for (var i = 0; i < iterations; ++i)
            simulation.tick();
        var calculatedPieces = oData.map(function (piece, i) {
            var renderValue = renderMode && renderMode(piece.data, i);
            var xPosition = piece.x;
            var yPosition = piece.y;
            if (projection === "horizontal") {
                yPosition = piece.x;
                xPosition = piece.y;
            }
            else if (projection === "radial") {
                var angle = oColumn.pct_middle;
                xPosition =
                    ((piece.x - oColumn.middle) / adjustedColumnWidth) * anglePiece;
                var rPosition = piece.scaledValue / 2;
                var xAngle = angle + xPosition;
                var baseCentroid = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], xAngle, rPosition);
                xPosition = baseCentroid[0];
                yPosition = baseCentroid[1];
            }
            var actualCircleRadius = typeof circleRadius === "function"
                ? circleRadius(piece, i)
                : circleRadius;
            var eventListeners = eventListenersGenerator(piece, i);
            var renderElementObject = type.customMark ? (React.createElement("g", { key: "piece-" + piece.renderKey, transform: "translate(" + xPosition + "," + yPosition + ")" }, type.customMark(__assign(__assign(__assign({}, piece.data), piece), { x: xPosition, y: yPosition }), i, {
                x: xPosition,
                y: yPosition,
                r: circleRadius,
                baseMarkProps: baseMarkProps,
                renderMode: renderMode,
                styleFn: styleFn,
                classFn: classFn,
                adjustedSize: adjustedSize,
                chartSize: chartSize,
                margin: margin,
                rScale: rScale
            }))) : (__assign({ className: classFn(__assign(__assign({}, piece), piece.data), i), markType: "rect", renderMode: renderValue, key: "piece-" + piece.renderKey, height: actualCircleRadius * 2, width: actualCircleRadius * 2, x: xPosition - actualCircleRadius, y: yPosition - actualCircleRadius, rx: actualCircleRadius, ry: actualCircleRadius, style: styleFn(__assign(__assign({}, piece), piece.data), ordsetI) }, eventListeners));
            var calculatedPiece = {
                o: key,
                xy: {
                    x: xPosition,
                    y: yPosition
                },
                piece: piece,
                renderElement: renderElementObject
            };
            return calculatedPiece;
        });
        allCalculatedPieces = __spread(allCalculatedPieces, calculatedPieces);
    });
    return allCalculatedPieces;
}
exports.swarmLayout = swarmLayout;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var
  Path = __webpack_require__(308);

module.exports = caster;

function caster(path) {
  return new Path(path).getBoundingBox();
}

caster.Path = Path;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var
  BoundingBox = __webpack_require__(309),
  BoundingBoxView = __webpack_require__(310),
  SvgPath = __webpack_require__(311);

module.exports = Path;

function Path(d) {
  this.d = d;
}

Path.prototype = {

  getBoundingBox: function() {
    var
      pathDriver,
      boundingBox;

    pathDriver = new SvgPath(this.d);
    boundingBox = new BoundingBox();

    pathDriver
      .abs()
      .unarc()
      .unshort()
      .iterate(function(seg, index, x, y) {

        switch(seg[0]) {
          case 'M':
          case 'L':
            boundingBox.addPoint(
              seg[1],
              seg[2]
            );
            break;
          case 'H':
            boundingBox.addX(seg[1]);
            break;
          case 'V':
            boundingBox.addY(seg[1]);
            break;
          case 'Q':
            boundingBox.addQuadraticCurve(
              x,
              y,
              seg[1],
              seg[2],
              seg[3],
              seg[4]
            );
            break;
          case 'C':
            boundingBox.addBezierCurve(
              x,
              y,
              seg[1],
              seg[2],
              seg[3],
              seg[4],
              seg[5],
              seg[6]
            );
            break;
        }

      });

    return new BoundingBoxView(boundingBox);
  }

};


/***/ }),
/* 309 */
/***/ (function(module, exports) {

module.exports = BoundingBox;

// from https://github.com/gabelerner/canvg/blob/860e418aca67b9a41e858a223d74d375793ec364/canvg.js#L449

function BoundingBox(x1, y1, x2, y2) { // pass in initial points if you want
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;

  this.addPoint(x1, y1);
  this.addPoint(x2, y2);
}

BoundingBox.prototype = {

  width: function () {
    return this.x2 - this.x1;
  },

  height: function () {
    return this.y2 - this.y1;
  },

  addPoint: function (x, y) {
    if (x != null) {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x;
        this.x2 = x;
      }
      if (x < this.x1) this.x1 = x;
      if (x > this.x2) this.x2 = x;
    }

    if (y != null) {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y;
        this.y2 = y;
      }
      if (y < this.y1) this.y1 = y;
      if (y > this.y2) this.y2 = y;
    }
  },

  addX: function (x) {
    this.addPoint(x, null);
  },

  addY: function (y) {
    this.addPoint(null, y);
  },

  addQuadraticCurve: function (p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
    var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  },

  addBezierCurve: function (p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    var
      i,
      p0 = [p0x, p0y],
      p1 = [p1x, p1y],
      p2 = [p2x, p2y],
      p3 = [p3x, p3y];

    this.addPoint(p0[0], p0[1]);
    this.addPoint(p3[0], p3[1]);

    for (i = 0; i <= 1; i++) {
      var f = function (t) {
        return Math.pow(1 - t, 3) * p0[i]
          + 3 * Math.pow(1 - t, 2) * t * p1[i]
          + 3 * (1 - t) * Math.pow(t, 2) * p2[i]
          + Math.pow(t, 3) * p3[i];
      };

      var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
      var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
      var c = 3 * p1[i] - 3 * p0[i];

      if (a == 0) {
        if (b == 0) continue;
        var t = -c / b;
        if (0 < t && t < 1) {
          if (i == 0) this.addX(f(t));
          if (i == 1) this.addY(f(t));
        }
        continue;
      }

      var b2ac = Math.pow(b, 2) - 4 * c * a;
      if (b2ac < 0) continue;
      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
      if (0 < t1 && t1 < 1) {
        if (i == 0) this.addX(f(t1));
        if (i == 1) this.addY(f(t1));
      }
      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
      if (0 < t2 && t2 < 1) {
        if (i == 0) this.addX(f(t2));
        if (i == 1) this.addY(f(t2));
      }
    }
  }

};



/***/ }),
/* 310 */
/***/ (function(module, exports) {


module.exports = BoundingBoxView;

function BoundingBoxView(boundingBox) {

  this.x1 = this.minX = boundingBox.x1 || 0;
  this.y1 = this.minY = boundingBox.y1 || 0;
  this.x2 = this.maxX = boundingBox.x2 || 0;
  this.y2 = this.maxY = boundingBox.y2 || 0;
  this.width = boundingBox.width() || 0;
  this.height = boundingBox.height() || 0;

}

BoundingBoxView.prototype = {

  round: function(precision) {
    precision = precision || 0;

    this.x1 = this.minX = +this.x1.toFixed(precision);
    this.y1 = this.minY = +this.y1.toFixed(precision);
    this.x2 = this.maxX = +this.x2.toFixed(precision);
    this.y2 = this.maxY = +this.y2.toFixed(precision);
    this.width = +this.width.toFixed(precision);
    this.height = +this.height.toFixed(precision);

    return this;
  },

  scale: function(scale) {
    var
      self = this;

    scale = scale || 1;

    [
      'x1',
      'minX',
      'y1',
      'minY',
      'x2',
      'maxX',
      'y2',
      'maxY',
      'width',
      'height'
    ]
      .forEach(function(name) {
        self[name] = self[name] * scale;
      });

    return this;
  },

  toString: function() {
    return [
      this.minX,
      this.minY,
      this.width,
      this.height
    ]
      .join(' ');
  }

};

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(312);


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// SVG Path transformations library
//
// Usage:
//
//    SvgPath('...')
//      .translate(-150, -100)
//      .scale(0.5)
//      .translate(-150, -100)
//      .toFixed(1)
//      .toString()
//




var pathParse      = __webpack_require__(313);
var transformParse = __webpack_require__(314);
var matrix         = __webpack_require__(180);
var a2c            = __webpack_require__(315);
var ellipse        = __webpack_require__(316);


// Class constructor
//
function SvgPath(path) {
  if (!(this instanceof SvgPath)) { return new SvgPath(path); }

  var pstate = pathParse(path);

  // Array of path segments.
  // Each segment is array [command, param1, param2, ...]
  this.segments = pstate.segments;

  // Error message on parse error.
  this.err      = pstate.err;

  // Transforms stack for lazy evaluation
  this.__stack    = [];
}

SvgPath.from = function (src) {
  if (typeof src === 'string') return new SvgPath(src);

  if (src instanceof SvgPath) {
    // Create empty object
    var s = new SvgPath('');

    // Clone properies
    s.err = src.err;
    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });
    s.__stack = src.__stack.map(function (m) {
      return matrix().matrix(m.toArray());
    });

    return s;
  }

  throw new Error('SvgPath.from: invalid param type ' + src);
};


SvgPath.prototype.__matrix = function (m) {
  var self = this, i;

  // Quick leave for empty matrix
  if (!m.queue.length) { return; }

  this.iterate(function (s, index, x, y) {
    var p, result, name, isRelative;

    switch (s[0]) {

      // Process 'assymetric' commands separately
      case 'v':
        p      = m.calc(0, s[1], true);
        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];
        break;

      case 'V':
        p      = m.calc(x, s[1], false);
        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];
        break;

      case 'h':
        p      = m.calc(s[1], 0, true);
        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];
        break;

      case 'H':
        p      = m.calc(s[1], y, false);
        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];
        break;

      case 'a':
      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]

        // Drop segment if arc is empty (end point === start point)
        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          return [];
        }*/

        // Transform rx, ry and the x-axis-rotation
        var ma = m.toArray();
        var e = ellipse(s[1], s[2], s[3]).transform(ma);

        // flip sweep-flag if matrix is not orientation-preserving
        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
          s[5] = s[5] ? '0' : '1';
        }

        // Transform end point as usual (without translation for relative notation)
        p = m.calc(s[6], s[7], s[0] === 'a');

        // Empty arcs can be ignored by renderer, but should not be dropped
        // to avoid collisions with `S A S` and so on. Replace with empty line.
        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
          break;
        }

        // if the resulting ellipse is (almost) a segment ...
        if (e.isDegenerate()) {
          // replace the arc by a line
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
        } else {
          // if it is a real ellipse
          // s[0], s[4] and s[5] are not modified
          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];
        }

        break;

      case 'm':
        // Edge case. The very first `m` should be processed as absolute, if happens.
        // Make sense for coord shift transforms.
        isRelative = index > 0;

        p = m.calc(s[1], s[2], isRelative);
        result = [ 'm', p[0], p[1] ];
        break;

      default:
        name       = s[0];
        result     = [ name ];
        isRelative = (name.toLowerCase() === name);

        // Apply transformations to the segment
        for (i = 1; i < s.length; i += 2) {
          p = m.calc(s[i], s[i + 1], isRelative);
          result.push(p[0], p[1]);
        }
    }

    self.segments[index] = result;
  }, true);
};


// Apply stacked commands
//
SvgPath.prototype.__evaluateStack = function () {
  var m, i;

  if (!this.__stack.length) { return; }

  if (this.__stack.length === 1) {
    this.__matrix(this.__stack[0]);
    this.__stack = [];
    return;
  }

  m = matrix();
  i = this.__stack.length;

  while (--i >= 0) {
    m.matrix(this.__stack[i].toArray());
  }

  this.__matrix(m);
  this.__stack = [];
};


// Convert processed SVG Path back to string
//
SvgPath.prototype.toString = function () {
  var elements = [], skipCmd, cmd;

  this.__evaluateStack();

  for (var i = 0; i < this.segments.length; i++) {
    // remove repeating commands names
    cmd = this.segments[i][0];
    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this.segments[i - 1][0];
    elements = elements.concat(skipCmd ? this.segments[i].slice(1) : this.segments[i]);
  }

  return elements.join(' ')
    // Optimizations: remove spaces around commands & before `-`
    //
    // We could also remove leading zeros for `0.5`-like values,
    // but their count is too small to spend time for.
    .replace(/ ?([achlmqrstvz]) ?/gi, '$1')
    .replace(/ \-/g, '-')
    // workaround for FontForge SVG importing bug
    .replace(/zm/g, 'z m');
};


// Translate path to (x [, y])
//
SvgPath.prototype.translate = function (x, y) {
  this.__stack.push(matrix().translate(x, y || 0));
  return this;
};


// Scale path to (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.scale = function (sx, sy) {
  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));
  return this;
};


// Rotate path around point (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.rotate = function (angle, rx, ry) {
  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
  return this;
};


// Skew path along the X axis by `degrees` angle
//
SvgPath.prototype.skewX = function (degrees) {
  this.__stack.push(matrix().skewX(degrees));
  return this;
};


// Skew path along the Y axis by `degrees` angle
//
SvgPath.prototype.skewY = function (degrees) {
  this.__stack.push(matrix().skewY(degrees));
  return this;
};


// Apply matrix transform (array of 6 elements)
//
SvgPath.prototype.matrix = function (m) {
  this.__stack.push(matrix().matrix(m));
  return this;
};


// Transform path according to "transform" attr of SVG spec
//
SvgPath.prototype.transform = function (transformString) {
  if (!transformString.trim()) {
    return this;
  }
  this.__stack.push(transformParse(transformString));
  return this;
};


// Round coords with given decimal precition.
// 0 by default (to integers)
//
SvgPath.prototype.round = function (d) {
  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;

  d = d || 0;

  this.__evaluateStack();

  this.segments.forEach(function (s) {
    var isRelative = (s[0].toLowerCase() === s[0]);

    switch (s[0]) {
      case 'H':
      case 'h':
        if (isRelative) { s[1] += deltaX; }
        deltaX = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'V':
      case 'v':
        if (isRelative) { s[1] += deltaY; }
        deltaY = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'Z':
      case 'z':
        deltaX = contourStartDeltaX;
        deltaY = contourStartDeltaY;
        return;

      case 'M':
      case 'm':
        if (isRelative) {
          s[1] += deltaX;
          s[2] += deltaY;
        }

        deltaX = s[1] - s[1].toFixed(d);
        deltaY = s[2] - s[2].toFixed(d);

        contourStartDeltaX = deltaX;
        contourStartDeltaY = deltaY;

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        return;

      case 'A':
      case 'a':
        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        if (isRelative) {
          s[6] += deltaX;
          s[7] += deltaY;
        }

        deltaX = s[6] - s[6].toFixed(d);
        deltaY = s[7] - s[7].toFixed(d);

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        s[3] = +s[3].toFixed(d + 2); // better precision for rotation
        s[6] = +s[6].toFixed(d);
        s[7] = +s[7].toFixed(d);
        return;

      default:
        // a c l q s t
        l = s.length;

        if (isRelative) {
          s[l - 2] += deltaX;
          s[l - 1] += deltaY;
        }

        deltaX = s[l - 2] - s[l - 2].toFixed(d);
        deltaY = s[l - 1] - s[l - 1].toFixed(d);

        s.forEach(function (val, i) {
          if (!i) { return; }
          s[i] = +s[i].toFixed(d);
        });
        return;
    }
  });

  return this;
};


// Apply iterator function to all segments. If function returns result,
// current segment will be replaced to array of returned segments.
// If empty array is returned, current regment will be deleted.
//
SvgPath.prototype.iterate = function (iterator, keepLazyStack) {
  var segments = this.segments,
      replacements = {},
      needReplace = false,
      lastX = 0,
      lastY = 0,
      countourStartX = 0,
      countourStartY = 0;
  var i, j, newSegments;

  if (!keepLazyStack) {
    this.__evaluateStack();
  }

  segments.forEach(function (s, index) {

    var res = iterator(s, index, lastX, lastY);

    if (Array.isArray(res)) {
      replacements[index] = res;
      needReplace = true;
    }

    var isRelative = (s[0] === s[0].toLowerCase());

    // calculate absolute X and Y
    switch (s[0]) {
      case 'm':
      case 'M':
        lastX = s[1] + (isRelative ? lastX : 0);
        lastY = s[2] + (isRelative ? lastY : 0);
        countourStartX = lastX;
        countourStartY = lastY;
        return;

      case 'h':
      case 'H':
        lastX = s[1] + (isRelative ? lastX : 0);
        return;

      case 'v':
      case 'V':
        lastY = s[1] + (isRelative ? lastY : 0);
        return;

      case 'z':
      case 'Z':
        // That make sence for multiple contours
        lastX = countourStartX;
        lastY = countourStartY;
        return;

      default:
        lastX = s[s.length - 2] + (isRelative ? lastX : 0);
        lastY = s[s.length - 1] + (isRelative ? lastY : 0);
    }
  });

  // Replace segments if iterator return results

  if (!needReplace) { return this; }

  newSegments = [];

  for (i = 0; i < segments.length; i++) {
    if (typeof replacements[i] !== 'undefined') {
      for (j = 0; j < replacements[i].length; j++) {
        newSegments.push(replacements[i][j]);
      }
    } else {
      newSegments.push(segments[i]);
    }
  }

  this.segments = newSegments;

  return this;
};


// Converts segments from relative to absolute
//
SvgPath.prototype.abs = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameUC = name.toUpperCase(),
        i;

    // Skip absolute commands
    if (name === nameUC) { return; }

    s[0] = nameUC;

    switch (name) {
      case 'v':
        // v has shifted coords parity
        s[1] += y;
        return;

      case 'a':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] += x;
        s[7] += y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] += i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts segments from absolute to relative
//
SvgPath.prototype.rel = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameLC = name.toLowerCase(),
        i;

    // Skip relative commands
    if (name === nameLC) { return; }

    // Don't touch the first M to avoid potential confusions.
    if (index === 0 && name === 'M') { return; }

    s[0] = nameLC;

    switch (name) {
      case 'V':
        // V has shifted coords parity
        s[1] -= y;
        return;

      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] -= x;
        s[7] -= y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] -= i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts arcs to cubic bézier curves
//
SvgPath.prototype.unarc = function () {
  this.iterate(function (s, index, x, y) {
    var new_segments, nextX, nextY, result = [], name = s[0];

    // Skip anything except arcs
    if (name !== 'A' && name !== 'a') { return null; }

    if (name === 'a') {
      // convert relative arc coordinates to absolute
      nextX = x + s[6];
      nextY = y + s[7];
    } else {
      nextX = s[6];
      nextY = s[7];
    }

    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);

    // Degenerated arcs can be ignored by renderer, but should not be dropped
    // to avoid collisions with `S A S` and so on. Replace with empty line.
    if (new_segments.length === 0) {
      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];
    }

    new_segments.forEach(function (s) {
      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);
    });

    return result;
  });

  return this;
};


// Converts smooth curves (with missed control point) to generic curves
//
SvgPath.prototype.unshort = function () {
  var segments = this.segments;
  var prevControlX, prevControlY, prevSegment;
  var curControlX, curControlY;

  // TODO: add lazy evaluation flag when relative commands supported

  this.iterate(function (s, idx, x, y) {
    var name = s[0], nameUC = name.toUpperCase(), isRelative;

    // First command MUST be M|m, it's safe to skip.
    // Protect from access to [-1] for sure.
    if (!idx) { return; }

    if (nameUC === 'T') { // quadratic curve
      isRelative = (name === 't');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'Q') {
        prevControlX = prevSegment[1] - x;
        prevControlY = prevSegment[2] - y;
      } else if (prevSegment[0] === 'q') {
        prevControlX = prevSegment[1] - prevSegment[3];
        prevControlY = prevSegment[2] - prevSegment[4];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'q' : 'Q',
        curControlX, curControlY,
        s[1], s[2]
      ];

    } else if (nameUC === 'S') { // cubic curve
      isRelative = (name === 's');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'C') {
        prevControlX = prevSegment[3] - x;
        prevControlY = prevSegment[4] - y;
      } else if (prevSegment[0] === 'c') {
        prevControlX = prevSegment[3] - prevSegment[5];
        prevControlY = prevSegment[4] - prevSegment[6];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'c' : 'C',
        curControlX, curControlY,
        s[1], s[2], s[3], s[4]
      ];
    }
  });

  return this;
};


module.exports = SvgPath;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };

var SPECIAL_SPACES = [
  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF
];

function isSpace(ch) {
  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators
    // White spaces
    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);
}

function isCommand(code) {
  /*eslint-disable no-bitwise*/
  switch (code | 0x20) {
    case 0x6D/* m */:
    case 0x7A/* z */:
    case 0x6C/* l */:
    case 0x68/* h */:
    case 0x76/* v */:
    case 0x63/* c */:
    case 0x73/* s */:
    case 0x71/* q */:
    case 0x74/* t */:
    case 0x61/* a */:
    case 0x72/* r */:
      return true;
  }
  return false;
}

function isArc(code) {
  return (code | 0x20) === 0x61;
}

function isDigit(code) {
  return (code >= 48 && code <= 57);   // 0..9
}

function isDigitStart(code) {
  return (code >= 48 && code <= 57) || /* 0..9 */
          code === 0x2B || /* + */
          code === 0x2D || /* - */
          code === 0x2E;   /* . */
}


function State(path) {
  this.index  = 0;
  this.path   = path;
  this.max    = path.length;
  this.result = [];
  this.param  = 0.0;
  this.err    = '';
  this.segmentStart = 0;
  this.data   = [];
}

function skipSpaces(state) {
  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
    state.index++;
  }
}


function scanFlag(state) {
  var ch = state.path.charCodeAt(state.index);

  if (ch === 0x30/* 0 */) {
    state.param = 0;
    state.index++;
    return;
  }

  if (ch === 0x31/* 1 */) {
    state.param = 1;
    state.index++;
    return;
  }

  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';
}


function scanParam(state) {
  var start = state.index,
      index = start,
      max = state.max,
      zeroFirst = false,
      hasCeiling = false,
      hasDecimal = false,
      hasDot = false,
      ch;

  if (index >= max) {
    state.err = 'SvgPath: missed param (at pos ' + index + ')';
    return;
  }
  ch = state.path.charCodeAt(index);

  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
    index++;
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  // This logic is shamelessly borrowed from Esprima
  // https://github.com/ariya/esprimas
  //
  if (!isDigit(ch) && ch !== 0x2E/* . */) {
    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
    return;
  }

  if (ch !== 0x2E/* . */) {
    zeroFirst = (ch === 0x30/* 0 */);
    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;

    if (zeroFirst && index < max) {
      // decimal number starts with '0' such as '09' is illegal.
      if (ch && isDigit(ch)) {
        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';
        return;
      }
    }

    while (index < max && isDigit(state.path.charCodeAt(index))) {
      index++;
      hasCeiling = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x2E/* . */) {
    hasDot = true;
    index++;
    while (isDigit(state.path.charCodeAt(index))) {
      index++;
      hasDecimal = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x65/* e */ || ch === 0x45/* E */) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }

    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;
    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      index++;
    }
    if (index < max && isDigit(state.path.charCodeAt(index))) {
      while (index < max && isDigit(state.path.charCodeAt(index))) {
        index++;
      }
    } else {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }
  }

  state.index = index;
  state.param = parseFloat(state.path.slice(start, index)) + 0.0;
}


function finalizeSegment(state) {
  var cmd, cmdLC;

  // Process duplicated commands (without comand name)

  // This logic is shamelessly borrowed from Raphael
  // https://github.com/DmitryBaranovskiy/raphael/
  //
  cmd   = state.path[state.segmentStart];
  cmdLC = cmd.toLowerCase();

  var params = state.data;

  if (cmdLC === 'm' && params.length > 2) {
    state.result.push([ cmd, params[0], params[1] ]);
    params = params.slice(2);
    cmdLC = 'l';
    cmd = (cmd === 'm') ? 'l' : 'L';
  }

  if (cmdLC === 'r') {
    state.result.push([ cmd ].concat(params));
  } else {

    while (params.length >= paramCounts[cmdLC]) {
      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));
      if (!paramCounts[cmdLC]) {
        break;
      }
    }
  }
}


function scanSegment(state) {
  var max = state.max,
      cmdCode, is_arc, comma_found, need_params, i;

  state.segmentStart = state.index;
  cmdCode = state.path.charCodeAt(state.index);
  is_arc = isArc(cmdCode);

  if (!isCommand(cmdCode)) {
    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';
    return;
  }

  need_params = paramCounts[state.path[state.index].toLowerCase()];

  state.index++;
  skipSpaces(state);

  state.data = [];

  if (!need_params) {
    // Z
    finalizeSegment(state);
    return;
  }

  comma_found = false;

  for (;;) {
    for (i = need_params; i > 0; i--) {
      if (is_arc && (i === 3 || i === 4)) scanFlag(state);
      else scanParam(state);

      if (state.err.length) {
        return;
      }
      state.data.push(state.param);

      skipSpaces(state);
      comma_found = false;

      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {
        state.index++;
        skipSpaces(state);
        comma_found = true;
      }
    }

    // after ',' param is mandatory
    if (comma_found) {
      continue;
    }

    if (state.index >= state.max) {
      break;
    }

    // Stop on next segment
    if (!isDigitStart(state.path.charCodeAt(state.index))) {
      break;
    }
  }

  finalizeSegment(state);
}


/* Returns array of segments:
 *
 * [
 *   [ command, coord1, coord2, ... ]
 * ]
 */
module.exports = function pathParse(svgPath) {
  var state = new State(svgPath);
  var max = state.max;

  skipSpaces(state);

  while (state.index < max && !state.err.length) {
    scanSegment(state);
  }

  if (state.err.length) {
    state.result = [];

  } else if (state.result.length) {

    if ('mM'.indexOf(state.result[0][0]) < 0) {
      state.err = 'SvgPath: string should start with `M` or `m`';
      state.result = [];
    } else {
      state.result[0][0] = 'M';
    }
  }

  return {
    err: state.err,
    segments: state.result
  };
};


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var Matrix = __webpack_require__(180);

var operations = {
  matrix: true,
  scale: true,
  rotate: true,
  translate: true,
  skewX: true,
  skewY: true
};

var CMD_SPLIT_RE    = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
var PARAMS_SPLIT_RE = /[\s,]+/;


module.exports = function transformParse(transformString) {
  var matrix = new Matrix();
  var cmd, params;

  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']
  transformString.split(CMD_SPLIT_RE).forEach(function (item) {

    // Skip empty elements
    if (!item.length) { return; }

    // remember operation
    if (typeof operations[item] !== 'undefined') {
      cmd = item;
      return;
    }

    // extract params & att operation to matrix
    params = item.split(PARAMS_SPLIT_RE).map(function (i) {
      return +i || 0;
    });

    // If params count is not correct - ignore command
    switch (cmd) {
      case 'matrix':
        if (params.length === 6) {
          matrix.matrix(params);
        }
        return;

      case 'scale':
        if (params.length === 1) {
          matrix.scale(params[0], params[0]);
        } else if (params.length === 2) {
          matrix.scale(params[0], params[1]);
        }
        return;

      case 'rotate':
        if (params.length === 1) {
          matrix.rotate(params[0], 0, 0);
        } else if (params.length === 3) {
          matrix.rotate(params[0], params[1], params[2]);
        }
        return;

      case 'translate':
        if (params.length === 1) {
          matrix.translate(params[0], 0);
        } else if (params.length === 2) {
          matrix.translate(params[0], params[1]);
        }
        return;

      case 'skewX':
        if (params.length === 1) {
          matrix.skewX(params[0]);
        }
        return;

      case 'skewY':
        if (params.length === 1) {
          matrix.skewY(params[0]);
        }
        return;
    }
  });

  return matrix;
};


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert an arc to a sequence of cubic bézier curves
//



var TAU = Math.PI * 2;


/* eslint-disable space-infix-ops */

// Calculate an angle between two unit vectors
//
// Since we measure angle between radii of circular arcs,
// we can use simplified math (without length normalization)
//
function unit_vector_angle(ux, uy, vx, vy) {
  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
  var dot  = ux * vx + uy * vy;

  // Add this to work with arbitrary vectors:
  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);

  // rounding errors, e.g. -1.0000000000000002 can screw up this
  if (dot >  1.0) { dot =  1.0; }
  if (dot < -1.0) { dot = -1.0; }

  return sign * Math.acos(dot);
}


// Convert from endpoint to center parameterization,
// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
//
// Return [cx, cy, theta1, delta_theta]
//
function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
  // Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  var rx_sq  =  rx * rx;
  var ry_sq  =  ry * ry;
  var x1p_sq = x1p * x1p;
  var y1p_sq = y1p * y1p;

  // Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //
  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);

  if (radicant < 0) {
    // due to rounding errors it might be e.g. -1.3877787807814457e-17
    radicant = 0;
  }

  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);
  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

  var cxp = radicant *  rx/ry * y1p;
  var cyp = radicant * -ry/rx * x1p;

  // Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //
  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;
  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;

  // Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //
  var v1x =  (x1p - cxp) / rx;
  var v1y =  (y1p - cyp) / ry;
  var v2x = (-x1p - cxp) / rx;
  var v2y = (-y1p - cyp) / ry;

  var theta1 = unit_vector_angle(1, 0, v1x, v1y);
  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);

  if (fs === 0 && delta_theta > 0) {
    delta_theta -= TAU;
  }
  if (fs === 1 && delta_theta < 0) {
    delta_theta += TAU;
  }

  return [ cx, cy, theta1, delta_theta ];
}

//
// Approximate one unit arc segment with bézier curves,
// see http://math.stackexchange.com/questions/873224
//
function approximate_unit_arc(theta1, delta_theta) {
  var alpha = 4/3 * Math.tan(delta_theta/4);

  var x1 = Math.cos(theta1);
  var y1 = Math.sin(theta1);
  var x2 = Math.cos(theta1 + delta_theta);
  var y2 = Math.sin(theta1 + delta_theta);

  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];
}

module.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
  var sin_phi = Math.sin(phi * TAU / 360);
  var cos_phi = Math.cos(phi * TAU / 360);

  // Make sure radii are valid
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  if (x1p === 0 && y1p === 0) {
    // we're asked to draw line to itself
    return [];
  }

  if (rx === 0 || ry === 0) {
    // one of the radii is zero
    return [];
  }


  // Compensate out-of-range radii
  //
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }


  // Get center parameters (cx, cy, theta1, delta_theta)
  //
  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);

  var result = [];
  var theta1 = cc[2];
  var delta_theta = cc[3];

  // Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //
  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
  delta_theta /= segments;

  for (var i = 0; i < segments; i++) {
    result.push(approximate_unit_arc(theta1, delta_theta));
    theta1 += delta_theta;
  }

  // We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //
  return result.map(function (curve) {
    for (var i = 0; i < curve.length; i += 2) {
      var x = curve[i + 0];
      var y = curve[i + 1];

      // scale
      x *= rx;
      y *= ry;

      // rotate
      var xp = cos_phi*x - sin_phi*y;
      var yp = sin_phi*x + cos_phi*y;

      // translate
      curve[i + 0] = xp + cc[0];
      curve[i + 1] = yp + cc[1];
    }

    return curve;
  });
};


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable space-infix-ops */

// The precision used to consider an ellipse as a circle
//
var epsilon = 0.0000000001;

// To convert degree in radians
//
var torad = Math.PI / 180;

// Class constructor :
//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.
//
function Ellipse(rx, ry, ax) {
  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }
  this.rx = rx;
  this.ry = ry;
  this.ax = ax;
}

// Apply a linear transform m to the ellipse
// m is an array representing a matrix :
//    -         -
//   | m[0] m[2] |
//   | m[1] m[3] |
//    -         -
//
Ellipse.prototype.transform = function (m) {
  // We consider the current ellipse as image of the unit circle
  // by first scale(rx,ry) and then rotate(ax) ...
  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.
  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);
  var ma = [
    this.rx * (m[0]*c + m[2]*s),
    this.rx * (m[1]*c + m[3]*s),
    this.ry * (-m[0]*s + m[2]*c),
    this.ry * (-m[1]*s + m[3]*c)
  ];

  // ma * transpose(ma) = [ J L ]
  //                      [ L K ]
  // L is calculated later (if the image is not a circle)
  var J = ma[0]*ma[0] + ma[2]*ma[2],
      K = ma[1]*ma[1] + ma[3]*ma[3];

  // the discriminant of the characteristic polynomial of ma * transpose(ma)
  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *
          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));

  // the "mean eigenvalue"
  var JK = (J + K) / 2;

  // check if the image is (almost) a circle
  if (D < epsilon * JK) {
    // if it is
    this.rx = this.ry = Math.sqrt(JK);
    this.ax = 0;
    return this;
  }

  // if it is not a circle
  var L = ma[0]*ma[1] + ma[2]*ma[3];

  D = Math.sqrt(D);

  // {l1,l2} = the two eigen values of ma * transpose(ma)
  var l1 = JK + D/2,
      l2 = JK - D/2;
  // the x - axis - rotation angle is the argument of the l1 - eigenvector
  /*eslint-disable indent*/
  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?
    90
  :
    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?
      (l1 - J) / L
    :
      L / (l1 - K)
    ) * 180 / Math.PI;
  /*eslint-enable indent*/

  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90
  if (this.ax >= 0) {
    // if ax in [0,90]
    this.rx = Math.sqrt(l1);
    this.ry = Math.sqrt(l2);
  } else {
    // if ax in ]-90,0[ => exchange axes
    this.ax += 90;
    this.rx = Math.sqrt(l2);
    this.ry = Math.sqrt(l1);
  }

  return this;
};

// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0
//
Ellipse.prototype.isDegenerate = function () {
  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);
};

module.exports = Ellipse;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var Annotation_1 = __importDefault(__webpack_require__(49));
var AnnotationCalloutCircle_1 = __importDefault(__webpack_require__(125));
var d3_hierarchy_1 = __webpack_require__(98);
var baseRules_1 = __webpack_require__(51);
var SpanOrDiv_1 = __importDefault(__webpack_require__(41));
var TooltipPositioner_1 = __importDefault(__webpack_require__(124));
exports.htmlFrameHoverRule = function (_a) {
    var baseD = _a.d, i = _a.i, tooltipContent = _a.tooltipContent, optimizeCustomTooltipPosition = _a.optimizeCustomTooltipPosition, useSpans = _a.useSpans, nodes = _a.nodes, edges = _a.edges, nodeIDAccessor = _a.nodeIDAccessor;
    var d = baseD.x && baseD.y
        ? baseD
        : baseD.edge
            ? __assign(__assign({}, (edges.find(function (p) {
                return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) &&
                    nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
            }) || {})), baseD) : nodes.find(function (p) { return nodeIDAccessor(p) === baseD.id; });
    if (!d)
        return null;
    var content = d.edge ? (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" },
        React.createElement("p", { key: "html-annotation-content-1" },
            (d.source || d.edge.source).id,
            " to ",
            (d.target || d.edge.target).id))) : (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" },
        React.createElement("p", { key: "html-annotation-content-1" }, d.id),
        React.createElement("p", { key: "html-annotation-content-2" },
            "Degree: ",
            d.degree)));
    if (d.type === "frame-hover" && tooltipContent) {
        content = optimizeCustomTooltipPosition ? (React.createElement(TooltipPositioner_1.default, { tooltipContent: tooltipContent, tooltipContentArgs: d })) : tooltipContent(d);
    }
    return (React.createElement(SpanOrDiv_1.default, { span: useSpans, key: "network-annotation-label-" + i, className: "annotation annotation-network-label " + (d.className || ""), style: {
            position: "absolute",
            top: d.y + "px",
            left: d.x + "px"
        } }, content));
};
exports.svgNodeRule = function (_a) {
    var d = _a.d, i = _a.i, nodeSizeAccessor = _a.nodeSizeAccessor;
    if (!d) {
        return null;
    }
    var noteData = Object.assign({
        dx: d.dx || -25,
        dy: d.dy || -25,
        x: d.x,
        y: d.y,
        note: { label: d.label, orientation: d.orientation, align: d.align },
        connector: { end: "arrow" }
    }, d, {
        type: AnnotationCalloutCircle_1.default,
        subject: {
            radius: d.radius || d.radius || nodeSizeAccessor(d)
        }
    });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgReactAnnotationRule = function (_a) {
    var d = _a.d, i = _a.i, projectedNodes = _a.projectedNodes, nodeIDAccessor = _a.nodeIDAccessor;
    var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) { return nodeIDAccessor(p) === d.id; });
    if (!selectedNode) {
        return null;
    }
    var noteData = Object.assign({
        dx: 0,
        dy: 0,
        x: selectedNode.x,
        y: selectedNode.y,
        note: { label: d.label },
        connector: { end: "arrow" }
    }, d, { type: typeof d.type === "function" ? d.type : undefined });
    return React.createElement(Annotation_1.default, { key: d.key || "annotation-" + i, noteData: noteData });
};
exports.svgEncloseRule = function (_a) {
    var d = _a.d, i = _a.i, projectedNodes = _a.projectedNodes, nodeIDAccessor = _a.nodeIDAccessor, nodeSizeAccessor = _a.nodeSizeAccessor;
    var selectedNodes = projectedNodes.filter(function (p) { return d.ids.indexOf(nodeIDAccessor(p)) !== -1; });
    if (selectedNodes.length === 0) {
        return null;
    }
    var circle = d3_hierarchy_1.packEnclose(selectedNodes.map(function (p) { return ({ x: p.x, y: p.y, r: nodeSizeAccessor(p) }); }));
    return baseRules_1.circleEnclosure({ circle: circle, d: d, i: i });
};
exports.svgRectEncloseRule = function (_a) {
    var d = _a.d, i = _a.i, projectedNodes = _a.projectedNodes, nodeIDAccessor = _a.nodeIDAccessor, nodeSizeAccessor = _a.nodeSizeAccessor;
    var selectedNodes = projectedNodes.filter(function (p) { return d.ids.indexOf(nodeIDAccessor(p)) !== -1; });
    if (selectedNodes.length === 0) {
        return null;
    }
    var bboxNodes = selectedNodes.map(function (p) {
        if (p.shapeNode) {
            return {
                x0: p.x0,
                x1: p.x1,
                y0: p.y0,
                y1: p.y1
            };
        }
        var nodeSize = nodeSizeAccessor(p);
        return {
            x0: p.x - nodeSize,
            x1: p.x + nodeSize,
            y0: p.y - nodeSize,
            y1: p.y + nodeSize
        };
    });
    return baseRules_1.rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};
exports.svgHullEncloseRule = function (_a) {
    var d = _a.d, i = _a.i, projectedNodes = _a.projectedNodes, nodeIDAccessor = _a.nodeIDAccessor, nodeSizeAccessor = _a.nodeSizeAccessor;
    var selectedNodes = projectedNodes.filter(function (p) { return d.ids.indexOf(nodeIDAccessor(p)) !== -1; });
    if (selectedNodes.length === 0) {
        return null;
    }
    var projectedPoints = [];
    selectedNodes.forEach(function (p) {
        if (p.shapeNode) {
            projectedPoints.push({ x: p.x0, y: p.y0 });
            projectedPoints.push({ x: p.x0, y: p.y1 });
            projectedPoints.push({ x: p.x1, y: p.y0 });
            projectedPoints.push({ x: p.x1, y: p.y1 });
        }
        else {
            var nodeSize = nodeSizeAccessor(p);
            projectedPoints.push({ x: p.x - nodeSize, y: p.y - nodeSize });
            projectedPoints.push({ x: p.x + nodeSize, y: p.y - nodeSize });
            projectedPoints.push({ x: p.x - nodeSize, y: p.y + nodeSize });
            projectedPoints.push({ x: p.x + nodeSize, y: p.y + nodeSize });
        }
    });
    return baseRules_1.hullEnclosure({ points: projectedPoints.map(function (d) { return [d.x, d.y]; }), d: d, i: i });
};
exports.svgHighlightRule = function (_a) {
    var d = _a.d, i = _a.i, networkFrameRender = _a.networkFrameRender;
    var nodes = networkFrameRender.nodes;
    var customMark = nodes.customMark, baseStyle = nodes.styleFn;
    var styleFn = baseStyle;
    if (d.style && typeof d.style === "function") {
        styleFn = function (d) { return (__assign(__assign({}, baseStyle(d)), d.style(d))); };
    }
    else if (d.style) {
        styleFn = function (d) { return (__assign(__assign({}, baseStyle(d)), d.style)); };
    }
    var transform = "translate(" + d.x + "," + d.y + ")";
    var baseMarkProps = { forceUpdate: true };
    var HighlightMark = customMark({ d: d, styleFn: styleFn, transform: transform, baseMarkProps: baseMarkProps, key: "highlight-" + i });
    return HighlightMark;
};


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var semiotic_mark_1 = __webpack_require__(15);
var d3_glyphedge_1 = __webpack_require__(319);
var d3_shape_1 = __webpack_require__(18);
var SvgHelper_1 = __webpack_require__(71);
var d3_interpolate_1 = __webpack_require__(12);
var d3_scale_1 = __webpack_require__(24);
var SvgHelper_2 = __webpack_require__(71);
var horizontalDagreLineGenerator = d3_shape_1.line()
    .curve(d3_shape_1.curveMonotoneX)
    .x(function (d) { return d.x; })
    .y(function (d) { return d.y; });
var verticalDagreLineGenerator = d3_shape_1.line()
    .curve(d3_shape_1.curveMonotoneY)
    .x(function (d) { return d.x; })
    .y(function (d) { return d.y; });
function sankeyEdgeSort(a, b, direction) {
    if (a.circular && !b.circular)
        return -1;
    if (b.circular && !a.circular)
        return 1;
    var first = direction === "down" ? "y" : "x";
    var second = direction === "down" ? "x" : "y";
    return a.source[first] === b.source[first]
        ? a.sankeyWidth === b.sankeyWidth
            ? a.source[second] - b.source[second]
            : b.sankeyWidth - a.sankeyWidth
        : a.source[first] - b.source[first];
}
var sigmoidLinks = {
    horizontal: d3_shape_1.linkHorizontal()
        .x(function (d) { return d.x; })
        .y(function (d) { return d.y; }),
    vertical: d3_shape_1.linkVertical()
        .x(function (d) { return d.x; })
        .y(function (d) { return d.y; }),
    radial: d3_glyphedge_1.d.lineArc
};
var customEdgeHashD = {
    curve: function (d, projection) {
        if (projection === void 0) { projection = "vertical"; }
        return sigmoidLinks[projection](d);
    },
    linearc: function (d) { return d3_glyphedge_1.d.lineArc(d); },
    ribbon: function (d) { return d3_glyphedge_1.d.ribbon(d, d.width); },
    arrowhead: function (d) {
        return d3_glyphedge_1.d.arrowHead(d, d.target.nodeSize, d.width, d.width * 1.5);
    },
    halfarrow: function (d) {
        return d3_glyphedge_1.d.halfArrow(d, d.target.nodeSize, d.width, d.width * 1.5);
    },
    nail: function (d) { return d3_glyphedge_1.d.nail(d, d.source.nodeSize); },
    comet: function (d) { return d3_glyphedge_1.d.comet(d, d.target.nodeSize); },
    taffy: function (d) {
        return d3_glyphedge_1.d.taffy(d, d.source.nodeSize / 2, d.target.nodeSize / 2, (d.source.nodeSize + d.target.nodeSize) / 4);
    }
};
exports.radialCurveGenerator = function (size) {
    var radialCurve = d3_shape_1.linkRadial()
        .angle(function (d) { return (d.x / size[0]) * Math.PI * 2; })
        .radius(function (d) { return d.y; });
    return function (_a) {
        var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
        return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: key, transform: "translate(" + 50 + "," + (size[1] / 2 - 50) + ")", markType: "path", d: radialCurve(d), style: styleFn(d, i), renderMode: renderMode ? renderMode(d, i) : undefined, className: className, "aria-label": "Node " + d.id, tabIndex: -1 })));
    };
};
exports.circleNodeGenerator = function (_a) {
    //this is repetitious
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, transform = _a.transform, baseMarkProps = _a.baseMarkProps;
    return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: key, transform: transform, markType: "rect", width: d.nodeSize * 2, height: d.nodeSize * 2, ry: d.nodeSize * 2, rx: d.nodeSize * 2, x: -d.nodeSize, y: -d.nodeSize, style: styleFn(d, i), renderMode: renderMode ? renderMode(d, i) : undefined, className: className, "aria-label": "Node " + d.id, tabIndex: -1 })));
};
exports.matrixEdgeGenerator = function (size, nodes) { return function (_a) {
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
    var gridSize = Math.min.apply(Math, __spread(size)) / nodes.length;
    return (React.createElement("g", { key: key },
        React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, simpleInterpolate: true, transform: "translate(" + d.source.y + "," + d.target.y + ")", markType: "rect", x: -gridSize / 2, y: -gridSize / 2, width: gridSize, height: gridSize, style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 })),
        React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key + "-mirror", className: className, simpleInterpolate: true, transform: "translate(" + d.target.y + "," + d.source.y + ")", markType: "rect", x: -gridSize / 2, y: -gridSize / 2, width: gridSize, height: gridSize, style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 }))));
}; };
exports.arcEdgeGenerator = function (size) {
    var yAdjust = size[1] / size[0];
    function arcDiagramArc(d) {
        var draw = d3_shape_1.line().curve(d3_shape_1.curveBasis);
        var midX = (d.source.x + d.target.x) / 2;
        var midY = d.source.x - d.target.x;
        return draw([[d.source.x, 0], [midX, midY * yAdjust], [d.target.x, 0]]);
    }
    return function (_a) {
        var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
        return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, simpleInterpolate: true, markType: "path", transform: "translate(0," + size[1] / 2 + ")", d: arcDiagramArc(d), style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 })));
    };
};
exports.chordEdgeGenerator = function (size) { return function (_a) {
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
    return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, simpleInterpolate: true, transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")", markType: "path", d: d.d, style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 })));
}; };
exports.dagreEdgeGenerator = function (direction) {
    var dagreLineGenerator = direction === "LR" || direction === "RL"
        ? horizontalDagreLineGenerator
        : verticalDagreLineGenerator;
    return function (_a) {
        var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
        if (d.ribbon || d.parallelEdges) {
            var ribbonGenerator = SvgHelper_1.linearRibbon();
            ribbonGenerator.x(function (p) { return p.x; });
            ribbonGenerator.y(function (p) { return p.y; });
            ribbonGenerator.r(function () { return d.weight || 1; });
            if (d.parallelEdges) {
                var sortedParallelEdges_1 = d.parallelEdges.sort(function (a, b) { return b.weight - a.weight; });
                return (React.createElement("g", { key: "" + key }, ribbonGenerator({
                    points: d.points,
                    multiple: d.parallelEdges
                }).map(function (ribbonD, ribbonI) { return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key + "-" + ribbonI, className: className, simpleInterpolate: true, markType: "path", d: ribbonD, style: styleFn(sortedParallelEdges_1[ribbonI], i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 }))); })));
            }
            return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, simpleInterpolate: true, markType: "path", d: ribbonGenerator(d.points), style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 })));
        }
        return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, simpleInterpolate: true, markType: "path", d: dagreLineGenerator(d.points), style: styleFn(d, i), "aria-label": "Connection from " + d.source.id + " to " + d.target.id, tabIndex: -1 })));
    };
};
exports.sankeyNodeGenerator = function (_a) {
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, transform = _a.transform, baseMarkProps = _a.baseMarkProps;
    var height = d.direction !== "down" ? d.height : d.width;
    var width = d.direction !== "down" ? d.width : d.height;
    return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, transform: transform, markType: "rect", height: height, width: width, x: -width / 2, y: -height / 2, rx: 0, ry: 0, style: styleFn(d), "aria-label": "Node " + d.id, tabIndex: -1 })));
};
exports.chordNodeGenerator = function (size) { return function (_a) {
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
    return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { renderMode: renderMode ? renderMode(d, i) : undefined, key: key, className: className, transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")", markType: "path", d: d.d, style: styleFn(d, i), "aria-label": "Node " + d.id, tabIndex: -1 })));
}; };
exports.matrixNodeGenerator = function (size, nodes) {
    var gridSize = Math.min.apply(Math, __spread(size));
    var stepSize = gridSize / (nodes.length + 1);
    return function (_a) {
        var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
        var showText = stepSize > 6;
        var showLine = stepSize > 3;
        var showRect = stepSize > 0.5;
        var textProps = {
            textAnchor: "end",
            fontSize: stepSize / 2 + "px"
        };
        var style = styleFn(d, i);
        var renderModeValue = renderMode ? renderMode(d, i) : undefined;
        return (React.createElement("g", { key: key, className: className },
            showRect && (React.createElement(semiotic_mark_1.Mark, { markType: "rect", x: stepSize / 2, y: d.y - stepSize / 2, width: gridSize - stepSize, height: stepSize, style: __assign(__assign({}, style), { stroke: "none" }), renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showRect && (React.createElement(semiotic_mark_1.Mark, { markType: "rect", y: stepSize / 2, x: d.y - stepSize / 2, height: gridSize - stepSize, width: stepSize, style: __assign(__assign({}, style), { stroke: "none" }), renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showLine && (React.createElement(semiotic_mark_1.Mark, { markType: "line", stroke: "black", x1: 0, x2: gridSize - stepSize / 2, y1: d.y - stepSize / 2, y2: d.y - stepSize / 2, style: style, renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showLine && (React.createElement(semiotic_mark_1.Mark, { markType: "line", stroke: "black", y1: 0, y2: gridSize - stepSize / 2, x1: d.y - stepSize / 2, x2: d.y - stepSize / 2, style: style, renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showLine && i === nodes.length - 1 && (React.createElement(semiotic_mark_1.Mark, { markType: "line", stroke: "black", x1: 0, x2: gridSize - stepSize / 2, y1: d.y + stepSize / 2, y2: d.y + stepSize / 2, style: style, renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showLine && i === nodes.length - 1 && (React.createElement(semiotic_mark_1.Mark, { markType: "line", stroke: "black", y1: 0, y2: gridSize - stepSize / 2, x1: d.y + stepSize / 2, x2: d.y + stepSize / 2, style: style, renderMode: renderModeValue, forceUpdate: true, baseMarkProps: baseMarkProps })),
            showText && (React.createElement("text", __assign({ x: 0, y: d.y + stepSize / 5 }, textProps), d.id)),
            showText && (React.createElement("text", __assign({ transform: "translate(" + d.y + ") rotate(90) translate(0," + stepSize /
                    5 + ")" }, textProps, { y: 0 }), d.id))));
    };
};
exports.radialRectNodeGenerator = function (size, center, type) {
    var radialArc = d3_shape_1.arc();
    var _a = type.angleRange, angleRange = _a === void 0 ? [0, 360] : _a;
    var rangePct = angleRange.map(function (d) { return d / 360; });
    var rangeMod = rangePct[1] - rangePct[0];
    var adjustedPct = rangeMod < 1
        ? d3_scale_1.scaleLinear()
            .domain([0, 1])
            .range(rangePct)
        : function (d) { return d; };
    return function (_a) {
        var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
        radialArc.innerRadius(d.y0 / 2).outerRadius(d.y1 / 2);
        return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: key, transform: "translate(" + center + ")", markType: "path", d: radialArc({
                startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
                endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2
            }), customTween: {
                fn: SvgHelper_2.arcTweener,
                props: {
                    startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
                    endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2,
                    innerRadius: d.y0 / 2,
                    outerRadius: d.y1 / 2
                }
            }, style: styleFn(d, i), renderMode: renderMode ? renderMode(d, i) : undefined, className: className, "aria-label": "Node " + d.id, tabIndex: -1 })));
    };
};
exports.radialLabelGenerator = function (node, nodei, nodeIDAccessor, size) {
    var anglePct = (node.x1 + node.x0) / 2 / size[0];
    var nodeLabel = nodeIDAccessor(node, nodei);
    var labelRotate = anglePct > 0.5 ? anglePct * 360 + 90 : anglePct * 360 - 90;
    return (React.createElement("g", { transform: "rotate(" + labelRotate + ")" }, typeof nodeLabel === "string" ? (React.createElement("text", { textAnchor: "middle", y: 5 }, nodeLabel)) : (nodeLabel)));
};
exports.hierarchicalRectNodeGenerator = function (_a) {
    var d = _a.d, i = _a.i, styleFn = _a.styleFn, renderMode = _a.renderMode, key = _a.key, className = _a.className, baseMarkProps = _a.baseMarkProps;
    //this is repetitious
    return (React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: key, transform: "translate(0,0)", markType: "rect", width: d.x1 - d.x0, height: d.y1 - d.y0, x: d.x0, y: d.y0, rx: 0, ry: 0, style: styleFn(d, i), renderMode: renderMode ? renderMode(d, i) : undefined, className: className, "aria-label": "Node " + d.id, tabIndex: -1 })));
};
var genericLineGenerator = function (d) {
    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
};
exports.drawNodes = function (_a) {
    var data = _a.data, renderKeyFn = _a.renderKeyFn, customMark = _a.customMark, styleFn = _a.styleFn, classFn = _a.classFn, renderMode = _a.renderMode, canvasDrawing = _a.canvasDrawing, canvasRenderFn = _a.canvasRenderFn, baseMarkProps = _a.baseMarkProps;
    var markGenerator = customMark;
    var renderedData = [];
    if (customMark && canvasRenderFn) {
        console.error("canvas rendering currently only supports generic circle nodes based on nodeSize");
    }
    data.forEach(function (d, i) {
        if (canvasRenderFn && canvasRenderFn(d, i) === true) {
            var canvasNode = {
                baseClass: "frame-piece",
                tx: d.x,
                ty: d.y,
                d: d,
                i: i,
                markProps: { markType: "circle", r: d.nodeSize },
                styleFn: styleFn,
                renderFn: renderMode,
                classFn: classFn
            };
            canvasDrawing.push(canvasNode);
        }
        else {
            // CUSTOM MARK IMPLEMENTATION
            renderedData.push(markGenerator({
                d: d,
                i: i,
                renderKeyFn: renderKeyFn,
                styleFn: styleFn,
                classFn: classFn,
                renderMode: renderMode,
                key: renderKeyFn ? renderKeyFn(d, i) : d.id || "node-" + i,
                className: "node " + classFn(d, i),
                transform: "translate(" + d.x + "," + d.y + ")",
                baseMarkProps: baseMarkProps
            }));
        }
    });
    return renderedData;
};
exports.drawEdges = function (_a) {
    var baseData = _a.data, renderKeyFn = _a.renderKeyFn, customMark = _a.customMark, styleFn = _a.styleFn, classFn = _a.classFn, renderMode = _a.renderMode, canvasRenderFn = _a.canvasRenderFn, canvasDrawing = _a.canvasDrawing, type = _a.type, baseMarkProps = _a.baseMarkProps, networkSettings = _a.networkSettings, projection = _a.projection;
    var networkType = networkSettings.type, direction = networkSettings.direction, _b = networkSettings.edgeSort, edgeSort = _b === void 0 ? sankeyEdgeSort : _b;
    var data = networkType === "sankey"
        ? baseData.sort(function (a, b) { return edgeSort(a, b, direction); })
        : baseData;
    var dGenerator = genericLineGenerator;
    var renderedData = [];
    if (customMark) {
        // CUSTOM MARK IMPLEMENTATION
        data.forEach(function (d, i) {
            var renderedCustomMark = customMark({
                d: d,
                i: i,
                renderKeyFn: renderKeyFn,
                styleFn: styleFn,
                classFn: classFn,
                renderMode: renderMode,
                key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i,
                className: classFn(d, i) + " edge",
                transform: "translate(" + d.x + "," + d.y + ")",
                baseMarkProps: baseMarkProps
            });
            if (renderedCustomMark &&
                renderedCustomMark.props &&
                (renderedCustomMark.props.markType !== "path" ||
                    renderedCustomMark.props.d)) {
                renderedData.push(renderedCustomMark);
            }
        });
    }
    else {
        if (type) {
            if (typeof type === "function") {
                dGenerator = type;
            }
            else if (customEdgeHashD[type]) {
                dGenerator = function (d) { return customEdgeHashD[type](d, projection); };
            }
        }
        data.forEach(function (d, i) {
            var renderedD = dGenerator(d);
            if (renderedD && canvasRenderFn && canvasRenderFn(d, i) === true) {
                var canvasEdge = {
                    baseClass: "frame-piece",
                    tx: d.x,
                    ty: d.y,
                    d: d,
                    i: i,
                    markProps: { markType: "path", d: renderedD },
                    styleFn: styleFn,
                    renderFn: renderMode,
                    classFn: classFn
                };
                canvasDrawing.push(canvasEdge);
            }
            else if (renderedD) {
                renderedData.push(React.createElement(semiotic_mark_1.Mark, __assign({}, baseMarkProps, { key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i, markType: "path", renderMode: renderMode ? renderMode(d, i) : undefined, className: classFn(d) + " edge", d: renderedD, style: styleFn(d, i), tabIndex: -1, role: "img", "aria-label": "connection from " + d.source.id + " to " + d.target.id })));
            }
        });
    }
    return renderedData;
};
function topologicalSort(nodesArray, edgesArray) {
    // adapted from https://simplapi.wordpress.com/2015/08/19/detect-graph-cycle-in-javascript/
    var nodes = [];
    var nodeHash = {};
    edgesArray.forEach(function (edge) {
        if (!edge.source.id || !edge.target.id) {
            return false;
        }
        if (!nodeHash[edge.source.id]) {
            nodeHash[edge.source.id] = { _id: edge.source.id, links: [] };
            nodes.push(nodeHash[edge.source.id]);
        }
        if (!nodeHash[edge.target.id]) {
            nodeHash[edge.target.id] = { _id: edge.target.id, links: [] };
            nodes.push(nodeHash[edge.target.id]);
        }
        nodeHash[edge.source.id].links.push(edge.target.id);
    });
    // Test if a node got any icoming edge
    function hasIncomingEdge(list, node) {
        for (var i = 0, l = list.length; i < l; ++i) {
            if (list[i].links.indexOf(node._id) !== -1) {
                return true;
            }
        }
        return false;
    }
    // Kahn Algorithm
    var L = [], S = nodes.filter(function (node) { return !hasIncomingEdge(nodes, node); });
    var n = null;
    while (S.length) {
        // Remove a node n from S
        n = S.pop();
        // Add n to tail of L
        L.push(n);
        var i = n.links.length;
        while (i--) {
            // Getting the node associated to the current stored id in links
            var m = nodes[nodes.map(function (d) { return d._id; }).indexOf(n.links[i])];
            // Remove edge e from the graph
            n.links.pop();
            if (!hasIncomingEdge(nodes, m)) {
                S.push(m);
            }
        }
    }
    // If any of them still got links, there is cycle somewhere
    var nodeWithEdge = nodes.find(function (node) { return node.links.length !== 0; });
    return nodeWithEdge ? null : L;
}
exports.topologicalSort = topologicalSort;
var curvature = 0.5;
exports.ribbonLink = function (d) {
    var diff = d.direction === "down"
        ? Math.abs(d.target.y - d.source.y)
        : Math.abs(d.source.x - d.target.x);
    // const halfWidth = d.width / 2
    var testCoordinates = d.direction === "down"
        ? [
            {
                x: d.y0,
                y: d.source.y
            },
            {
                x: d.y0,
                y: d.source.y + diff / 3
            },
            {
                x: d.y1,
                y: d.target.y - diff / 3
            },
            {
                x: d.y1,
                y: d.target.y
            }
        ]
        : [
            {
                x: d.source.x0,
                y: d.y0
            },
            {
                x: d.source.x0 + diff / 3,
                y: d.y0
            },
            {
                x: d.target.x0 - diff / 3,
                y: d.y1
            },
            {
                x: d.target.x0,
                y: d.y1
            }
        ];
    var linkGenerator = SvgHelper_1.linearRibbon();
    linkGenerator.x(function (d) { return d.x; });
    linkGenerator.y(function (d) { return d.y; });
    linkGenerator.r(function () { return d.sankeyWidth / 2; });
    return linkGenerator(testCoordinates);
};
exports.areaLink = function (d) {
    var x0, x1, x2, x3, y0, y1, xi, y2, y3;
    if (d.direction === "down") {
        x0 = d.y0 - d.sankeyWidth / 2;
        x1 = d.y1 - d.sankeyWidth / 2;
        x2 = d.y1 + d.sankeyWidth / 2;
        x3 = d.y0 + d.sankeyWidth / 2;
        y0 = d.source.y1;
        y1 = d.target.y0;
        xi = d3_interpolate_1.interpolateNumber(y0, y1);
        y2 = xi(curvature);
        y3 = xi(1 - curvature);
        return "M" + x0 + "," + y0 + "C" + x0 + "," + y2 + " " + x1 + "," + y3 + " " + x1 + "," + y1 + "L" + x2 + "," + y1 + "C" + x2 + "," + y3 + " " + x3 + "," + y2 + " " + x3 + "," + y0 + "Z";
    }
    ;
    (x0 = d.source.x1), // eslint-disable-line no-sequences
        (x1 = d.target.x0),
        (xi = d3_interpolate_1.interpolateNumber(x0, x1)),
        (x2 = xi(curvature)),
        (x3 = xi(1 - curvature)),
        (y0 = d.y0 - d.sankeyWidth / 2),
        (y1 = d.y1 - d.sankeyWidth / 2),
        (y2 = d.y1 + d.sankeyWidth / 2),
        (y3 = d.y0 + d.sankeyWidth / 2);
    return "M" + x0 + "," + y0 + "C" + x2 + "," + y0 + " " + x3 + "," + y1 + " " + x1 + "," + y1 + "L" + x1 + "," + y2 + "C" + x3 + "," + y2 + " " + x2 + "," + y3 + " " + x0 + "," + y3 + "Z";
};
function circularAreaLink(link) {
    var linkGenerator = SvgHelper_1.linearRibbon();
    linkGenerator.x(function (d) { return d.x; });
    linkGenerator.y(function (d) { return d.y; });
    linkGenerator.r(function () { return link.sankeyWidth / 2; });
    var xyForLink = link.direction === "down"
        ? [
            {
                x: link.circularPathData.sourceY,
                y: link.circularPathData.sourceX
            },
            {
                x: link.circularPathData.sourceY,
                y: link.circularPathData.leftFullExtent
            },
            {
                x: link.circularPathData.verticalFullExtent,
                y: link.circularPathData.leftFullExtent
            },
            {
                x: link.circularPathData.verticalFullExtent,
                y: link.circularPathData.rightFullExtent
            },
            {
                x: link.circularPathData.targetY,
                y: link.circularPathData.rightFullExtent
            },
            {
                x: link.circularPathData.targetY,
                y: link.circularPathData.targetX
            }
        ]
        : [
            {
                x: link.circularPathData.sourceX,
                y: link.circularPathData.sourceY
            },
            {
                x: link.circularPathData.leftFullExtent,
                y: link.circularPathData.sourceY
            },
            {
                x: link.circularPathData.leftFullExtent,
                y: link.circularPathData.verticalFullExtent
            },
            {
                x: link.circularPathData.rightFullExtent,
                y: link.circularPathData.verticalFullExtent
            },
            {
                x: link.circularPathData.rightFullExtent,
                y: link.circularPathData.targetY
            },
            {
                x: link.circularPathData.targetX,
                y: link.circularPathData.targetY
            }
        ];
    return linkGenerator(xyForLink);
}
exports.circularAreaLink = circularAreaLink;
var hierarchyDecorator = function (hierarchy, hashEntries, nodeIDAccessor, nodes) {
    if (hierarchy.children) {
        hierarchy.children.forEach(function (child) {
            var theseEntries = hashEntries.filter(function (entry) { return entry[1] === child.id; });
            theseEntries.forEach(function (entry) {
                var idNode = nodes.find(function (node) { return nodeIDAccessor(node) === entry[0]; }) || {};
                child.childHash[entry[0]] = __assign(__assign({ id: entry[0] }, idNode), { children: [], childHash: {} });
                child.children.push(child.childHash[entry[0]]);
            });
            if (child.children.length > 0) {
                hierarchyDecorator(child, hashEntries, nodeIDAccessor, nodes);
            }
        });
    }
};
exports.softStack = function (edges, nodes, sourceAccessor, targetAccessor, nodeIDAccessor) {
    var hierarchy = { id: "root-generated", children: [], childHash: {} };
    var discoveredHierarchyHash = {};
    var targetToSourceHash = {};
    var hasLogicalRoot = true;
    var isHierarchical = true;
    for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var source = sourceAccessor(edge);
        var target = targetAccessor(edge);
        var sourceID = typeof source === "object" ? nodeIDAccessor(source) : source;
        var targetID = typeof target === "object" ? nodeIDAccessor(target) : target;
        targetToSourceHash[targetID] = sourceID;
        if (!discoveredHierarchyHash[sourceID]) {
            discoveredHierarchyHash[sourceID] = targetID;
        }
        else {
            isHierarchical = false;
            break;
        }
    }
    if (isHierarchical) {
        var hashEntries = Object.entries(discoveredHierarchyHash);
        hashEntries.forEach(function (entry) {
            var target = entry[1];
            if (!discoveredHierarchyHash[target]) {
                discoveredHierarchyHash[target] = "root-generated";
                var idNode = nodes.find(function (node) { return nodeIDAccessor(node) === target; }) || {};
                hierarchy.childHash[target] = __assign(__assign({ id: target }, idNode), { children: [], childHash: {} });
                hierarchy.children.push(hierarchy.childHash[target]);
            }
        });
        hierarchyDecorator(hierarchy, hashEntries, nodeIDAccessor, nodes);
        nodes.forEach(function (node) {
            var nodeID = nodeIDAccessor(node);
            if (!discoveredHierarchyHash[nodeID] && !targetToSourceHash[nodeID]) {
                hierarchy.children.push(__assign(__assign({ id: nodeID }, node), { children: [], childHash: {} }));
            }
        });
        if (hierarchy.children.length === 1) {
            hierarchy = hierarchy.children[0];
            hasLogicalRoot = false;
        }
        return { hierarchy: hierarchy, isHierarchical: true, hasLogicalRoot: hasLogicalRoot };
    }
    return { hierarchy: {}, isHierarchical: false, hasLogicalRoot: false };
};


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
         true ? factory(exports) :
        undefined;
}(this, function (exports) { 'use strict';

        function halfArrow(d, nodeTargetSize, bodySize, headSize) {
            var diffX = d.target.y - d.source.y;
            var diffY = d.target.x - d.source.x;

            var headDistance = headSize * 3;

            var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
            var angle1 = angle0 - ( Math.PI / 2 );
            var angle2 = angle0 + ( Math.PI / 2 );

            var x1 = d.source.x + (headSize * Math.cos(angle1));
            var y1 = d.source.y - (headSize * Math.sin(angle1));
            var x2 = d.source.x + (headSize * Math.cos(angle2));
            var y2 = d.source.y - (headSize * Math.sin(angle2));
            var x3 = d.target.x - (headSize * Math.cos(angle1));
            var y3 = d.target.y + (headSize * Math.sin(angle1));

            var mx1 = d.source.x + (bodySize * Math.cos(angle1));
            var my1 = d.source.y - (bodySize * Math.sin(angle1));
            var mx2 = d.source.x + (bodySize * Math.cos(angle2));
            var my2 = d.source.y - (bodySize * Math.sin(angle2));

            var mx3 = d.target.x + (bodySize * Math.cos(angle1));
            var my3 = d.target.y - (bodySize * Math.sin(angle1));

            var dY = d.source.y - d.target.y;
            var dX = d.source.x - d.target.x;

            var midDiffY1 = my1 - my3;
            var midDiffX1 = mx1 - mx3;

            var diffY1 = y1 - y3;
            var diffX1 = x1 - x3;

            var pythag = Math.sqrt((midDiffX1 * midDiffX1) + (midDiffY1 * midDiffY1));
            var pythag2 = Math.sqrt((dX * dX) + (dY * dY));

            var adjX1 = mx2 - ((midDiffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var adjY1 = my2 - ((midDiffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

            var headX1 = x2 - ((diffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var headY1 = y2 - ((diffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

            var tipX = d.source.x - ((dX * (pythag2 - nodeTargetSize)) / pythag2);
            var tipY = d.source.y - ((dY * (pythag2 - nodeTargetSize)) / pythag2);

            return "M" + d.source.x + "," + d.source.y + "L" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + d.source.x + "," + d.source.y + "z";
        };

        function lineArc(d) {
          var dx = d.target.x - d.source.x,
              dy = d.target.y - d.source.y,
              dr = Math.sqrt(dx * dx + dy * dy);
          return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
        };

        function ribbon(d, bodySize) {
                var diffX = d.target.y - d.source.y;
                var diffY = d.target.x - d.source.x;

                var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
                var angle1 = angle0 - ( Math.PI / 2 );
                var angle2 = angle0 + ( Math.PI / 2 );

                var mx1 = d.source.x + (bodySize * Math.cos(angle1));
                var my1 = d.source.y - (bodySize * Math.sin(angle1));
                var mx2 = d.source.x + (bodySize * Math.cos(angle2));
                var my2 = d.source.y - (bodySize * Math.sin(angle2));

                var mx3 = d.target.x - (bodySize * Math.cos(angle1));
                var my3 = d.target.y + (bodySize * Math.sin(angle1));
                var mx4 = d.target.x - (bodySize * Math.cos(angle2));
                var my4 = d.target.y + (bodySize * Math.sin(angle2));

                return "M" + mx1 + "," + my1 + "L" + mx2 + "," + my2 + "L" + mx3 + "," + my3 + "L" + mx4 + "," + my4 + "z";
        }

        function taffy(d, nodeSourceSize, nodeTargetSize, midpointSize) {
            var diffX = d.target.y - d.source.y;
            var diffY = d.target.x - d.source.x;

            var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
            var angle1 = angle0 - ( Math.PI / 2 );
            var angle2 = angle0 + ( Math.PI / 2 );

            var x1 = d.source.x + (nodeSourceSize * Math.cos(angle1));
            var y1 = d.source.y - (nodeSourceSize * Math.sin(angle1));
            var x2 = d.source.x + (nodeSourceSize * Math.cos(angle2));
            var y2 = d.source.y - (nodeSourceSize * Math.sin(angle2));

            var x3 = d.target.x + (nodeTargetSize * Math.cos(angle2));
            var y3 = d.target.y - (nodeTargetSize * Math.sin(angle2));
            var x4 = d.target.x + (nodeTargetSize * Math.cos(angle1));
            var y4 = d.target.y - (nodeTargetSize * Math.sin(angle1));

            var mx1 = d.source.x + (midpointSize * Math.cos(angle1));
            var my1 = d.source.y - (midpointSize * Math.sin(angle1));
            var mx2 = d.source.x + (midpointSize * Math.cos(angle2));
            var my2 = d.source.y - (midpointSize * Math.sin(angle2));

            var mx3 = d.target.x + (midpointSize * Math.cos(angle1));
            var my3 = d.target.y - (midpointSize * Math.sin(angle1));
            var mx4 = d.target.x + (midpointSize * Math.cos(angle2));
            var my4 = d.target.y - (midpointSize * Math.sin(angle2));

            var midY2 = (my1 + my3) / 2;
            var midX2 = (mx1 + mx3) / 2;
            var midY1 = (my2 + my4) / 2;
            var midX1 = (mx2 + mx4) / 2;

            return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + midX1 + "," + midY1 + " L " + x3 + "," + y3 + " L " + x4 + "," + y4 + " L " + midX2 + "," + midY2 + "z";
        };

        function nail(d, nodeSize) {
            var diffX = d.target.y - d.source.y;
            var diffY = d.target.x - d.source.x;

            var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
            var angle1 = angle0 - ( Math.PI / 2 );
            var angle2 = angle0 + ( Math.PI / 2 );

            var x1 = d.source.x + (nodeSize * Math.cos(angle1));
            var y1 = d.source.y - (nodeSize * Math.sin(angle1));
            var x2 = d.source.x + (nodeSize * Math.cos(angle2));
            var y2 = d.source.y - (nodeSize * Math.sin(angle2));

            return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.target.x + "," + d.target.y + "z";
        };

        function comet(d, nodeSize) {
            var diffX = d.target.y - d.source.y;
            var diffY = d.target.x - d.source.x;

            var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
            var angle1 = angle0 - ( Math.PI / 2 );
            var angle2 = angle0 + ( Math.PI / 2 );

            var x1 = d.target.x + (nodeSize * Math.cos(angle1));
            var y1 = d.target.y - (nodeSize * Math.sin(angle1));
            var x2 = d.target.x + (nodeSize * Math.cos(angle2));
            var y2 = d.target.y - (nodeSize * Math.sin(angle2));

            return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.source.x + "," + d.source.y + "z";
        };

        function arrowHead(d, nodeTargetSize, bodySize, headSize) {
            var diffX = d.target.y - d.source.y;
            var diffY = d.target.x - d.source.x;

            var headDistance = headSize * 3;

            var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
            var angle1 = angle0 - ( Math.PI / 2 );
            var angle2 = angle0 + ( Math.PI / 2 );

            var x1 = d.source.x + (headSize * Math.cos(angle1));
            var y1 = d.source.y - (headSize * Math.sin(angle1));
            var x2 = d.source.x + (headSize * Math.cos(angle2));
            var y2 = d.source.y - (headSize * Math.sin(angle2));

            var x3 = d.target.x - (headSize * Math.cos(angle1));
            var y3 = d.target.y + (headSize * Math.sin(angle1));
            var x4 = d.target.x - (headSize * Math.cos(angle2));
            var y4 = d.target.y + (headSize * Math.sin(angle2));

            var mx1 = d.source.x + (bodySize * Math.cos(angle1));
            var my1 = d.source.y - (bodySize * Math.sin(angle1));
            var mx2 = d.source.x + (bodySize * Math.cos(angle2));
            var my2 = d.source.y - (bodySize * Math.sin(angle2));

            var mx3 = d.target.x + (bodySize * Math.cos(angle1));
            var my3 = d.target.y - (bodySize * Math.sin(angle1));
            var mx4 = d.target.x + (bodySize * Math.cos(angle2));
            var my4 = d.target.y - (bodySize * Math.sin(angle2));

            var dY = d.source.y - d.target.y;
            var dX = d.source.x - d.target.x;

            var midDiffY1 = my1 - my3;
            var midDiffX1 = mx1 - mx3;
            var midDiffY2 = my2 - my4;
            var midDiffX2 = mx2 - mx4;

            var diffY1 = y1 - y3;
            var diffX1 = x1 - x3;
            var diffY2 = y2 - y4;
            var diffX2 = x2 - x4;

            var pythag = Math.sqrt((midDiffX1 * midDiffX1) + (midDiffY1 * midDiffY1));
            var pythag2 = Math.sqrt((dX * dX) + (dY * dY));

            var adjX1 = mx2 - ((midDiffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var adjY1 = my2 - ((midDiffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var adjX2 = mx1 - ((midDiffX2 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var adjY2 = my1 - ((midDiffY2 * (pythag - headDistance - nodeTargetSize)) / pythag);

            var headX2 = x1 - ((diffX2 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var headY2 = y1 - ((diffY2 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var headX1 = x2 - ((diffX1 * (pythag - headDistance - nodeTargetSize)) / pythag);
            var headY1 = y2 - ((diffY1 * (pythag - headDistance - nodeTargetSize)) / pythag);

            var tipX = d.source.x - ((dX * (pythag2 - nodeTargetSize)) / pythag2);
            var tipY = d.source.y - ((dY * (pythag2 - nodeTargetSize)) / pythag2);

            return "M" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + headX2 + "," + headY2 + "L" + adjX2 + "," + adjY2 + "L" + mx1 + "," + my1 + "z";
        };

        function parallel(d, sourceSize, targetSize, edgeNumber) {

          var diffX = d.target.y - d.source.y;
          var diffY = d.target.x - d.source.x;

          var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
          var angle1 = angle0 + ( (Math.PI * 0.75) + (edgeNumber * 0.25) );
          var angle2 = angle0 + ( (Math.PI * 0.25) - (edgeNumber * 0.25) );

          var x1 = d.source.x + (sourceSize * Math.cos(angle1));
          var y1 = d.source.y - (sourceSize * Math.sin(angle1));
          var x2 = d.target.x + (targetSize * Math.cos(angle2));
          var y2 = d.target.y - (targetSize * Math.sin(angle2));

          return {source: {x: x1, y: y1}, target: {x: x2, y: y2}};

        }

        function offset(d, nodeSize) {
          var diffX = d.target.y - d.source.y;
          var diffY = d.target.x - d.source.x;

          var angle0 = ( Math.atan2( diffY, diffX ) + ( Math.PI / 2 ) );
          var angle1 = angle0 + ( Math.PI * 0.75 );
          var angle2 = angle0 + ( Math.PI * 0.25 );

          var x1 = d.source.x + (nodeSize * Math.cos(angle1));
          var y1 = d.source.y - (nodeSize * Math.sin(angle1));
          var x2 = d.target.x + (nodeSize * Math.cos(angle2));
          var y2 = d.target.y - (nodeSize * Math.sin(angle2));

          return {source: {x: x1, y: y1}, target: {x: x2, y: y2}};

        }

        function particle(d, path, pathWidth, speed) {
            pathWidth = pathWidth / 2;

            d.particles = d.particles.filter(function (d) {return d.current < path.getTotalLength()});

            if (d.frequency < 1) {
                if (Math.random() < d.frequency) {
                    pushParticle();
                }
            } else {
                for (var x = 0; x < d.frequency; x++) {
                    pushParticle();
                }
            }

            function pushParticle() {
                d.particles.push({current: 0, xOffset: pathWidth - (pathWidth * Math.random() * 2), yOffset: pathWidth - (pathWidth * Math.random() * 2)});
            }

            d.particles.forEach(function (particle) {
                particle.current = particle.current + speed;
                var currentPosition = path.getPointAtLength(particle.current);
                particle.x = currentPosition.x + particle.xOffset;
                particle.y = currentPosition.y + particle.yOffset;
            });
        };

        var d = {
          arrowHead: arrowHead,
          comet: comet,
          nail: nail,
          taffy: taffy,
          ribbon: ribbon,
          lineArc: lineArc,
          halfArrow: halfArrow
        };

        var project = {
          offset: offset,
          parallel: parallel
        };

        var mutate = {
          particle: particle
        };

        var version = "1.2.0";

        exports.version = version;
        exports.d = d;
        exports.project = project;
        exports.mutate = mutate;

}));

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sankeyCircular = __webpack_require__(321);

Object.defineProperty(exports, "sankeyCircular", {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_sankeyCircular).default;
  }
});

var _align = __webpack_require__(184);

Object.defineProperty(exports, "sankeyCenter", {
  enumerable: true,
  get: function () {
    return _align.center;
  }
});
Object.defineProperty(exports, "sankeyLeft", {
  enumerable: true,
  get: function () {
    return _align.left;
  }
});
Object.defineProperty(exports, "sankeyRight", {
  enumerable: true,
  get: function () {
    return _align.right;
  }
});
Object.defineProperty(exports, "sankeyJustify", {
  enumerable: true,
  get: function () {
    return _align.justify;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  // Set the default values
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      // extent
  dx = 24,
      // nodeWidth
  py,
      // nodePadding, for vertical postioning
  id = defaultId,
      align = _align.justify,
      nodes = defaultNodes,
      links = defaultLinks,
      iterations = 32,
      circularLinkGap = 2,
      paddingRatio;

  function sankeyCircular() {
    var graph = {
      nodes: nodes.apply(null, arguments),
      links: links.apply(null, arguments)

      // Process the graph's nodes and links, setting their positions

      // 1.  Associate the nodes with their respective links, and vice versa
    };computeNodeLinks(graph);

    // 2.  Determine which links result in a circular path in the graph
    identifyCircles(graph, id);

    // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links
    computeNodeValues(graph);

    // 5.  Calculate the nodes' depth based on the incoming and outgoing links
    //     Sets the nodes':
    //     - depth:  the depth in the graph
    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right
    //     - x0, x1: the x coordinates, as is relates to visual position from left to right
    computeNodeDepths(graph);

    // 3.  Determine how the circular links will be drawn,
    //     either travelling back above the main chart ("top")
    //     or below the main chart ("bottom")
    selectCircularLinkTypes(graph, id);

    // 6.  Calculate the nodes' and links' vertical position within their respective column
    //     Also readjusts sankeyCircular size if circular links are needed, and node x's
    computeNodeBreadths(graph, iterations, id);
    computeLinkBreadths(graph);

    // 7.  Sort links per node, based on the links' source/target nodes' breadths
    // 8.  Adjust nodes that overlap links that span 2+ columns

    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement
    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {

      sortSourceLinks(graph, y1, id);
      sortTargetLinks(graph, y1, id);
      resolveNodeLinkOverlaps(graph, y0, y1, id);
      sortSourceLinks(graph, y1, id);
      sortTargetLinks(graph, y1, id);
    }

    // 8.1  Adjust node and link positions back to fill height of chart area if compressed
    fillHeight(graph, y0, y1);

    // 9. Calculate visually appealling path for the circular paths, and create the "d" string
    addCircularPathData(graph, circularLinkGap, y1, id);

    return graph;
  } // end of sankeyCircular function


  // Set the sankeyCircular parameters
  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap
  sankeyCircular.nodeId = function (_) {
    return arguments.length ? (id = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : id;
  };

  sankeyCircular.nodeAlign = function (_) {
    return arguments.length ? (align = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : align;
  };

  sankeyCircular.nodeWidth = function (_) {
    return arguments.length ? (dx = +_, sankeyCircular) : dx;
  };

  sankeyCircular.nodePadding = function (_) {
    return arguments.length ? (py = +_, sankeyCircular) : py;
  };

  sankeyCircular.nodes = function (_) {
    return arguments.length ? (nodes = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : nodes;
  };

  sankeyCircular.links = function (_) {
    return arguments.length ? (links = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : links;
  };

  sankeyCircular.size = function (_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];
  };

  sankeyCircular.extent = function (_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];
  };

  sankeyCircular.iterations = function (_) {
    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;
  };

  sankeyCircular.circularLinkGap = function (_) {
    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;
  };

  sankeyCircular.nodePaddingRatio = function (_) {
    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks(graph) {
    graph.nodes.forEach(function (node, i) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = (0, _d3Collection.map)(graph.nodes, id);
    graph.links.forEach(function (link, i) {
      link.index = i;
      var source = link.source;
      var target = link.target;
      if (typeof source !== 'object') {
        source = link.source = find(nodeById, source);
      }
      if (typeof target !== 'object') {
        target = link.target = find(nodeById, target);
      }
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) and cycleness of each node by summing the associated links.
  function computeNodeValues(graph) {
    graph.nodes.forEach(function (node) {
      node.partOfCycle = false;
      node.value = Math.max((0, _d3Array.sum)(node.sourceLinks, value), (0, _d3Array.sum)(node.targetLinks, value));
      node.sourceLinks.forEach(function (link) {
        if (link.circular) {
          node.partOfCycle = true;
          node.circularLinkType = link.circularLinkType;
        }
      });
      node.targetLinks.forEach(function (link) {
        if (link.circular) {
          node.partOfCycle = true;
          node.circularLinkType = link.circularLinkType;
        }
      });
    });
  }

  function getCircleMargins(graph) {
    var totalTopLinksWidth = 0,
        totalBottomLinksWidth = 0,
        totalRightLinksWidth = 0,
        totalLeftLinksWidth = 0;

    var maxColumn = (0, _d3Array.max)(graph.nodes, function (node) {
      return node.column;
    });

    graph.links.forEach(function (link) {
      if (link.circular) {
        if (link.circularLinkType == 'top') {
          totalTopLinksWidth = totalTopLinksWidth + link.width;
        } else {
          totalBottomLinksWidth = totalBottomLinksWidth + link.width;
        }

        if (link.target.column == 0) {
          totalLeftLinksWidth = totalLeftLinksWidth + link.width;
        }

        if (link.source.column == maxColumn) {
          totalRightLinksWidth = totalRightLinksWidth + link.width;
        }
      }
    });

    //account for radius of curves and padding between links
    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;
    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;
    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;
    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;

    return { "top": totalTopLinksWidth, "bottom": totalBottomLinksWidth, "left": totalLeftLinksWidth, "right": totalRightLinksWidth };
  }

  // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links
  function scaleSankeySize(graph, margin) {

    var maxColumn = (0, _d3Array.max)(graph.nodes, function (node) {
      return node.column;
    });

    var currentWidth = x1 - x0;
    var currentHeight = y1 - y0;

    var newWidth = currentWidth + margin.right + margin.left;
    var newHeight = currentHeight + margin.top + margin.bottom;

    var scaleX = currentWidth / newWidth;
    var scaleY = currentHeight / newHeight;

    x0 = x0 * scaleX + margin.left;
    x1 = margin.right == 0 ? x1 : x1 * scaleX;
    y0 = y0 * scaleY + margin.top;
    y1 = y1 * scaleY;

    graph.nodes.forEach(function (node) {
      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);
      node.x1 = node.x0 + dx;
    });

    return scaleY;
  }

  // Iteratively assign the depth for each node.
  // Nodes are assigned the maximum depth of incoming neighbors plus one;
  // nodes with no incoming links are assigned depth zero, while
  // nodes with no outgoing links are assigned the maximum depth.
  function computeNodeDepths(graph) {
    var nodes, next, x;

    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
      nodes.forEach(function (node) {
        node.depth = x;
        node.sourceLinks.forEach(function (link) {
          if (next.indexOf(link.target) < 0 && !link.circular) {
            next.push(link.target);
          }
        });
      });
    }

    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
      nodes.forEach(function (node) {
        node.height = x;
        node.targetLinks.forEach(function (link) {
          if (next.indexOf(link.source) < 0 && !link.circular) {
            next.push(link.source);
          }
        });
      });
    }

    // assign column numbers, and get max value
    graph.nodes.forEach(function (node) {
      node.column = Math.floor(align.call(null, node, x));
    });
  }

  // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)
  function computeNodeBreadths(graph, iterations, id) {
    var columns = (0, _d3Collection.nest)().key(function (d) {
      return d.column;
    }).sortKeys(_d3Array.ascending).entries(graph.nodes).map(function (d) {
      return d.values;
    });

    initializeNodeBreadth(id);
    resolveCollisions();

    for (var alpha = 1, n = iterations; n > 0; --n) {
      relaxLeftAndRight(alpha *= 0.99, id);
      resolveCollisions();
    }

    function initializeNodeBreadth(id) {

      //override py if nodePadding has been set
      if (paddingRatio) {
        var padding = Infinity;
        columns.forEach(function (nodes) {
          var thisPadding = y1 * paddingRatio / (nodes.length + 1);
          padding = thisPadding < padding ? thisPadding : padding;
        });
        py = padding;
      }

      var ky = (0, _d3Array.min)(columns, function (nodes) {
        return (y1 - y0 - (nodes.length - 1) * py) / (0, _d3Array.sum)(nodes, value);
      });

      //calculate the widths of the links
      ky = ky * scale;

      graph.links.forEach(function (link) {
        link.width = link.value * ky;
      });

      //determine how much to scale down the chart, based on circular links
      var margin = getCircleMargins(graph);
      var ratio = scaleSankeySize(graph, margin);

      //re-calculate widths
      ky = ky * ratio;

      graph.links.forEach(function (link) {
        link.width = link.value * ky;
      });

      columns.forEach(function (nodes) {
        var nodesLength = nodes.length;
        nodes.forEach(function (node, i) {
          if (node.depth == columns.length - 1 && nodesLength == 1) {
            node.y0 = y1 / 2 - node.value * ky;
            node.y1 = node.y0 + node.value * ky;
          } else if (node.depth == 0 && nodesLength == 1) {
            node.y0 = y1 / 2 - node.value * ky;
            node.y1 = node.y0 + node.value * ky;
          } else if (node.partOfCycle) {
            if (numberOfNonSelfLinkingCycles(node, id) == 0) {
              node.y0 = y1 / 2 + i;
              node.y1 = node.y0 + node.value * ky;
            } else if (node.circularLinkType == 'top') {
              node.y0 = y0 + i;
              node.y1 = node.y0 + node.value * ky;
            } else {
              node.y0 = y1 - node.value * ky - i;
              node.y1 = node.y0 + node.value * ky;
            }
          } else {
            if (margin.top == 0 || margin.bottom == 0) {
              node.y0 = (y1 - y0) / nodesLength * i;
              node.y1 = node.y0 + node.value * ky;
            } else {
              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;
              node.y1 = node.y0 + node.value * ky;
            }
          }
        });
      });
    }

    // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position
    // and shift up/down to be closer to the vertical middle of those targets and sources
    function relaxLeftAndRight(alpha, id) {
      var columnsLength = columns.length;

      columns.forEach(function (nodes, i) {
        var n = nodes.length;
        var depth = nodes[0].depth;

        nodes.forEach(function (node) {
          // check the node is not an orphan
          if (node.sourceLinks.length || node.targetLinks.length) {
            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) {} else if (depth == 0 && n == 1) {
              var nodeHeight = node.y1 - node.y0;

              node.y0 = y1 / 2 - nodeHeight / 2;
              node.y1 = y1 / 2 + nodeHeight / 2;
            } else if (depth == columnsLength - 1 && n == 1) {
              var nodeHeight = node.y1 - node.y0;

              node.y0 = y1 / 2 - nodeHeight / 2;
              node.y1 = y1 / 2 + nodeHeight / 2;
            } else {
              var avg = 0;

              var avgTargetY = (0, _d3Array.mean)(node.sourceLinks, linkTargetCenter);
              var avgSourceY = (0, _d3Array.mean)(node.targetLinks, linkSourceCenter);

              if (avgTargetY && avgSourceY) {
                avg = (avgTargetY + avgSourceY) / 2;
              } else {
                avg = avgTargetY || avgSourceY;
              }

              var dy = (avg - nodeCenter(node)) * alpha;
              // positive if it node needs to move down
              node.y0 += dy;
              node.y1 += dy;
            }
          }
        });
      });
    }

    // For each column, check if nodes are overlapping, and if so, shift up/down
    function resolveCollisions() {
      columns.forEach(function (nodes) {
        var node,
            dy,
            y = y0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(ascendingBreadth);

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y - node.y0;

          if (dy > 0) {
            node.y0 += dy;
            node.y1 += dy;
          }
          y = node.y1 + py;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y - py - y1;
        if (dy > 0) {
          ;y = node.y0 -= dy, node.y1 -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y1 + py - y;
            if (dy > 0) node.y0 -= dy, node.y1 -= dy;
            y = node.y0;
          }
        }
      });
    }
  }

  // Assign the links y0 and y1 based on source/target nodes position,
  // plus the link's relative position to other links to the same node
  function computeLinkBreadths(graph) {
    graph.nodes.forEach(function (node) {
      node.sourceLinks.sort(ascendingTargetBreadth);
      node.targetLinks.sort(ascendingSourceBreadth);
    });
    graph.nodes.forEach(function (node) {
      var y0 = node.y0;
      var y1 = y0;

      // start from the bottom of the node for cycle links
      var y0cycle = node.y1;
      var y1cycle = y0cycle;

      node.sourceLinks.forEach(function (link) {
        if (link.circular) {
          link.y0 = y0cycle - link.width / 2;
          y0cycle = y0cycle - link.width;
        } else {
          link.y0 = y0 + link.width / 2;
          y0 += link.width;
        }
      });
      node.targetLinks.forEach(function (link) {
        if (link.circular) {
          link.y1 = y1cycle - link.width / 2;
          y1cycle = y1cycle - link.width;
        } else {
          link.y1 = y1 + link.width / 2;
          y1 += link.width;
        }
      });
    });
  }

  return sankeyCircular;
};

var _d3Array = __webpack_require__(225);

var _d3Collection = __webpack_require__(27);

var _align = __webpack_require__(184);

var _constant = __webpack_require__(322);

var _constant2 = _interopRequireDefault(_constant);

var _d3Shape = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}

// sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths
// https://github.com/tomshanley/d3-sankeyCircular-circular
// fork of https://github.com/d3/d3-sankeyCircular copyright Mike Bostock
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}

// sort nodes' breadth (ie top to bottom in a column)
// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node
// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom
function ascendingBreadth(a, b) {
  if (a.partOfCycle === b.partOfCycle) {
    return a.y0 - b.y0;
  } else {
    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {
      return -1;
    } else {
      return 1;
    }
  }
}

// return the value of a node or link
function value(d) {
  return d.value;
}

// return the vertical center of a node
function nodeCenter(node) {
  return (node.y0 + node.y1) / 2;
}

// return the vertical center of a link's source node
function linkSourceCenter(link) {
  return nodeCenter(link.source);
}

// return the vertical center of a link's target node
function linkTargetCenter(link) {
  return nodeCenter(link.target);
}

/* function weightedSource (link) {
  return nodeCenter(link.source) * link.value
} */

/* function weightedTarget (link) {
  return nodeCenter(link.target) * link.value
} */

// Return the default value for ID for node, d.index
function defaultId(d) {
  return d.index;
}

// Return the default object the graph's nodes, graph.nodes
function defaultNodes(graph) {
  return graph.nodes;
}

// Return the default object the graph's nodes, graph.links
function defaultLinks(graph) {
  return graph.links;
}

// Return the node from the collection that matches the provided ID, or throw an error if no match
function find(nodeById, id) {
  var node = nodeById.get(id);
  if (!node) throw new Error('missing: ' + id);
  return node;
}

function getNodeID(node, id) {
  return id(node);
}

// The main sankeyCircular functions

// Some constants for circular link calculations
var verticalMargin = 25;
var baseRadius = 10;
var scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped

/// /////////////////////////////////////////////////////////////////////////////////
// Cycle functions
// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043

// Identify circles in the link objects
function identifyCircles(graph, id) {
  var addedLinks = [];
  var circularLinkID = 0;
  graph.links.forEach(function (link) {
    if (createsCycle(link.source, link.target, addedLinks, id)) {
      link.circular = true;
      link.circularLinkID = circularLinkID;
      circularLinkID = circularLinkID + 1;
    } else {
      link.circular = false;
      addedLinks.push(link);
    }
  });
}

// Assign a circular link type (top or bottom), based on:
// - if the source/target node already has circular links, then use the same type
// - if not, choose the type with fewer links
function selectCircularLinkTypes(graph, id) {
  var numberOfTops = 0;
  var numberOfBottoms = 0;
  graph.links.forEach(function (link) {
    if (link.circular) {
      // if either souce or target has type already use that
      if (link.source.circularLinkType || link.target.circularLinkType) {
        // default to source type if available
        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;
      } else {
        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';
      }

      if (link.circularLinkType == 'top') {
        numberOfTops = numberOfTops + 1;
      } else {
        numberOfBottoms = numberOfBottoms + 1;
      }

      graph.nodes.forEach(function (node) {
        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {
          node.circularLinkType = link.circularLinkType;
        }
      });
    }
  });

  //correct self-linking links to be same direction as node
  graph.links.forEach(function (link) {
    if (link.circular) {
      //if both source and target node are same type, then link should have same type
      if (link.source.circularLinkType == link.target.circularLinkType) {
        link.circularLinkType = link.source.circularLinkType;
      }
      //if link is selflinking, then link should have same type as node
      if (selfLinking(link, id)) {
        link.circularLinkType = link.source.circularLinkType;
      }
    }
  });
}

// Checks if link creates a cycle
function createsCycle(originalSource, nodeToCheck, graph, id) {

  // Check for self linking nodes
  if (getNodeID(originalSource, id) == getNodeID(nodeToCheck, id)) {
    return true;
  }

  if (graph.length == 0) {
    return false;
  }

  var nextLinks = findLinksOutward(nodeToCheck, graph);
  // leaf node check
  if (nextLinks.length == 0) {
    return false;
  }

  // cycle check
  for (var i = 0; i < nextLinks.length; i++) {
    var nextLink = nextLinks[i];

    if (nextLink.target === originalSource) {
      return true;
    }

    // Recurse
    if (createsCycle(originalSource, nextLink.target, graph, id)) {
      return true;
    }
  }

  // Exhausted all links
  return false;
}

// Given a node, find all links for which this is a source in the current 'known' graph
function findLinksOutward(node, graph) {
  var children = [];

  for (var i = 0; i < graph.length; i++) {
    if (node == graph[i].source) {
      children.push(graph[i]);
    }
  }

  return children;
}

// Return the angle between a straight line between the source and target of the link, and the vertical plane of the node
function linkAngle(link) {
  var adjacent = Math.abs(link.y1 - link.y0);
  var opposite = Math.abs(link.target.x0 - link.source.x1);

  return Math.atan(opposite / adjacent);
}

// Check if two circular links potentially overlap
function circularLinksCross(link1, link2) {
  if (link1.source.column < link2.target.column) {
    return false;
  } else if (link1.target.column > link2.source.column) {
    return false;
  } else {
    return true;
  }
}

// Return the number of circular links for node, not including self linking links
function numberOfNonSelfLinkingCycles(node, id) {
  var sourceCount = 0;
  node.sourceLinks.forEach(function (l) {
    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;
  });

  var targetCount = 0;
  node.targetLinks.forEach(function (l) {
    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;
  });

  return sourceCount + targetCount;
}

// Check if a circular link is the only circular link for both its source and target node
function onlyCircularLink(link) {
  var nodeSourceLinks = link.source.sourceLinks;
  var sourceCount = 0;
  nodeSourceLinks.forEach(function (l) {
    sourceCount = l.circular ? sourceCount + 1 : sourceCount;
  });

  var nodeTargetLinks = link.target.targetLinks;
  var targetCount = 0;
  nodeTargetLinks.forEach(function (l) {
    targetCount = l.circular ? targetCount + 1 : targetCount;
  });

  if (sourceCount > 1 || targetCount > 1) {
    return false;
  } else {
    return true;
  }
}

// creates vertical buffer values per set of top/bottom links
function calcVerticalBuffer(links, circularLinkGap, id) {
  links.sort(sortLinkColumnAscending);
  links.forEach(function (link, i) {
    var buffer = 0;

    if (selfLinking(link, id) && onlyCircularLink(link)) {
      link.circularPathData.verticalBuffer = buffer + link.width / 2;
    } else {
      var j = 0;
      for (j; j < i; j++) {
        if (circularLinksCross(links[i], links[j])) {
          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;
          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;
        }
      }

      link.circularPathData.verticalBuffer = buffer + link.width / 2;
    }
  });

  return links;
}

// calculate the optimum path for a link to reduce overlaps
function addCircularPathData(graph, circularLinkGap, y1, id) {
  //var baseRadius = 10
  var buffer = 5;
  //var verticalMargin = 25

  var minY = (0, _d3Array.min)(graph.links, function (link) {
    return link.source.y0;
  });

  // create object for circular Path Data
  graph.links.forEach(function (link) {
    if (link.circular) {
      link.circularPathData = {};
    }
  });

  // calc vertical offsets per top/bottom links
  var topLinks = graph.links.filter(function (l) {
    return l.circularLinkType == 'top';
  });
  topLinks = calcVerticalBuffer(topLinks, circularLinkGap, id);

  var bottomLinks = graph.links.filter(function (l) {
    return l.circularLinkType == 'bottom';
  });
  bottomLinks = calcVerticalBuffer(bottomLinks, circularLinkGap, id);

  // add the base data for each link
  graph.links.forEach(function (link) {
    if (link.circular) {
      link.circularPathData.arcRadius = link.width + baseRadius;
      link.circularPathData.leftNodeBuffer = buffer;
      link.circularPathData.rightNodeBuffer = buffer;
      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;
      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;
      link.circularPathData.targetX = link.target.x0;
      link.circularPathData.sourceY = link.y0;
      link.circularPathData.targetY = link.y1;

      // for self linking paths, and that the only circular link in/out of that node
      if (selfLinking(link, id) && onlyCircularLink(link)) {
        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;
        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;
        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;
        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;

        if (link.circularLinkType == 'bottom') {
          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
        } else {
          // top links
          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
        }
      } else {
        // else calculate normally
        // add left extent coordinates, based on links with same source column and circularLink type
        var thisColumn = link.source.column;
        var thisCircularLinkType = link.circularLinkType;
        var sameColumnLinks = graph.links.filter(function (l) {
          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;
        });

        if (link.circularLinkType == 'bottom') {
          sameColumnLinks.sort(sortLinkSourceYDescending);
        } else {
          sameColumnLinks.sort(sortLinkSourceYAscending);
        }

        var radiusOffset = 0;
        sameColumnLinks.forEach(function (l, i) {
          if (l.circularLinkID == link.circularLinkID) {
            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
          }
          radiusOffset = radiusOffset + l.width;
        });

        // add right extent coordinates, based on links with same target column and circularLink type
        thisColumn = link.target.column;
        sameColumnLinks = graph.links.filter(function (l) {
          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;
        });
        if (link.circularLinkType == 'bottom') {
          sameColumnLinks.sort(sortLinkTargetYDescending);
        } else {
          sameColumnLinks.sort(sortLinkTargetYAscending);
        }

        radiusOffset = 0;
        sameColumnLinks.forEach(function (l, i) {
          if (l.circularLinkID == link.circularLinkID) {
            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
          }
          radiusOffset = radiusOffset + l.width;
        });

        // bottom links
        if (link.circularLinkType == 'bottom') {
          link.circularPathData.verticalFullExtent = y1 + verticalMargin + link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
        } else {
          // top links
          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;
          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
        }
      }

      // all links
      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;
      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;
      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;
      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;
    }

    if (link.circular) {
      link.path = createCircularPathString(link);
    } else {
      var normalPath = (0, _d3Shape.linkHorizontal)().source(function (d) {
        var x = d.source.x0 + (d.source.x1 - d.source.x0);
        var y = d.y0;
        return [x, y];
      }).target(function (d) {
        var x = d.target.x0;
        var y = d.y1;
        return [x, y];
      });
      link.path = normalPath(link);
    }
  });
}

// create a d path using the addCircularPathData
function createCircularPathString(link) {
  var pathString = '';
  var pathData = {};

  if (link.circularLinkType == 'top') {
    pathString =
    // start at the right of the source node
    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
    // line right to buffer point
    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
    // line up to buffer point
    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
    // line left to buffer point
    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
    // line down
    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
    // line to end
    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
  } else {
    // bottom path
    pathString =
    // start at the right of the source node
    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
    // line right to buffer point
    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
    // line down to buffer point
    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
    // line left to buffer point
    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
    // line up
    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +
    // Arc around: Centre of arc X and  //Centre of arc Y
    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +
    // End of arc X //End of arc Y
    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
    // line to end
    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
  }

  return pathString;
}

// sort links based on the distance between the source and tartget node columns
// if the same, then use Y position of the source node
function sortLinkColumnAscending(link1, link2) {
  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {
    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);
  } else {
    return linkColumnDistance(link2) - linkColumnDistance(link1);
  }
}

// sort ascending links by their source vertical position, y0
function sortLinkSourceYAscending(link1, link2) {
  return link1.y0 - link2.y0;
}

// sort descending links by their source vertical position, y0
function sortLinkSourceYDescending(link1, link2) {
  return link2.y0 - link1.y0;
}

// sort ascending links by their target vertical position, y1
function sortLinkTargetYAscending(link1, link2) {
  return link1.y1 - link2.y1;
}

// sort descending links by their target vertical position, y1
function sortLinkTargetYDescending(link1, link2) {
  return link2.y1 - link1.y1;
}

// return the distance between the link's target and source node, in terms of the nodes' column
function linkColumnDistance(link) {
  return link.target.column - link.source.column;
}

// return the distance between the link's target and source node, in terms of the nodes' X coordinate
function linkXLength(link) {
  return link.target.x0 - link.source.x1;
}

// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
// * approx, based on a straight line from target to source, when in fact the path is a bezier
function linkPerpendicularYToLinkSource(longerLink, shorterLink) {
  // get the angle for the longer link
  var angle = linkAngle(longerLink);

  // get the adjacent length to the other link's x position
  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

  // add or subtract from longer link1's original y1, depending on the slope
  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;

  return yPerpendicular;
}

// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
// * approx, based on a straight line from target to source, when in fact the path is a bezier
function linkPerpendicularYToLinkTarget(longerLink, shorterLink) {
  // get the angle for the longer link
  var angle = linkAngle(longerLink);

  // get the adjacent length to the other link's x position
  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

  // add or subtract from longer link's original y1, depending on the slope
  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;

  return yPerpendicular;
}

// Move any nodes that overlap links which span 2+ columns
function resolveNodeLinkOverlaps(graph, y0, y1, id) {

  graph.links.forEach(function (link) {
    if (link.circular) {
      return;
    }

    if (link.target.column - link.source.column > 1) {
      var columnToTest = link.source.column + 1;
      var maxColumnToTest = link.target.column - 1;

      var i = 1;
      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;

      for (columnToTest, i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {
        graph.nodes.forEach(function (node) {
          if (node.column == columnToTest) {
            var t = i / (numberOfColumnsToTest + 1);

            // Find all the points of a cubic bezier curve in javascript
            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript

            var B0_t = Math.pow(1 - t, 3);
            var B1_t = 3 * t * Math.pow(1 - t, 2);
            var B2_t = 3 * Math.pow(t, 2) * (1 - t);
            var B3_t = Math.pow(t, 3);

            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;

            var linkY0AtColumn = py_t - link.width / 2;
            var linkY1AtColumn = py_t + link.width / 2;

            // If top of link overlaps node, push node up
            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {

              var dy = node.y1 - linkY0AtColumn + 10;
              dy = node.circularLinkType == 'bottom' ? dy : -dy;

              node = adjustNodeHeight(node, dy, y0, y1);

              // check if other nodes need to move up too
              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (nodesOverlap(node, otherNode)) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {
              // If bottom of link overlaps node, push node down
              var dy = linkY1AtColumn - node.y0 + 10;

              node = adjustNodeHeight(node, dy, y0, y1);

              // check if other nodes need to move down too
              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {
              // if link completely overlaps node
              var dy = linkY1AtColumn - node.y0 + 10;

              node = adjustNodeHeight(node, dy, y0, y1);

              graph.nodes.forEach(function (otherNode) {
                // don't need to check itself or nodes at different columns
                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                  return;
                }
                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                  adjustNodeHeight(otherNode, dy, y0, y1);
                }
              });
            }
          }
        });
      }
    }
  });
}

// check if two nodes overlap
function nodesOverlap(nodeA, nodeB) {
  // test if nodeA top partially overlaps nodeB
  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {
    return true;
  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {
    // test if nodeA bottom partially overlaps nodeB
    return true;
  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {
    // test if nodeA covers nodeB
    return true;
  } else {
    return false;
  }
}

// update a node, and its associated links, vertical positions (y0, y1)
function adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {
  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {
    node.y0 = node.y0 + dy;
    node.y1 = node.y1 + dy;

    node.targetLinks.forEach(function (l) {
      l.y1 = l.y1 + dy;
    });

    node.sourceLinks.forEach(function (l) {
      l.y0 = l.y0 + dy;
    });
  }
  return node;
}

// sort and set the links' y0 for each node
function sortSourceLinks(graph, y1, id) {
  graph.nodes.forEach(function (node) {
    // move any nodes up which are off the bottom
    if (node.y + (node.y1 - node.y0) > y1) {
      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);
    }

    var nodesSourceLinks = graph.links.filter(function (l) {
      return getNodeID(l.source, id) == getNodeID(node, id);
    });

    var nodeSourceLinksLength = nodesSourceLinks.length;

    // if more than 1 link then sort
    if (nodeSourceLinksLength > 1) {
      nodesSourceLinks.sort(function (link1, link2) {
        // if both are not circular...
        if (!link1.circular && !link2.circular) {
          // if the target nodes are the same column, then sort by the link's target y
          if (link1.target.column == link2.target.column) {
            return link1.y1 - link2.y1;
          } else if (!sameInclines(link1, link2)) {
            // if the links slope in different directions, then sort by the link's target y
            return link1.y1 - link2.y1;

            // if the links slope in same directions, then sort by any overlap
          } else {
            if (link1.target.column > link2.target.column) {
              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);
              return link1.y1 - link2Adj;
            }
            if (link2.target.column > link1.target.column) {
              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);
              return link1Adj - link2.y1;
            }
          }
        }

        // if only one is circular, the move top links up, or bottom links down
        if (link1.circular && !link2.circular) {
          return link1.circularLinkType == 'top' ? -1 : 1;
        } else if (link2.circular && !link1.circular) {
          return link2.circularLinkType == 'top' ? 1 : -1;
        }

        // if both links are circular...
        if (link1.circular && link2.circular) {
          // ...and they both loop the same way (both top)
          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.target.column === link2.target.column) {
              return link1.target.y1 - link2.target.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link2.target.column - link1.target.column;
            }
          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
            // ...and they both loop the same way (both bottom)
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.target.column === link2.target.column) {
              return link2.target.y1 - link1.target.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link1.target.column - link2.target.column;
            }
          } else {
            // ...and they loop around different ways, the move top up and bottom down
            return link1.circularLinkType == 'top' ? -1 : 1;
          }
        }
      });
    }

    // update y0 for links
    var ySourceOffset = node.y0;

    nodesSourceLinks.forEach(function (link) {
      link.y0 = ySourceOffset + link.width / 2;
      ySourceOffset = ySourceOffset + link.width;
    });

    // correct any circular bottom links so they are at the bottom of the node
    nodesSourceLinks.forEach(function (link, i) {
      if (link.circularLinkType == 'bottom') {
        var j = i + 1;
        var offsetFromBottom = 0;
        // sum the widths of any links that are below this link
        for (j; j < nodeSourceLinksLength; j++) {
          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;
        }
        link.y0 = node.y1 - offsetFromBottom - link.width / 2;
      }
    });
  });
}

// sort and set the links' y1 for each node
function sortTargetLinks(graph, y1, id) {
  graph.nodes.forEach(function (node) {
    var nodesTargetLinks = graph.links.filter(function (l) {
      return getNodeID(l.target, id) == getNodeID(node, id);
    });

    var nodesTargetLinksLength = nodesTargetLinks.length;

    if (nodesTargetLinksLength > 1) {
      nodesTargetLinks.sort(function (link1, link2) {
        // if both are not circular, the base on the source y position
        if (!link1.circular && !link2.circular) {
          if (link1.source.column == link2.source.column) {
            return link1.y0 - link2.y0;
          } else if (!sameInclines(link1, link2)) {
            return link1.y0 - link2.y0;
          } else {
            // get the angle of the link to the further source node (ie the smaller column)
            if (link2.source.column < link1.source.column) {
              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);

              return link1.y0 - link2Adj;
            }
            if (link1.source.column < link2.source.column) {
              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);

              return link1Adj - link2.y0;
            }
          }
        }

        // if only one is circular, the move top links up, or bottom links down
        if (link1.circular && !link2.circular) {
          return link1.circularLinkType == 'top' ? -1 : 1;
        } else if (link2.circular && !link1.circular) {
          return link2.circularLinkType == 'top' ? 1 : -1;
        }

        // if both links are circular...
        if (link1.circular && link2.circular) {
          // ...and they both loop the same way (both top)
          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.source.column === link2.source.column) {
              return link1.source.y1 - link2.source.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link1.source.column - link2.source.column;
            }
          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
            // ...and they both loop the same way (both bottom)
            // ...and they both connect to a target with same column, then sort by the target's y
            if (link1.source.column === link2.source.column) {
              return link1.source.y1 - link2.source.y1;
            } else {
              // ...and they connect to different column targets, then sort by how far back they
              return link2.source.column - link1.source.column;
            }
          } else {
            // ...and they loop around different ways, the move top up and bottom down
            return link1.circularLinkType == 'top' ? -1 : 1;
          }
        }
      });
    }

    // update y1 for links
    var yTargetOffset = node.y0;

    nodesTargetLinks.forEach(function (link) {
      link.y1 = yTargetOffset + link.width / 2;
      yTargetOffset = yTargetOffset + link.width;
    });

    // correct any circular bottom links so they are at the bottom of the node
    nodesTargetLinks.forEach(function (link, i) {
      if (link.circularLinkType == 'bottom') {
        var j = i + 1;
        var offsetFromBottom = 0;
        // sum the widths of any links that are below this link
        for (j; j < nodesTargetLinksLength; j++) {
          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;
        }
        link.y1 = node.y1 - offsetFromBottom - link.width / 2;
      }
    });
  });
}

// test if links both slope up, or both slope down
function sameInclines(link1, link2) {
  return incline(link1) == incline(link2);
}

// returns the slope of a link, from source to target
// up => slopes up from source to target
// down => slopes down from source to target
function incline(link) {
  return link.y0 - link.y1 > 0 ? 'up' : 'down';
}

// check if link is self linking, ie links a node to the same node
function selfLinking(link, id) {
  return getNodeID(link.source, id) == getNodeID(link.target, id);
}

function fillHeight(graph, y0, y1) {

  var nodes = graph.nodes;
  var links = graph.links;

  var top = false;
  var bottom = false;

  links.forEach(function (link) {
    if (link.circularLinkType == "top") {
      top = true;
    } else if (link.circularLinkType == "bottom") {
      bottom = true;
    }
  });

  if (top == false || bottom == false) {
    var minY0 = (0, _d3Array.min)(nodes, function (node) {
      return node.y0;
    });
    var maxY1 = (0, _d3Array.max)(nodes, function (node) {
      return node.y1;
    });
    var currentHeight = maxY1 - minY0;
    var chartHeight = y1 - y0;
    var ratio = chartHeight / currentHeight;

    nodes.forEach(function (node) {
      var nodeHeight = (node.y1 - node.y0) * ratio;
      node.y0 = (node.y0 - minY0) * ratio;
      node.y1 = node.y0 + nodeHeight;
    });

    links.forEach(function (link) {
      link.y0 = (link.y0 - minY0) * ratio;
      link.y1 = (link.y1 - minY0) * ratio;
      link.width = link.width * ratio;
    });
  }
}

/// ////////////////////////////////////////////////////////////////////////////

/*exports.sankeyCircular = sankeyCircular
exports.sankeyCenter = center
exports.sankeyLeft = left
exports.sankeyRight = right
exports.sankeyJustify = justify
  Object.defineProperty(exports, '__esModule', { value: true })*/

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = constant;
// returns a function, using the parameter given to the sankey setting
function constant(x) {
  return function () {
    return x;
  };
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(0));
var memoize_one_1 = __importDefault(__webpack_require__(111));
var framePropHash = {
    NetworkFrame: true,
    XYFrame: true,
    OrdinalFrame: true,
    ResponsiveNetworkFrame: true,
    ResponsiveXYFrame: true,
    ResponsiveOrdinalFrame: true,
    SparkNetworkFrame: true,
    SparkXYFrame: true,
    SparkOrdinalFrame: true
};
var invertKeys = {
    rExtent: "invertR",
    xExtent: "invertX",
    yExtent: "invertY"
};
var buildNewState = function (prevState, extentValue, extentType, extentPosition, invertedExtent) {
    var _a, _b;
    var oldExtents = prevState.rawExtents[extentType] || {};
    oldExtents[extentPosition] = extentValue;
    var extentMinMaxValues = Object.values(oldExtents)
        .flat()
        .filter(function (d) { return d !== undefined && d !== null && !isNaN(d); });
    var baseExtent = [
        Math.min.apply(Math, __spread(extentMinMaxValues)),
        Math.max.apply(Math, __spread(extentMinMaxValues))
    ];
    if (invertedExtent) {
        baseExtent = baseExtent.reverse();
    }
    return {
        extents: __assign(__assign({}, prevState.extents), (_a = {}, _a[extentType] = extentMinMaxValues.length === 0 ? undefined : baseExtent, _a)),
        rawExtents: __assign(__assign({}, prevState.rawExtents), (_b = {}, _b[extentType] = oldExtents, _b))
    };
};
function validFrameProps(originalProps) {
    var newProps = __assign({}, originalProps);
    return newProps;
}
var FacetController = /** @class */ (function (_super) {
    __extends(FacetController, _super);
    function FacetController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            extents: {},
            rawExtents: {},
            facetHover: undefined
        };
        /**
         * Helper for creating extent if we have a  min/max value
         * use that else use the onChange version so we can in return
         * normalize all of the facets to have the same extents
         */
        _this.createExtent = function (extentType, state, index) {
            return state.extents && state.extents[extentType]
                ? {
                    onChange: _this.extentHandler(extentType, index),
                    extent: state.extents[extentType]
                }
                : { onChange: _this.extentHandler(extentType, index) };
        };
        /**
         * Whenever the extent changes, create the min/max values for each extentType
         * so this could be rExtent for OrdinalFrame or x/yExtent for the XYFrame
         */
        _this.extentHandler = function (extentType, extentPosition) {
            var invertedExtent = _this.props[invertKeys[extentType]] || false;
            return function (extentValue) {
                _this.setState(function (prevState) {
                    return buildNewState(prevState, extentValue, extentType, extentPosition, invertedExtent);
                });
                return extentValue;
            };
        };
        /**
         * Remove and add required annotation props for specific annotation types.
         */
        _this.generateChildAnnotations = function (_a) {
            var originalAnnotations = _a.originalAnnotations, state = _a.state;
            var annotationBase = state.facetHoverAnnotations;
            var _b = _this.props, hoverAnnotation = _b.hoverAnnotation, pieceHoverAnnotation = _b.pieceHoverAnnotation;
            var annotationSettings = hoverAnnotation || pieceHoverAnnotation;
            if (!annotationSettings || !annotationBase) {
                return originalAnnotations;
            }
            if (state.facetHover) {
                var annotations = __spread(originalAnnotations);
                if (annotationSettings === true) {
                    annotationBase = [__assign({}, state.facetHover)];
                }
                else {
                    var annotationMap = annotationSettings;
                    annotationBase = annotationMap.map(function (annotation) {
                        var decoratedAnnotation = typeof annotation === "function"
                            ? annotation(state.facetHover)
                            : __assign(__assign({}, state.facetHover), annotation);
                        return decoratedAnnotation;
                    });
                }
                if (Array.isArray(annotationBase)) {
                    annotationBase.forEach(function (annotation) {
                        if (typeof annotation !== "function") {
                            if (annotation.type === "column-hover") {
                                annotation.facetColumn = annotation.column.name;
                                annotation.column = undefined;
                            }
                            else {
                                if (!annotation.type) {
                                    annotation.type = "frame-hover";
                                }
                                annotation.y = undefined;
                                annotation.yBottom = undefined;
                                annotation.yMiddle = undefined;
                                annotation.yTop = undefined;
                            }
                        }
                    });
                    annotations.push.apply(annotations, __spread(annotationBase));
                }
                return annotations;
            }
            return originalAnnotations;
        };
        /**
         * Map hover annotations and extent to child. Initially the extent is an object with
         * an onChange handler however once each of those resolve we then create an
         * extent that matches between all of them. This logic can be found in createExtent and also
         * extentHandler
         */
        _this.mapChildrenWithAppropriateProps = function (_a) {
            var child = _a.child, index = _a.index, originalAnnotations = _a.originalAnnotations, props = _a.props, state = _a.state;
            var childType = child.type;
            var frameType = childType.displayName;
            var annotations = _this.generateChildAnnotations({
                state: state,
                originalAnnotations: originalAnnotations
            });
            var customProps = __assign(__assign({}, props), { annotations: annotations });
            if (!framePropHash[frameType]) {
                return React.cloneElement(child, { facetprops: customProps });
            }
            // pieceHoverAnnotation could be an object, so we need to be explicit in checking for true
            if (props.hoverAnnotation || props.pieceHoverAnnotation) {
                customProps.customHoverBehavior = function (d) {
                    _this.setState({
                        facetHover: d,
                        facetHoverAnnotations: props.hoverAnnotation || props.pieceHoverAnnotation
                    });
                };
            }
            if ((frameType === "OrdinalFrame" ||
                frameType === "ResponsiveOrdinalFrame" ||
                frameType === "SparkOrdinalFrame") &&
                props.sharedRExtent === true) {
                var invertedExtent_1 = customProps[invertKeys["rExtent"]] || false;
                customProps.rExtent = _this.createExtent("rExtent", state, index);
                customProps.onUnmount = function () {
                    _this.setState(function (prevState) {
                        return buildNewState(prevState, [], "rExtent", index, invertedExtent_1);
                    });
                };
            }
            if ((frameType === "XYFrame" ||
                frameType === "ResponsiveXYFrame" ||
                frameType === "SparkXYFrame") &&
                props.sharedXExtent === true) {
                var invertedExtent_2 = customProps[invertKeys["xExtent"]] || false;
                customProps.xExtent = _this.createExtent("xExtent", state, index);
                customProps.onUnmount = function () {
                    _this.setState(function (prevState) {
                        return buildNewState(prevState, [], "xExtent", index, invertedExtent_2);
                    });
                };
            }
            if ((frameType === "XYFrame" ||
                frameType === "ResponsiveXYFrame" ||
                frameType === "SparkXYFrame") &&
                props.sharedYExtent === true) {
                var invertedExtent_3 = customProps[invertKeys["yExtent"]] || false;
                customProps.yExtent = _this.createExtent("yExtent", state, index);
                customProps.onUnmount = function () {
                    _this.setState(function (prevState) {
                        return buildNewState(prevState, [], "yExtent", index, invertedExtent_3);
                    });
                };
            }
            if (customProps.pieceHoverAnnotation) {
                customProps.pieceHoverAnnotation = [];
            }
            else if (customProps.hoverAnnotation) {
                customProps.hoverAnnotation = [];
            }
            return React.cloneElement(child, validFrameProps(customProps));
        };
        /**
         * Memoize the mapping to prevent unecessary updates and not have
         * to use the lifecycle methods.
         */
        _this.processFacetController = memoize_one_1.default(function (props, state) {
            return React.Children.map(props.children, function (child, index) {
                if (!child)
                    return null;
                return _this.mapChildrenWithAppropriateProps({
                    child: child,
                    index: index,
                    originalAnnotations: child.props.annotations || [],
                    props: props,
                    state: state
                });
            });
        });
        return _this;
    }
    FacetController.prototype.render = function () {
        return (React.createElement(React.Fragment, null, this.processFacetController(this.props, this.state)));
    };
    return FacetController;
}(React.Component));
exports.default = FacetController;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var NetworkFrame_1 = __importDefault(__webpack_require__(130));
var ResponsiveFrame_1 = __importDefault(__webpack_require__(86));
exports.default = ResponsiveFrame_1.default(NetworkFrame_1.default);


/***/ }),
/* 325 */
/***/ (function(module, exports) {

function resizeListener(e) {
  var win = e.target || e.srcElement
  if (win.__resizeRAF__) {
    cancelAnimationFrame(win.__resizeRAF__)
  }
  win.__resizeRAF__ = requestAnimationFrame(function () {
    var trigger = win.__resizeTrigger__
    var listeners = trigger &&  trigger.__resizeListeners__
    if (listeners) {
      listeners.forEach(function (fn) {
        fn.call(trigger, e)
      })
    }
  })
}

var exports = function exports(element, fn) {
  var window = this
  var document = window.document
  var isIE

  var attachEvent = document.attachEvent
  if (typeof navigator !== 'undefined') {
    isIE = navigator.userAgent.match(/Trident/) ||
      navigator.userAgent.match(/Edge/)
  }

  function objectLoad() {
    this.contentDocument.defaultView.__resizeTrigger__ = this.__resizeElement__
    this.contentDocument.defaultView.addEventListener('resize', resizeListener)
  }

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = []
    if (attachEvent) {
      element.__resizeTrigger__ = element
      element.attachEvent('onresize', resizeListener)
    } else {
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative'
      }
      var obj = (element.__resizeTrigger__ = document.createElement('object'))
      obj.setAttribute(
        'style',
        'position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none; z-index: -1; opacity: 0;'
      )
      obj.setAttribute('class', 'resize-sensor')

      // prevent <object> from stealing keyboard focus
      obj.setAttribute('tabindex', '-1');

      obj.__resizeElement__ = element
      obj.onload = objectLoad
      obj.type = 'text/html'
      if (isIE) {
        element.appendChild(obj)
      }
      obj.data = 'about:blank'
      if (!isIE) {
        element.appendChild(obj)
      }
    }
  }
  element.__resizeListeners__.push(fn)
}

module.exports = typeof window === 'undefined' ? exports : exports.bind(window)

module.exports.unbind = function (element, fn) {
  var attachEvent = document.attachEvent
  var listeners = element.__resizeListeners__ || []
  if (fn) {
    var index = listeners.indexOf(fn)
    if (index !== -1) {
      listeners.splice(index, 1)
    }
  } else {
    listeners = element.__resizeListeners__ = []
  }
  if (!listeners.length) {
    if (attachEvent) {
      element.detachEvent('onresize', resizeListener)
    } else if (element.__resizeTrigger__) {
      var contentDocument = element.__resizeTrigger__.contentDocument;
      var defaultView = contentDocument && contentDocument.defaultView;
      if (defaultView) {
        defaultView.removeEventListener('resize', resizeListener);
        delete defaultView.__resizeTrigger__;
      }
      element.__resizeTrigger__ = !element.removeChild(
        element.__resizeTrigger__
      )
    }
    delete element.__resizeListeners__
  }
}


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var MinimapXYFrame_1 = __importDefault(__webpack_require__(181));
var ResponsiveFrame_1 = __importDefault(__webpack_require__(86));
exports.default = ResponsiveFrame_1.default(MinimapXYFrame_1.default);


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var XYFrame_1 = __importDefault(__webpack_require__(70));
var ResponsiveFrame_1 = __importDefault(__webpack_require__(86));
exports.default = ResponsiveFrame_1.default(XYFrame_1.default);


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var OrdinalFrame_1 = __importDefault(__webpack_require__(128));
var ResponsiveFrame_1 = __importDefault(__webpack_require__(86));
exports.default = ResponsiveFrame_1.default(OrdinalFrame_1.default);


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var XYFrame_1 = __importDefault(__webpack_require__(70));
var SparkFrame_1 = __importDefault(__webpack_require__(53));
var SparkFrame_2 = __webpack_require__(53);
exports.default = SparkFrame_1.default(XYFrame_1.default, SparkFrame_2.xyFrameDefaults, "SparkXYFrame");


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var OrdinalFrame_1 = __importDefault(__webpack_require__(128));
var SparkFrame_1 = __importDefault(__webpack_require__(53));
var SparkFrame_2 = __webpack_require__(53);
exports.default = SparkFrame_1.default(OrdinalFrame_1.default, SparkFrame_2.ordinalFrameDefaults, "SparkOrdinalFrame");


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var NetworkFrame_1 = __importDefault(__webpack_require__(130));
var SparkFrame_1 = __importDefault(__webpack_require__(53));
var SparkFrame_2 = __webpack_require__(53);
exports.default = SparkFrame_1.default(NetworkFrame_1.default, SparkFrame_2.networkFrameDefaults, "SparkNetworkFrame");


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const d3_scale_1 = __webpack_require__(78);
const React = __importStar(__webpack_require__(0));
const semiotic_1 = __webpack_require__(81);
const HTMLLegend_1 = __importDefault(__webpack_require__(72));
const tooltip_content_1 = __importDefault(__webpack_require__(44));
const utilities_1 = __webpack_require__(77);
const styled_components_1 = __importDefault(__webpack_require__(19));
const NumberOfItemsP = styled_components_1.default.p `
  margin: 20px 0 5px;
`;
const ParCoordsAxisTickG = styled_components_1.default.g `
  & text {
    text-anchor: end;
  }

  & :first-child {
    fill: white;
    stroke: white;
    opacity: 0.75;
    stroke-width: 2;
  }
`;
const axisSize = [40, 380];
function parallelizeData(data, metrics, schemaFields, primaryKey) {
    const minmax = {};
    const screenScales = {};
    metrics.forEach(metric => {
        const dataExtent = [
            Math.min(...data.map(datapoint => datapoint[metric.name])),
            Math.max(...data.map(datapoint => datapoint[metric.name]))
        ];
        const minMaxScale = d3_scale_1.scaleLinear()
            .domain(dataExtent)
            .range([0, 1]);
        minmax[metric.name] = minMaxScale;
        const screenScale = d3_scale_1.scaleLinear()
            .domain(dataExtent)
            .range([380, 0]);
        screenScales[metric.name] = screenScale;
    });
    const dataPieces = [];
    data.forEach(datapoint => {
        metrics.forEach(metric => {
            const dataPiece = {
                metric: metric.name,
                rawvalue: datapoint[metric.name],
                pctvalue: minmax[metric.name](datapoint[metric.name])
            };
            schemaFields.forEach((field) => {
                if (field.type === "string") {
                    dataPiece[field.name] = datapoint[field.name];
                }
            });
            primaryKey.forEach(key => {
                dataPiece[key] = datapoint[key];
            });
            dataPieces.push(dataPiece);
        });
    });
    return { dataPieces, scales: screenScales };
}
class ParallelCoordinatesController extends React.Component {
    constructor(props) {
        super(props);
        this.brushing = (selectedExtent, columnName) => {
            const columnExtent = this.state.columnExtent;
            columnExtent[columnName] = selectedExtent;
            this.setState({ columnExtent });
        };
        const { options, data, schema } = props;
        const { primaryKey, metrics } = options;
        const parallelizeResults = parallelizeData(data, metrics, schema.fields, primaryKey);
        this.state = {
            filterMode: true,
            data: parallelizeResults.dataPieces,
            dataScales: parallelizeResults.scales,
            columnExtent: metrics.reduce((metricHash, metric) => {
                metricHash[metric.name] = [-Infinity, Infinity];
                return metricHash;
            }, {})
        };
    }
    shouldComponentUpdate() {
        return true;
    }
    render() {
        const { options, data } = this.props;
        const { primaryKey, metrics, chart, colors, setColor } = options;
        const { dim1 } = chart;
        const { columnExtent, filterMode } = this.state;
        const hiddenHash = new Map();
        const connectorFunction = (columnDatapoint) => primaryKey.map(key => columnDatapoint[key]).join(",");
        Object.keys(columnExtent).forEach((key) => {
            const extent = columnExtent[key].sort((a, b) => a - b);
            this.state.data
                .filter((datapoint) => datapoint.metric === key &&
                (datapoint.pctvalue < extent[0] || datapoint.pctvalue > extent[1]))
                .forEach((datapoint) => {
                hiddenHash.set(primaryKey.map(key => datapoint[key]).join(","), true);
            });
        });
        const additionalSettings = {};
        const shownData = data.filter(datapoint => !hiddenHash.get(primaryKey.map(key => datapoint[key]).join(",")));
        const filteredData = shownData.map(datapoint => primaryKey.map(key => datapoint[key]).join(" - "));
        const colorHash = { Other: "grey" };
        if (dim1 && dim1 !== "none") {
            const { uniqueValues, valueHash } = shownData.reduce((valueReducer, datapoint) => {
                const value = datapoint[dim1];
                valueReducer.valueHash[value] =
                    (valueReducer.valueHash[value] &&
                        valueReducer.valueHash[value] + 1) ||
                        1;
                valueReducer.uniqueValues =
                    (!valueReducer.uniqueValues.find((uniqueValue) => uniqueValue === value) && [...valueReducer.uniqueValues, value]) ||
                        valueReducer.uniqueValues;
                return valueReducer;
            }, { uniqueValues: [], valueHash: {} });
            const uniqueDimsForColors = data.reduce((colorArray, datapoint) => colorArray.indexOf(datapoint[dim1]) === -1
                ? [...colorArray, datapoint[dim1]]
                : colorArray, []);
            uniqueDimsForColors.forEach((value, index) => {
                colorHash[value] = colors[index % colors.length];
            });
            additionalSettings.afterElements =
                uniqueValues.length <= 18 ? (React.createElement(HTMLLegend_1.default, { values: uniqueValues, colorHash: colorHash, valueHash: valueHash, setColor: setColor })) : (React.createElement(NumberOfItemsP, null,
                    filteredData.length,
                    " items"));
        }
        if (!filterMode) {
            additionalSettings.annotations = metrics
                .map(metric => ({
                label: "",
                metric: metric.name,
                type: "enclose-rect",
                color: "green",
                disable: ["connector"],
                coordinates: [
                    { metric: metric.name, pctvalue: columnExtent[metric.name][0] },
                    { metric: metric.name, pctvalue: columnExtent[metric.name][1] }
                ]
            }))
                .filter(annotation => annotation.coordinates[0].pctvalue !== 0 ||
                annotation.coordinates[1].pctvalue !== 1);
        }
        return (React.createElement("div", null,
            React.createElement("div", null,
                React.createElement("button", { className: `button-text ${filterMode ? "selected" : ""}`, onClick: () => this.setState({ filterMode: true }) }, "Filter"),
                React.createElement("button", { className: `button-text ${filterMode ? "" : "selected"}`, onClick: () => this.setState({ filterMode: false }) }, "Explore")),
            React.createElement(semiotic_1.ResponsiveOrdinalFrame, Object.assign({ data: this.state.data, oAccessor: "metric", rAccessor: "pctvalue", type: {
                    type: "point",
                    r: 2
                }, connectorType: connectorFunction, style: (datapoint) => ({
                    fill: hiddenHash.get(primaryKey.map((key) => datapoint[key]).join(","))
                        ? "lightgray"
                        : colorHash[datapoint[dim1]],
                    opacity: hiddenHash.get(primaryKey.map((key) => datapoint[key]).join(","))
                        ? 0.15
                        : 0.99
                }), connectorStyle: (datapoint) => ({
                    stroke: hiddenHash.get(primaryKey.map((key) => datapoint.source[key]).join(","))
                        ? "gray"
                        : colorHash[datapoint.source[dim1]],
                    strokeWidth: hiddenHash.get(primaryKey.map((key) => datapoint.source[key]).join(","))
                        ? 1
                        : 1.5,
                    strokeOpacity: hiddenHash.get(primaryKey.map((key) => datapoint.source[key]).join(","))
                        ? 0.1
                        : 1
                }), responsiveWidth: true, margin: { top: 20, left: 20, right: 20, bottom: 100 }, oPadding: 40, pixelColumnWidth: 80, interaction: filterMode
                    ? {
                        columnsBrush: true,
                        during: this.brushing,
                        extent: Object.keys(this.state.columnExtent)
                    }
                    : null, pieceHoverAnnotation: !filterMode, tooltipContent: (hoveredDatapoint) => {
                    const textColor = hiddenHash.get(primaryKey.map((key) => hoveredDatapoint[key]).join(","))
                        ? "grey"
                        : colorHash[hoveredDatapoint[dim1]];
                    return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
                        React.createElement("h3", null, primaryKey
                            .map((key) => hoveredDatapoint[key])
                            .join(", ")),
                        hoveredDatapoint[dim1] && (React.createElement("h3", { style: { color: textColor } },
                            dim1,
                            ": ",
                            hoveredDatapoint[dim1])),
                        React.createElement("p", null,
                            hoveredDatapoint.metric,
                            ": ",
                            hoveredDatapoint.rawvalue)));
                }, canvasPieces: true, canvasConnectors: true, oLabel: (columnLabel) => (React.createElement("g", null,
                    React.createElement("text", { transform: "rotate(45)" }, columnLabel),
                    React.createElement("g", { transform: "translate(-20,-395)" },
                        React.createElement(semiotic_1.Axis, { scale: this.state.dataScales[columnLabel], size: axisSize, orient: "left", ticks: 5, tickFormat: (tickValue) => (React.createElement(ParCoordsAxisTickG, null,
                                React.createElement("text", null, utilities_1.numeralFormatting(tickValue)),
                                React.createElement("text", null, utilities_1.numeralFormatting(tickValue)))) })))) }, additionalSettings))));
    }
}
ParallelCoordinatesController.defaultProps = {
    metadata: {},
    height: 500
};
exports.default = ParallelCoordinatesController;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
const react_color_1 = __webpack_require__(334);
const styled_components_1 = __importDefault(__webpack_require__(19));
// NOTE: These styles could be extracted for each of the components used within.
//       In order to get this typescript & styled-components transition in place though,
//       For now this just matches the prior style structure exactly with one big wrapper
//       and one extracted component -- <PaletteButton />
const Wrapper = styled_components_1.default.div `
  & {
    margin: 30px 0;
    padding: 30px;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;
  }
  .close {
    position: absolute;
    top: 15px;
    right: 15px;
    cursor: pointer;
    opacity: 0.5;
    font-size: 40px;
    line-height: 22px;
  }
  .close:hover {
    opacity: 1;
  }
  .grid-wrapper {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 20px;
  }
  h3 {
    margin: 0 0 20px;
  }
  .box {
    cursor: pointer;
    width: 30px;
    height: 30px;
    border-radius: 5px;
    display: inline-block;
    margin: 0 20px 20px 0;
  }
  textarea {
    height: 184px;
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 20px;
    padding: 5px;
    font-size: 14px;
    border-color: #ccc;
  }
`;
const ColorPickerWrapper = styled_components_1.default.div `
  & {
    width: 225px;
  }
`;
const PalettePickerWrapper = styled_components_1.default.div `
  & {
    margin-top: 30px;
  }
`;
const PaletteButton = styled_components_1.default.button `
  & {
    margin: 0 20px 10px 0;
    -webkit-appearance: none;
    padding: 5px 15px;
    background: white;
    border: 1px solid #bbb;
    border-radius: 3px;
    cursor: pointer;
    text-transform: uppercase;
    font-size: 14px;
    color: #555;
  }
  &:hover {
    border-color: #888;
    color: #222;
  }
`;
class PalettePicker extends React.PureComponent {
    constructor(props) {
        super(props);
        this.openClose = () => {
            this.setState({
                open: !this.state.open,
                colors: this.props.colors.join(",\n")
            });
        };
        this.handleChange = (color, position) => {
            this.setState({ selectedColor: color, selectedPosition: position });
        };
        this.pickerChange = (color) => {
            const { colors } = this.props;
            colors[this.state.selectedPosition] = color.hex;
            this.props.updateColor(colors);
            this.setState({ selectedColor: color.hex, colors: colors.join(",\n") });
        };
        this.colorsFromTextarea = () => {
            const parsedTextValue = this.state.colors
                .replace(/\"/g, "")
                .replace(/ /g, "")
                .replace(/\[/g, "")
                .replace(/\]/g, "")
                .replace(/\r?\n|\r/g, "")
                .split(",");
            this.props.updateColor(parsedTextValue);
        };
        this.updateTextArea = (e) => {
            this.setState({ colors: e.target.value });
        };
        this.state = {
            open: false,
            selectedColor: props.colors[0],
            selectedPosition: 0,
            colors: props.colors.join(",\n")
        };
    }
    render() {
        if (!this.state.open) {
            return (React.createElement("div", { style: { display: "inline-block" } },
                React.createElement(PaletteButton, { onClick: this.openClose }, "Adjust Palette")));
        }
        const { colors } = this.props;
        return (React.createElement(Wrapper, null,
            React.createElement("div", { className: "close", role: "button", tabIndex: 0, onClick: this.openClose, onKeyPress: (e) => {
                    if (e.keyCode === 13) {
                        this.openClose();
                    }
                } }, "\u00D7"),
            React.createElement("div", { className: "grid-wrapper" },
                React.createElement("div", null,
                    React.createElement("h3", null, "Select Color"),
                    colors.map((color, index) => (React.createElement("div", { key: `color-${index}`, className: "box", style: { background: color }, role: "button", tabIndex: 0, onKeyPress: (e) => {
                            if (e.keyCode === 13) {
                                this.handleChange(color, index);
                            }
                        }, onClick: () => this.handleChange(color, index) })))),
                React.createElement("div", null,
                    React.createElement("h3", null, "Adjust Color"),
                    React.createElement(ColorPickerWrapper, null,
                        React.createElement(react_color_1.ChromePicker, { color: this.state.selectedColor, onChangeComplete: this.pickerChange }))),
                React.createElement("div", null,
                    React.createElement("h3", null, "Paste New Colors"),
                    React.createElement("textarea", { value: this.state.colors, onChange: this.updateTextArea }),
                    React.createElement(PaletteButton, { onClick: this.colorsFromTextarea }, "Update Colors"))),
            React.createElement(PalettePickerWrapper, null,
                React.createElement("a", { href: `http://projects.susielu.com/viz-palette?colors=[${colors
                        .map(d => `"${d}"`)
                        .join(",")}]&backgroundColor="white"&fontColor="black"` }, "Evaluate This Palette with VIZ PALETTE"))));
    }
}
PalettePicker.defaultProps = {
    metadata: {},
    height: 500
};
exports.default = PalettePicker;


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomPicker = exports.TwitterPicker = exports.SwatchesPicker = exports.SliderPicker = exports.SketchPicker = exports.PhotoshopPicker = exports.MaterialPicker = exports.HuePicker = exports.GithubPicker = exports.CompactPicker = exports.ChromePicker = exports.default = exports.CirclePicker = exports.BlockPicker = exports.AlphaPicker = undefined;

var _Alpha = __webpack_require__(335);

Object.defineProperty(exports, 'AlphaPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Block = __webpack_require__(463);

Object.defineProperty(exports, 'BlockPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Block).default;
  }
});

var _Circle = __webpack_require__(465);

Object.defineProperty(exports, 'CirclePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Circle).default;
  }
});

var _Chrome = __webpack_require__(467);

Object.defineProperty(exports, 'ChromePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Chrome).default;
  }
});

var _Compact = __webpack_require__(473);

Object.defineProperty(exports, 'CompactPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Compact).default;
  }
});

var _Github = __webpack_require__(476);

Object.defineProperty(exports, 'GithubPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Github).default;
  }
});

var _Hue = __webpack_require__(478);

Object.defineProperty(exports, 'HuePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Material = __webpack_require__(480);

Object.defineProperty(exports, 'MaterialPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Material).default;
  }
});

var _Photoshop = __webpack_require__(481);

Object.defineProperty(exports, 'PhotoshopPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Photoshop).default;
  }
});

var _Sketch = __webpack_require__(487);

Object.defineProperty(exports, 'SketchPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sketch).default;
  }
});

var _Slider = __webpack_require__(490);

Object.defineProperty(exports, 'SliderPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Swatches = __webpack_require__(494);

Object.defineProperty(exports, 'SwatchesPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatches).default;
  }
});

var _Twitter = __webpack_require__(498);

Object.defineProperty(exports, 'TwitterPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Twitter).default;
  }
});

var _ColorWrap = __webpack_require__(217);

Object.defineProperty(exports, 'CustomPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Chrome2 = _interopRequireDefault(_Chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Chrome2.default;

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(8);

var _AlphaPointer = __webpack_require__(462);

var _AlphaPointer2 = _interopRequireDefault(_AlphaPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPicker = exports.AlphaPicker = function AlphaPicker(_ref) {
  var rgb = _ref.rgb,
      hsl = _ref.hsl,
      width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      direction = _ref.direction,
      style = _ref.style,
      renderers = _ref.renderers,
      pointer = _ref.pointer,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      alpha: {
        radius: '2px',
        style: style
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'alpha-picker ' + className },
    _react2.default.createElement(_common.Alpha, _extends({}, styles.alpha, {
      rgb: rgb,
      hsl: hsl,
      pointer: pointer,
      renderers: renderers,
      onChange: onChange,
      direction: direction
    }))
  );
};

AlphaPicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _AlphaPointer2.default
};

exports.default = (0, _common.ColorWrap)(AlphaPicker);

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenNames = undefined;

var _isString2 = __webpack_require__(337);

var _isString3 = _interopRequireDefault(_isString2);

var _forOwn2 = __webpack_require__(131);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _isPlainObject2 = __webpack_require__(191);

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _map2 = __webpack_require__(34);

var _map3 = _interopRequireDefault(_map2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flattenNames = exports.flattenNames = function flattenNames() {
  var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var names = [];

  (0, _map3.default)(things, function (thing) {
    if (Array.isArray(thing)) {
      flattenNames(thing).map(function (name) {
        return names.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3.default)(thing, function (value, key) {
        value === true && names.push(key);
        names.push(key + '-' + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names.push(thing);
    }
  });

  return names;
};

exports.default = flattenNames;

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    isArray = __webpack_require__(16),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 338 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(73);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 340 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 341 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 342 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 344 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(42),
    isLength = __webpack_require__(136),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(139),
    nativeKeys = __webpack_require__(347);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(189);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(349),
    baseMatchesProperty = __webpack_require__(393),
    identity = __webpack_require__(88),
    isArray = __webpack_require__(16),
    property = __webpack_require__(403);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(350),
    getMatchData = __webpack_require__(392),
    matchesStrictComparable = __webpack_require__(202);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(89),
    baseIsEqual = __webpack_require__(194);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 351 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(91);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(91);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(91);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(91);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(90);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 357 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 358 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 359 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(90),
    Map = __webpack_require__(142),
    MapCache = __webpack_require__(143);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(140),
    isMasked = __webpack_require__(362),
    isObject = __webpack_require__(20),
    toSource = __webpack_require__(193);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(363);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(22);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 364 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(366),
    ListCache = __webpack_require__(90),
    Map = __webpack_require__(142);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(367),
    hashDelete = __webpack_require__(368),
    hashGet = __webpack_require__(369),
    hashHas = __webpack_require__(370),
    hashSet = __webpack_require__(371);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(92);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 368 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(92);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(92);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(92);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(93);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 373 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(93);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(93);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(93);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(89),
    equalArrays = __webpack_require__(195),
    equalByTag = __webpack_require__(383),
    equalObjects = __webpack_require__(386),
    getTag = __webpack_require__(94),
    isArray = __webpack_require__(16),
    isBuffer = __webpack_require__(87),
    isTypedArray = __webpack_require__(135);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(143),
    setCacheAdd = __webpack_require__(379),
    setCacheHas = __webpack_require__(380);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 379 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 380 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 381 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 382 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(73),
    Uint8Array = __webpack_require__(196),
    eq = __webpack_require__(75),
    equalArrays = __webpack_require__(195),
    mapToArray = __webpack_require__(384),
    setToArray = __webpack_require__(385);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 384 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 385 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(197);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 387 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(43),
    root = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(201),
    keys = __webpack_require__(74);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(194),
    get = __webpack_require__(394),
    hasIn = __webpack_require__(400),
    isKey = __webpack_require__(145),
    isStrictComparable = __webpack_require__(201),
    matchesStrictComparable = __webpack_require__(202),
    toKey = __webpack_require__(96);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(203);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(396);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(397);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(143);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(399);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(73),
    arrayMap = __webpack_require__(192),
    isArray = __webpack_require__(16),
    isSymbol = __webpack_require__(95);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(401),
    hasPath = __webpack_require__(402);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 401 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(204),
    isArguments = __webpack_require__(132),
    isArray = __webpack_require__(16),
    isIndex = __webpack_require__(134),
    isLength = __webpack_require__(136),
    toKey = __webpack_require__(96);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(404),
    basePropertyDeep = __webpack_require__(405),
    isKey = __webpack_require__(145),
    toKey = __webpack_require__(96);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 404 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(203);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(205),
    isArrayLike = __webpack_require__(54);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(54);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeClasses = undefined;

var _forOwn2 = __webpack_require__(131);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _cloneDeep2 = __webpack_require__(409);

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mergeClasses = exports.mergeClasses = function mergeClasses(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function (name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3.default)(toMerge, function (value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }

        styles[key] = _extends({}, styles[key], toMerge[key]);
      });
    }

    return name;
  });
  return styles;
};

exports.default = mergeClasses;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(410);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(89),
    arrayEach = __webpack_require__(206),
    assignValue = __webpack_require__(207),
    baseAssign = __webpack_require__(411),
    baseAssignIn = __webpack_require__(412),
    cloneBuffer = __webpack_require__(209),
    copyArray = __webpack_require__(210),
    copySymbols = __webpack_require__(415),
    copySymbolsIn = __webpack_require__(416),
    getAllKeys = __webpack_require__(197),
    getAllKeysIn = __webpack_require__(417),
    getTag = __webpack_require__(94),
    initCloneArray = __webpack_require__(418),
    initCloneByTag = __webpack_require__(419),
    initCloneObject = __webpack_require__(213),
    isArray = __webpack_require__(16),
    isBuffer = __webpack_require__(87),
    isMap = __webpack_require__(424),
    isObject = __webpack_require__(20),
    isSet = __webpack_require__(426),
    keys = __webpack_require__(74);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(76),
    keys = __webpack_require__(74);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(76),
    keysIn = __webpack_require__(97);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20),
    isPrototype = __webpack_require__(139),
    nativeKeysIn = __webpack_require__(414);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 414 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(76),
    getSymbols = __webpack_require__(144);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(76),
    getSymbolsIn = __webpack_require__(211);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(198),
    getSymbolsIn = __webpack_require__(211),
    keysIn = __webpack_require__(97);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 418 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(147),
    cloneDataView = __webpack_require__(420),
    cloneRegExp = __webpack_require__(421),
    cloneSymbol = __webpack_require__(422),
    cloneTypedArray = __webpack_require__(212);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(147);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 421 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(73);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(425),
    baseUnary = __webpack_require__(137),
    nodeUtil = __webpack_require__(138);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(94),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(427),
    baseUnary = __webpack_require__(137),
    nodeUtil = __webpack_require__(138);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(94),
    isObjectLike = __webpack_require__(25);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoprefix = undefined;

var _forOwn2 = __webpack_require__(131);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },

  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },

  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },

  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(' ');
    return {
      position: 'absolute',
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      'extend': name
    };
  }
};

var autoprefix = exports.autoprefix = function autoprefix(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function (styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function (value, key) {
      var transform = transforms[key];
      if (transform) {
        expanded = _extends({}, expanded, transform(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};

exports.default = autoprefix;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hover = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hover = exports.hover = function hover(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Hover, _React$Component);

    function Hover() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Hover);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function () {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function () {
        return _this.setState({ hover: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Hover;
  }(_react2.default.Component);
};

exports.default = hover;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.active = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var active = exports.active = function active(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Active, _React$Component);

    function Active() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Active);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function () {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function () {
        return _this.setState({ active: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Active;
  }(_react2.default.Component);
};

exports.default = active;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var loopable = function loopable(i, length) {
  var props = {};
  var setProp = function setProp(name) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    props[name] = value;
  };

  i === 0 && setProp('first-child');
  i === length - 1 && setProp('last-child');
  (i === 0 || i % 2 === 0) && setProp('even');
  Math.abs(i % 2) === 1 && setProp('odd');
  setProp('nth-child', i);

  return props;
};

exports.default = loopable;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Alpha = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _alpha = __webpack_require__(433);

var alpha = _interopRequireWildcard(_alpha);

var _Checkboard = __webpack_require__(148);

var _Checkboard2 = _interopRequireDefault(_Checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Alpha = exports.Alpha = function (_ref) {
  _inherits(Alpha, _ref);

  function Alpha() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Alpha);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
      var change = alpha.calculateChange(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleChange);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Alpha, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var rgb = this.props.rgb;
      var styles = (0, _reactcss2.default)({
        'default': {
          alpha: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: '0px 0px 0px 0px',
            overflow: 'hidden',
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: 'relative',
            height: '100%',
            margin: '0 3px'
          },
          pointer: {
            position: 'absolute',
            left: rgb.a * 100 + '%'
          },
          slider: {
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            marginTop: '1px',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          gradient: {
            background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + '%'
          }
        },
        'overwrite': _extends({}, this.props.style)
      }, {
        vertical: this.props.direction === 'vertical',
        overwrite: true
      });

      return _react2.default.createElement(
        'div',
        { style: styles.alpha },
        _react2.default.createElement(
          'div',
          { style: styles.checkboard },
          _react2.default.createElement(_Checkboard2.default, { renderers: this.props.renderers })
        ),
        _react2.default.createElement('div', { style: styles.gradient }),
        _react2.default.createElement(
          'div',
          {
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Alpha;
}(_react.PureComponent || _react.Component);

exports.default = Alpha;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, hsl, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (direction === 'vertical') {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }

    if (hsl.a !== a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: a,
        source: 'rgb'
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }

    if (initialA !== _a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a,
        source: 'rgb'
      };
    }
  }
  return null;
};

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var checkboardCache = {};

var render = exports.render = function render(c1, c2, size, serverCanvas) {
  if (typeof document === 'undefined' && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext('2d');
  if (!ctx) {
    return null;
  } // If no context can be found, return early.
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};

var get = exports.get = function get(c1, c2, size, serverCanvas) {
  var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');

  if (checkboardCache[key]) {
    return checkboardCache[key];
  }

  var checkboard = render(c1, c2, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableInput = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_ARROW_OFFSET = 1;

var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue(value) {
  return Number(String(value).replace(/%/g, ''));
};

var EditableInput = exports.EditableInput = function (_ref) {
  _inherits(EditableInput, _ref);

  function EditableInput(props) {
    _classCallCheck(this, EditableInput);

    var _this = _possibleConstructorReturn(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));

    _this.handleBlur = function () {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };

    _this.handleChange = function (e) {
      _this.setUpdatedValue(e.target.value, e);
    };

    _this.handleKeyDown = function (e) {
      // In case `e.target.value` is a percentage remove the `%` character
      // and update accordingly with a percentage
      // https://github.com/casesandberg/react-color/issues/383
      var value = getNumberValue(e.target.value);
      if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
        var offset = _this.getArrowOffset();
        var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset : value - offset;

        _this.setUpdatedValue(updatedValue, e);
      }
    };

    _this.handleDrag = function (e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
        }
      }
    };

    _this.handleMouseDown = function (e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener('mousemove', _this.handleDrag);
        window.addEventListener('mouseup', _this.handleMouseUp);
      }
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleDrag);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    return _this;
  }

  _createClass(EditableInput, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'getValueObjectWithLabel',
    value: function getValueObjectWithLabel(value) {
      return _defineProperty({}, this.props.label, value);
    }
  }, {
    key: 'getArrowOffset',
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: 'setUpdatedValue',
    value: function setUpdatedValue(value, e) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e);

      this.setState({ value: value });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            position: 'relative'
          }
        },
        'user-override': {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        'dragLabel-true': {
          label: {
            cursor: 'ew-resize'
          }
        }
      }, {
        'user-override': true
      }, this.props);

      return _react2.default.createElement(
        'div',
        { style: styles.wrap },
        _react2.default.createElement('input', {
          style: styles.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: 'false'
        }),
        this.props.label && !this.props.hideLabel ? _react2.default.createElement(
          'span',
          { style: styles.label, onMouseDown: this.handleMouseDown },
          this.props.label
        ) : null
      );
    }
  }]);

  return EditableInput;
}(_react.PureComponent || _react.Component);

exports.default = EditableInput;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _hue = __webpack_require__(437);

var hue = _interopRequireWildcard(_hue);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Hue = exports.Hue = function (_ref) {
  _inherits(Hue, _ref);

  function Hue() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Hue);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
      var change = hue.calculateChange(e, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Hue, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props$direction = this.props.direction,
          direction = _props$direction === undefined ? 'horizontal' : _props$direction;


      var styles = (0, _reactcss2.default)({
        'default': {
          hue: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: '0 2px',
            position: 'relative',
            height: '100%',
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            left: this.props.hsl.h * 100 / 360 + '%'
          },
          slider: {
            marginTop: '1px',
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          pointer: {
            left: '0px',
            top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
          }
        }
      }, { vertical: direction === 'vertical' });

      return _react2.default.createElement(
        'div',
        { style: styles.hue },
        _react2.default.createElement(
          'div',
          {
            className: 'hue-' + direction,
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'style',
            null,
            '\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          '
          ),
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Hue;
}(_react.PureComponent || _react.Component);

exports.default = Hue;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, direction, hsl, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (direction === 'vertical') {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }

    if (hsl.h !== h) {
      return {
        h: h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: 'hsl'
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }

    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: 'hsl'
      };
    }
  }
  return null;
};

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Raised = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Raised = exports.Raised = function Raised(_ref) {
  var zDepth = _ref.zDepth,
      radius = _ref.radius,
      background = _ref.background,
      children = _ref.children,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      wrap: {
        position: 'relative',
        display: 'inline-block'
      },
      content: {
        position: 'relative'
      },
      bg: {
        absolute: '0px 0px 0px 0px',
        boxShadow: '0 ' + zDepth + 'px ' + zDepth * 4 + 'px rgba(0,0,0,.24)',
        borderRadius: radius,
        background: background
      }
    },
    'zDepth-0': {
      bg: {
        boxShadow: 'none'
      }
    },

    'zDepth-1': {
      bg: {
        boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
      }
    },
    'zDepth-2': {
      bg: {
        boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
      }
    },
    'zDepth-3': {
      bg: {
        boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
      }
    },
    'zDepth-4': {
      bg: {
        boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
      }
    },
    'zDepth-5': {
      bg: {
        boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
      }
    },
    'square': {
      bg: {
        borderRadius: '0'
      }
    },
    'circle': {
      bg: {
        borderRadius: '50%'
      }
    }
  }, passedStyles), { 'zDepth-1': zDepth === 1 });

  return _react2.default.createElement(
    'div',
    { style: styles.wrap },
    _react2.default.createElement('div', { style: styles.bg }),
    _react2.default.createElement(
      'div',
      { style: styles.content },
      children
    )
  );
};

Raised.propTypes = {
  background: _propTypes2.default.string,
  zDepth: _propTypes2.default.oneOf([0, 1, 2, 3, 4, 5]),
  radius: _propTypes2.default.number,
  styles: _propTypes2.default.object
};

Raised.defaultProps = {
  background: '#fff',
  zDepth: 1,
  radius: 2,
  styles: {}
};

exports.default = Raised;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(89),
    assignMergeValue = __webpack_require__(214),
    baseFor = __webpack_require__(187),
    baseMergeDeep = __webpack_require__(440),
    isObject = __webpack_require__(20),
    keysIn = __webpack_require__(97),
    safeGet = __webpack_require__(215);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(214),
    cloneBuffer = __webpack_require__(209),
    cloneTypedArray = __webpack_require__(212),
    copyArray = __webpack_require__(210),
    initCloneObject = __webpack_require__(213),
    isArguments = __webpack_require__(132),
    isArray = __webpack_require__(16),
    isArrayLikeObject = __webpack_require__(441),
    isBuffer = __webpack_require__(87),
    isFunction = __webpack_require__(140),
    isObject = __webpack_require__(20),
    isPlainObject = __webpack_require__(191),
    isTypedArray = __webpack_require__(135),
    safeGet = __webpack_require__(215),
    toPlainObject = __webpack_require__(442);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(54),
    isObjectLike = __webpack_require__(25);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(76),
    keysIn = __webpack_require__(97);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(444),
    isIterateeCall = __webpack_require__(451);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(88),
    overRest = __webpack_require__(445),
    setToString = __webpack_require__(447);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(446);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 446 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(448),
    shortOut = __webpack_require__(450);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(449),
    defineProperty = __webpack_require__(208),
    identity = __webpack_require__(88);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 449 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 450 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(75),
    isArrayLike = __webpack_require__(54),
    isIndex = __webpack_require__(134),
    isObject = __webpack_require__(20);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Saturation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _throttle = __webpack_require__(453);

var _throttle2 = _interopRequireDefault(_throttle);

var _saturation = __webpack_require__(456);

var saturation = _interopRequireWildcard(_saturation);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Saturation = exports.Saturation = function (_ref) {
  _inherits(Saturation, _ref);

  function Saturation(props) {
    _classCallCheck(this, Saturation);

    var _this = _possibleConstructorReturn(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));

    _this.handleChange = function (e) {
      typeof _this.props.onChange === 'function' && _this.throttle(_this.props.onChange, saturation.calculateChange(e, _this.props.hsl, _this.container), e);
    };

    _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.throttle = (0, _throttle2.default)(function (fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }

  _createClass(Saturation, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _ref2 = this.props.style || {},
          color = _ref2.color,
          white = _ref2.white,
          black = _ref2.black,
          pointer = _ref2.pointer,
          circle = _ref2.circle;

      var styles = (0, _reactcss2.default)({
        'default': {
          color: {
            absolute: '0px 0px 0px 0px',
            background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
            borderRadius: this.props.radius
          },
          white: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          black: {
            absolute: '0px 0px 0px 0px',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            top: -(this.props.hsv.v * 100) + 100 + '%',
            left: this.props.hsv.s * 100 + '%',
            cursor: 'default'
          },
          circle: {
            width: '4px',
            height: '4px',
            boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
            borderRadius: '50%',
            cursor: 'hand',
            transform: 'translate(-2px, -2px)'
          }
        },
        'custom': {
          color: color,
          white: white,
          black: black,
          pointer: pointer,
          circle: circle
        }
      }, { 'custom': !!this.props.style });

      return _react2.default.createElement(
        'div',
        {
          style: styles.color,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        _react2.default.createElement(
          'style',
          null,
          '\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        '
        ),
        _react2.default.createElement(
          'div',
          { style: styles.white, className: 'saturation-white' },
          _react2.default.createElement('div', { style: styles.black, className: 'saturation-black' }),
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.circle })
          )
        )
      );
    }
  }]);

  return Saturation;
}(_react.PureComponent || _react.Component);

exports.default = Saturation;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(216),
    isObject = __webpack_require__(20);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(22);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(20),
    isSymbol = __webpack_require__(95);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var calculateChange = exports.calculateChange = function calculateChange(e, hsl, container) {
  var _container$getBoundin = container.getBoundingClientRect(),
      containerWidth = _container$getBoundin.width,
      containerHeight = _container$getBoundin.height;

  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }

  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }

  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;

  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: 'hsv'
  };
};

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(458);


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(206),
    baseEach = __webpack_require__(205),
    castFunction = __webpack_require__(190),
    isArray = __webpack_require__(16);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if ( true && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {}

})(Math);


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatch = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _interaction = __webpack_require__(461);

var _Checkboard = __webpack_require__(148);

var _Checkboard2 = _interopRequireDefault(_Checkboard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ENTER = 13;

var Swatch = exports.Swatch = function Swatch(_ref) {
  var color = _ref.color,
      style = _ref.style,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onHover = _ref.onHover,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? color : _ref$title,
      children = _ref.children,
      focus = _ref.focus,
      _ref$focusStyle = _ref.focusStyle,
      focusStyle = _ref$focusStyle === undefined ? {} : _ref$focusStyle;

  var transparent = color === 'transparent';
  var styles = (0, _reactcss2.default)({
    default: {
      swatch: _extends({
        background: color,
        height: '100%',
        width: '100%',
        cursor: 'pointer',
        position: 'relative',
        outline: 'none'
      }, style, focus ? focusStyle : {})
    }
  });

  var handleClick = function handleClick(e) {
    return onClick(color, e);
  };
  var handleKeyDown = function handleKeyDown(e) {
    return e.keyCode === ENTER && onClick(color, e);
  };
  var handleHover = function handleHover(e) {
    return onHover(color, e);
  };

  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover;
  }

  return _react2.default.createElement(
    'div',
    _extends({
      style: styles.swatch,
      onClick: handleClick,
      title: title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && _react2.default.createElement(_Checkboard2.default, {
      borderRadius: styles.swatch.borderRadius,
      boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.1)'
    })
  );
};

exports.default = (0, _interaction.handleFocus)(Swatch);

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleFocus = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-invalid-this */


var handleFocus = exports.handleFocus = function handleFocus(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
  return function (_React$Component) {
    _inherits(Focus, _React$Component);

    function Focus() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Focus);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function () {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function () {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(Focus, [{
      key: 'render',
      value: function render() {
        return _react2.default.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          _react2.default.createElement(Component, _extends({}, this.props, this.state))
        );
      }
    }]);

    return Focus;
  }(_react2.default.Component);
};

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPointer = exports.AlphaPointer = function AlphaPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = AlphaPointer;

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

var _BlockSwatches = __webpack_require__(464);

var _BlockSwatches2 = _interopRequireDefault(_BlockSwatches);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Block = exports.Block = function Block(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var transparent = hex === 'transparent';
  var handleChange = function handleChange(hexCode, e) {
    _color2.default.isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: 'hex'
    }, e);
  };

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        boxShadow: '0 1px rgba(0,0,0,.1)',
        borderRadius: '6px',
        position: 'relative'
      },
      head: {
        height: '110px',
        background: hex,
        borderRadius: '6px 6px 0 0',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative'
      },
      body: {
        padding: '10px'
      },
      label: {
        fontSize: '18px',
        color: _color2.default.getContrastingColor(hex),
        position: 'relative'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 10px 10px 10px',
        borderColor: 'transparent transparent ' + hex + ' transparent',
        position: 'absolute',
        top: '-10px',
        left: '50%',
        marginLeft: '-10px'
      },
      input: {
        width: '100%',
        fontSize: '12px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '22px',
        boxShadow: 'inset 0 0 0 1px #ddd',
        borderRadius: '4px',
        padding: '0 7px',
        boxSizing: 'border-box'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      }
    }
  }, passedStyles), { 'hide-triangle': triangle === 'hide' });

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'block-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.head },
      transparent && _react2.default.createElement(_common.Checkboard, { borderRadius: '6px 6px 0 0' }),
      _react2.default.createElement(
        'div',
        { style: styles.label },
        hex
      )
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(_BlockSwatches2.default, { colors: colors, onClick: handleChange, onSwatchHover: onSwatchHover }),
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};

Block.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  triangle: _propTypes2.default.oneOf(['top', 'hide']),
  styles: _propTypes2.default.object
};

Block.defaultProps = {
  width: 170,
  colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
  triangle: 'top',
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Block);

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockSwatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlockSwatches = exports.BlockSwatches = function BlockSwatches(_ref) {
  var colors = _ref.colors,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginRight: '-10px'
      },
      swatch: {
        width: '22px',
        height: '22px',
        float: 'left',
        marginRight: '10px',
        marginBottom: '10px',
        borderRadius: '4px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_common.Swatch, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick: onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: '0 0 4px ' + c
        }
      });
    }),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = BlockSwatches;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Circle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _materialColors = __webpack_require__(218);

var material = _interopRequireWildcard(_materialColors);

var _common = __webpack_require__(8);

var _CircleSwatch = __webpack_require__(466);

var _CircleSwatch2 = _interopRequireDefault(_CircleSwatch);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Circle = exports.Circle = function Circle(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      circleSize = _ref.circleSize,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      circleSpacing = _ref.circleSpacing,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      card: {
        width: width,
        display: 'flex',
        flexWrap: 'wrap',
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(hexCode, e) {
    return onChange({ hex: hexCode, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'circle-picker ' + className },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_CircleSwatch2.default, {
        key: c,
        color: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover,
        active: hex === c.toLowerCase(),
        circleSize: circleSize,
        circleSpacing: circleSpacing
      });
    })
  );
};

Circle.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  circleSize: _propTypes2.default.number,
  circleSpacing: _propTypes2.default.number,
  styles: _propTypes2.default.object
};

Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [material.red['500'], material.pink['500'], material.purple['500'], material.deepPurple['500'], material.indigo['500'], material.blue['500'], material.lightBlue['500'], material.cyan['500'], material.teal['500'], material.green['500'], material.lightGreen['500'], material.lime['500'], material.yellow['500'], material.amber['500'], material.orange['500'], material.deepOrange['500'], material.brown['500'], material.blueGrey['500']],
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Circle);

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CircleSwatch = exports.CircleSwatch = function CircleSwatch(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      hover = _ref.hover,
      active = _ref.active,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: 'scale(1)',
        transition: '100ms transform ease'
      },
      Swatch: {
        borderRadius: '50%',
        background: 'transparent',
        boxShadow: 'inset 0 0 0 ' + (circleSize / 2 + 1) + 'px ' + color,
        transition: '100ms box-shadow ease'
      }
    },
    'hover': {
      swatch: {
        transform: 'scale(1.2)'
      }
    },
    'active': {
      Swatch: {
        boxShadow: 'inset 0 0 0 3px ' + color
      }
    }
  }, { hover: hover, active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, {
      style: styles.Swatch,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles.Swatch.boxShadow + ', 0 0 5px ' + color }
    })
  );
};

CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};

exports.default = (0, _reactcss.handleHover)(CircleSwatch);

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _ChromeFields = __webpack_require__(468);

var _ChromeFields2 = _interopRequireDefault(_ChromeFields);

var _ChromePointer = __webpack_require__(471);

var _ChromePointer2 = _interopRequireDefault(_ChromePointer);

var _ChromePointerCircle = __webpack_require__(472);

var _ChromePointerCircle2 = _interopRequireDefault(_ChromePointerCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chrome = exports.Chrome = function Chrome(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      disableAlpha = _ref.disableAlpha,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hsv = _ref.hsv,
      hex = _ref.hex,
      renderers = _ref.renderers,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className,
      defaultView = _ref.defaultView;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      picker: {
        width: width,
        background: '#fff',
        borderRadius: '2px',
        boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
        boxSizing: 'initial',
        fontFamily: 'Menlo'
      },
      saturation: {
        width: '100%',
        paddingBottom: '55%',
        position: 'relative',
        borderRadius: '2px 2px 0 0',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '2px 2px 0 0'
      },
      body: {
        padding: '16px 16px 12px'
      },
      controls: {
        display: 'flex'
      },
      color: {
        width: '32px'
      },
      swatch: {
        marginTop: '6px',
        width: '16px',
        height: '16px',
        borderRadius: '8px',
        position: 'relative',
        overflow: 'hidden'
      },
      active: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '8px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
        background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
        zIndex: '2'
      },
      toggles: {
        flex: '1'
      },
      hue: {
        height: '10px',
        position: 'relative',
        marginBottom: '8px'
      },
      Hue: {
        radius: '2px'
      },
      alpha: {
        height: '10px',
        position: 'relative'
      },
      Alpha: {
        radius: '2px'
      }
    },
    'disableAlpha': {
      color: {
        width: '22px'
      },
      alpha: {
        display: 'none'
      },
      hue: {
        marginBottom: '0px'
      },
      swatch: {
        width: '10px',
        height: '10px',
        marginTop: '0px'
      }
    }
  }, passedStyles), { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'chrome-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        pointer: _ChromePointerCircle2.default,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(
        'div',
        { style: styles.controls, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.color },
          _react2.default.createElement(
            'div',
            { style: styles.swatch },
            _react2.default.createElement('div', { style: styles.active }),
            _react2.default.createElement(_common.Checkboard, { renderers: renderers })
          )
        ),
        _react2.default.createElement(
          'div',
          { style: styles.toggles },
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              style: styles.Hue,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              onChange: onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.Alpha, {
              style: styles.Alpha,
              rgb: rgb,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              renderers: renderers,
              onChange: onChange
            })
          )
        )
      ),
      _react2.default.createElement(_ChromeFields2.default, {
        rgb: rgb,
        hsl: hsl,
        hex: hex,
        view: defaultView,
        onChange: onChange,
        disableAlpha: disableAlpha
      })
    )
  );
};

Chrome.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  disableAlpha: _propTypes2.default.bool,
  styles: _propTypes2.default.object,
  defaultView: _propTypes2.default.oneOf(["hex", "rgb", "hsl"])
};

Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Chrome);

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromeFields = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _isUndefined = __webpack_require__(469);

var _isUndefined2 = _interopRequireDefault(_isUndefined);

var _common = __webpack_require__(8);

var _UnfoldMoreHorizontalIcon = __webpack_require__(470);

var _UnfoldMoreHorizontalIcon2 = _interopRequireDefault(_UnfoldMoreHorizontalIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-did-mount-set-state, no-param-reassign */

var ChromeFields = exports.ChromeFields = function (_React$Component) {
  _inherits(ChromeFields, _React$Component);

  function ChromeFields(props) {
    _classCallCheck(this, ChromeFields);

    var _this = _possibleConstructorReturn(this, (ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call(this));

    _this.toggleViews = function () {
      if (_this.state.view === 'hex') {
        _this.setState({ view: 'rgb' });
      } else if (_this.state.view === 'rgb') {
        _this.setState({ view: 'hsl' });
      } else if (_this.state.view === 'hsl') {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: 'hex' });
        } else {
          _this.setState({ view: 'rgb' });
        }
      }
    };

    _this.handleChange = function (data, e) {
      if (data.hex) {
        _color2.default.isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: 'hex'
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: 'rgb'
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }

        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: 'rgb'
        }, e);
      } else if (data.h || data.s || data.l) {
        // Remove any occurances of '%'.
        if (typeof data.s === 'string' && data.s.includes('%')) {
          data.s = data.s.replace('%', '');
        }
        if (typeof data.l === 'string' && data.l.includes('%')) {
          data.l = data.l.replace('%', '');
        }

        // We store HSL as a unit interval so we need to override the 1 input to 0.01
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }

        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!(0, _isUndefined2.default)(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!(0, _isUndefined2.default)(data.l) ? data.l : _this.props.hsl.l),
          source: 'hsl'
        }, e);
      }
    };

    _this.showHighlight = function (e) {
      e.currentTarget.style.background = '#eee';
    };

    _this.hideHighlight = function (e) {
      e.currentTarget.style.background = 'transparent';
    };

    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }

  _createClass(ChromeFields, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            paddingTop: '16px',
            display: 'flex'
          },
          fields: {
            flex: '1',
            display: 'flex',
            marginLeft: '-6px'
          },
          field: {
            paddingLeft: '6px',
            width: '100%'
          },
          alpha: {
            paddingLeft: '6px',
            width: '100%'
          },
          toggle: {
            width: '32px',
            textAlign: 'right',
            position: 'relative'
          },
          icon: {
            marginRight: '-4px',
            marginTop: '12px',
            cursor: 'pointer',
            position: 'relative'
          },
          iconHighlight: {
            position: 'absolute',
            width: '24px',
            height: '28px',
            background: '#eee',
            borderRadius: '4px',
            top: '10px',
            left: '12px',
            display: 'none'
          },
          input: {
            fontSize: '11px',
            color: '#333',
            width: '100%',
            borderRadius: '2px',
            border: 'none',
            boxShadow: 'inset 0 0 0 1px #dadada',
            height: '21px',
            textAlign: 'center'
          },
          label: {
            textTransform: 'uppercase',
            fontSize: '11px',
            lineHeight: '11px',
            color: '#969696',
            textAlign: 'center',
            display: 'block',
            marginTop: '12px'
          },
          svg: {
            fill: '#333',
            width: '24px',
            height: '24px',
            border: '1px transparent solid',
            borderRadius: '5px'
          }
        },
        'disableAlpha': {
          alpha: {
            display: 'none'
          }
        }
      }, this.props, this.state);

      var fields = void 0;
      if (this.state.view === 'hex') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'hex', value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'rgb') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'r',
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'g',
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'b',
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'hsl') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'h',
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 's',
              value: Math.round(this.props.hsl.s * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'l',
              value: Math.round(this.props.hsl.l * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }

      return _react2.default.createElement(
        'div',
        { style: styles.wrap, className: 'flexbox-fix' },
        fields,
        _react2.default.createElement(
          'div',
          { style: styles.toggle },
          _react2.default.createElement(
            'div',
            { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
                return _this2.icon = icon;
              } },
            _react2.default.createElement(_UnfoldMoreHorizontalIcon2.default, {
              style: styles.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === 'hex') {
        return { view: 'rgb' };
      }
      return null;
    }
  }]);

  return ChromeFields;
}(_react2.default.Component);

ChromeFields.defaultProps = {
  view: "hex"
};

exports.default = ChromeFields;

/***/ }),
/* 469 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var DEFAULT_SIZE = 24;

exports.default = function (_ref) {
  var _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
      _ref$width = _ref.width,
      width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? {} : _ref$style,
      props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);

  return _react2.default.createElement(
    'svg',
    _extends({
      viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
      style: _extends({ fill: fill, width: width, height: height }, style)
    }, props),
    _react2.default.createElement('path', { d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z' })
  );
};

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointer = exports.ChromePointer = function ChromePointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        transform: 'translate(-6px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointer;

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointerCircle = exports.ChromePointerCircle = function ChromePointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointerCircle;

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compact = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

var _CompactColor = __webpack_require__(474);

var _CompactColor2 = _interopRequireDefault(_CompactColor);

var _CompactFields = __webpack_require__(475);

var _CompactFields2 = _interopRequireDefault(_CompactFields);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Compact = exports.Compact = function Compact(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      Compact: {
        background: '#f6f6f6',
        radius: '4px'
      },
      compact: {
        paddingTop: '5px',
        paddingLeft: '5px',
        boxSizing: 'initial',
        width: '240px'
      },
      clear: {
        clear: 'both'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else {
      onChange(data, e);
    }
  };

  return _react2.default.createElement(
    _common.Raised,
    { style: styles.Compact, styles: passedStyles },
    _react2.default.createElement(
      'div',
      { style: styles.compact, className: 'compact-picker ' + className },
      _react2.default.createElement(
        'div',
        null,
        (0, _map2.default)(colors, function (c) {
          return _react2.default.createElement(_CompactColor2.default, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover: onSwatchHover
          });
        }),
        _react2.default.createElement('div', { style: styles.clear })
      ),
      _react2.default.createElement(_CompactFields2.default, { hex: hex, rgb: rgb, onChange: handleChange })
    )
  );
};

Compact.propTypes = {
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  styles: _propTypes2.default.object
};

Compact.defaultProps = {
  colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E'],
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Compact);

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactColor = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactColor = exports.CompactColor = function CompactColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        background: color,
        width: '15px',
        height: '15px',
        float: 'left',
        marginRight: '5px',
        marginBottom: '5px',
        position: 'relative',
        cursor: 'pointer'
      },
      dot: {
        absolute: '5px 5px 5px 5px',
        background: _color2.default.getContrastingColor(color),
        borderRadius: '50%',
        opacity: '0'
      }
    },
    'active': {
      dot: {
        opacity: '1'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      dot: {
        background: '#000'
      }
    },
    'transparent': {
      dot: {
        background: '#000'
      }
    }
  }, { active: active, 'color-#FFFFFF': color === '#FFFFFF', 'transparent': color === 'transparent' });

  return _react2.default.createElement(
    _common.Swatch,
    {
      style: styles.color,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    _react2.default.createElement('div', { style: styles.dot })
  );
};

exports.default = CompactColor;

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactFields = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactFields = exports.CompactFields = function CompactFields(_ref) {
  var hex = _ref.hex,
      rgb = _ref.rgb,
      onChange = _ref.onChange;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingBottom: '6px',
        paddingRight: '5px',
        position: 'relative'
      },
      active: {
        position: 'absolute',
        top: '6px',
        left: '5px',
        height: '9px',
        width: '9px',
        background: hex
      },
      HEXwrap: {
        flex: '6',
        position: 'relative'
      },
      HEXinput: {
        width: '80%',
        padding: '0px',
        paddingLeft: '20%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      HEXlabel: {
        display: 'none'
      },
      RGBwrap: {
        flex: '3',
        position: 'relative'
      },
      RGBinput: {
        width: '70%',
        padding: '0px',
        paddingLeft: '30%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '3px',
        left: '0px',
        lineHeight: '16px',
        textTransform: 'uppercase',
        fontSize: '12px',
        color: '#999'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement('div', { style: styles.active }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: 'hex',
      value: hex,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    })
  );
};

exports.default = CompactFields;

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Github = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _GithubSwatch = __webpack_require__(477);

var _GithubSwatch2 = _interopRequireDefault(_GithubSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Github = exports.Github = function Github(_ref) {
  var width = _ref.width,
      colors = _ref.colors,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '1px solid rgba(0,0,0,0.2)',
        boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
        borderRadius: '4px',
        position: 'relative',
        padding: '5px',
        display: 'flex',
        flexWrap: 'wrap'
      },
      triangle: {
        position: 'absolute',
        border: '7px solid transparent',
        borderBottomColor: '#fff'
      },
      triangleShadow: {
        position: 'absolute',
        border: '8px solid transparent',
        borderBottomColor: 'rgba(0,0,0,0.15)'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-14px',
        left: '10px'
      },
      triangleShadow: {
        top: '-16px',
        left: '9px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-14px',
        right: '10px'
      },
      triangleShadow: {
        top: '-16px',
        right: '9px'
      }
    },
    'bottom-left-triangle': {
      triangle: {
        top: '35px',
        left: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        left: '9px',
        transform: 'rotate(180deg)'
      }
    },
    'bottom-right-triangle': {
      triangle: {
        top: '35px',
        right: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        right: '9px',
        transform: 'rotate(180deg)'
      }
    }
  }, passedStyles), {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right',
    'bottom-left-triangle': triangle === 'bottom-left',
    'bottom-right-triangle': triangle === 'bottom-right'
  });

  var handleChange = function handleChange(hex, e) {
    return onChange({ hex: hex, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'github-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_GithubSwatch2.default, {
        color: c,
        key: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

Github.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  triangle: _propTypes2.default.oneOf(['hide', 'top-left', 'top-right', 'bottom-left', 'bottom-right']),
  styles: _propTypes2.default.object
};

Github.defaultProps = {
  width: 200,
  colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
  triangle: 'top-left',
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Github);

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GithubSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GithubSwatch = exports.GithubSwatch = function GithubSwatch(_ref) {
  var hover = _ref.hover,
      color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var hoverSwatch = {
    position: 'relative',
    zIndex: '2',
    outline: '2px solid #fff',
    boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
  };

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: '25px',
        height: '25px',
        fontSize: '0'
      }
    },
    'hover': {
      swatch: hoverSwatch
    }
  }, { hover: hover });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, {
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};

exports.default = (0, _reactcss.handleHover)(GithubSwatch);

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HuePicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _HuePointer = __webpack_require__(479);

var _HuePointer2 = _interopRequireDefault(_HuePointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HuePicker = exports.HuePicker = function HuePicker(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      hsl = _ref.hsl,
      direction = _ref.direction,
      pointer = _ref.pointer,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      hue: {
        radius: '2px'
      }
    }
  }, passedStyles));

  // Overwrite to provide pure hue color
  var handleChange = function handleChange(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'hue-picker ' + className },
    _react2.default.createElement(_common.Hue, _extends({}, styles.hue, {
      hsl: hsl,
      pointer: pointer,
      onChange: handleChange,
      direction: direction
    }))
  );
};

HuePicker.propTypes = {
  styles: _propTypes2.default.object
};
HuePicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _HuePointer2.default,
  styles: {}
};

exports.default = (0, _common.ColorWrap)(HuePicker);

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Material = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Material = exports.Material = function Material(_ref) {
  var onChange = _ref.onChange,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      material: {
        width: '98px',
        height: '98px',
        padding: '16px',
        fontFamily: 'Roboto'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '2px solid ' + hex,
        outline: 'none',
        height: '30px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '1px solid #eee',
        outline: 'none',
        height: '30px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      split: {
        display: 'flex',
        marginRight: '-10px',
        paddingTop: '11px'
      },
      third: {
        flex: '1',
        paddingRight: '10px'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    _common.Raised,
    { styles: passedStyles },
    _react2.default.createElement(
      'div',
      { style: styles.material, className: 'material-picker ' + className },
      _react2.default.createElement(_common.EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: 'hex',
        value: hex,
        onChange: handleChange
      }),
      _react2.default.createElement(
        'div',
        { style: styles.split, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'r', value: rgb.r,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};

exports.default = (0, _common.ColorWrap)(Material);

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Photoshop = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _PhotoshopFields = __webpack_require__(482);

var _PhotoshopFields2 = _interopRequireDefault(_PhotoshopFields);

var _PhotoshopPointerCircle = __webpack_require__(483);

var _PhotoshopPointerCircle2 = _interopRequireDefault(_PhotoshopPointerCircle);

var _PhotoshopPointer = __webpack_require__(484);

var _PhotoshopPointer2 = _interopRequireDefault(_PhotoshopPointer);

var _PhotoshopButton = __webpack_require__(485);

var _PhotoshopButton2 = _interopRequireDefault(_PhotoshopButton);

var _PhotoshopPreviews = __webpack_require__(486);

var _PhotoshopPreviews2 = _interopRequireDefault(_PhotoshopPreviews);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Photoshop = exports.Photoshop = function (_React$Component) {
  _inherits(Photoshop, _React$Component);

  function Photoshop(props) {
    _classCallCheck(this, Photoshop);

    var _this = _possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));

    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }

  _createClass(Photoshop, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          _props$styles = _props.styles,
          passedStyles = _props$styles === undefined ? {} : _props$styles,
          _props$className = _props.className,
          className = _props$className === undefined ? '' : _props$className;

      var styles = (0, _reactcss2.default)((0, _merge2.default)({
        'default': {
          picker: {
            background: '#DCDCDC',
            borderRadius: '4px',
            boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
            boxSizing: 'initial',
            width: '513px'
          },
          head: {
            backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
            borderBottom: '1px solid #B1B1B1',
            boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
            height: '23px',
            lineHeight: '24px',
            borderRadius: '4px 4px 0 0',
            fontSize: '13px',
            color: '#4D4D4D',
            textAlign: 'center'
          },
          body: {
            padding: '15px 15px 0',
            display: 'flex'
          },
          saturation: {
            width: '256px',
            height: '256px',
            position: 'relative',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0',
            overflow: 'hidden'
          },
          hue: {
            position: 'relative',
            height: '256px',
            width: '19px',
            marginLeft: '10px',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0'
          },
          controls: {
            width: '180px',
            marginLeft: '10px'
          },
          top: {
            display: 'flex'
          },
          previews: {
            width: '60px'
          },
          actions: {
            flex: '1',
            marginLeft: '20px'
          }
        }
      }, passedStyles));

      return _react2.default.createElement(
        'div',
        { style: styles.picker, className: 'photoshop-picker ' + className },
        _react2.default.createElement(
          'div',
          { style: styles.head },
          this.props.header
        ),
        _react2.default.createElement(
          'div',
          { style: styles.body, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.saturation },
            _react2.default.createElement(_common.Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: _PhotoshopPointerCircle2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              direction: 'vertical',
              hsl: this.props.hsl,
              pointer: _PhotoshopPointer2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.controls },
            _react2.default.createElement(
              'div',
              { style: styles.top, className: 'flexbox-fix' },
              _react2.default.createElement(
                'div',
                { style: styles.previews },
                _react2.default.createElement(_PhotoshopPreviews2.default, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              _react2.default.createElement(
                'div',
                { style: styles.actions },
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'OK', onClick: this.props.onAccept, active: true }),
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'Cancel', onClick: this.props.onCancel }),
                _react2.default.createElement(_PhotoshopFields2.default, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);

  return Photoshop;
}(_react2.default.Component);

Photoshop.propTypes = {
  header: _propTypes2.default.string,
  styles: _propTypes2.default.object
};

Photoshop.defaultProps = {
  header: 'Color Picker',
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Photoshop);

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPicker = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPicker = exports.PhotoshopPicker = function PhotoshopPicker(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsv = _ref.hsv,
      hex = _ref.hex;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        paddingTop: '5px',
        paddingBottom: '9px',
        width: '80px',
        position: 'relative'
      },
      divider: {
        height: '5px'
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        marginLeft: '40%',
        width: '40%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '5px',
        fontSize: '13px',
        paddingLeft: '3px',
        marginRight: '10px'
      },
      RGBlabel: {
        left: '0px',
        width: '34px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px',
        position: 'absolute'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        marginLeft: '20%',
        width: '80%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '6px',
        fontSize: '13px',
        paddingLeft: '3px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        width: '14px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px'
      },
      fieldSymbols: {
        position: 'absolute',
        top: '5px',
        right: '-7px',
        fontSize: '13px'
      },
      symbol: {
        height: '20px',
        lineHeight: '22px',
        paddingBottom: '7px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data['#']) {
      _color2.default.isValidHex(data['#']) && onChange({
        hex: data['#'],
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: 'hsv'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields },
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'h',
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 's',
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'v',
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: '#',
      value: hex.replace('#', ''),
      onChange: handleChange
    }),
    _react2.default.createElement(
      'div',
      { style: styles.fieldSymbols },
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '\xB0'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      )
    )
  );
};

exports.default = PhotoshopPicker;

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    },
    'black-outline': {
      picker: {
        boxShadow: 'inset 0 0 0 1px #000'
      }
    }
  }, { 'black-outline': hsl.l > 0.5 });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = PhotoshopPointerCircle;

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '4px 0 4px 6px',
        borderColor: 'transparent transparent transparent #fff',
        position: 'absolute',
        top: '1px',
        left: '1px'
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '5px 0 5px 8px',
        borderColor: 'transparent transparent transparent #555'
      },

      left: {
        Extend: 'triangleBorder',
        transform: 'translate(-13px, -4px)'
      },
      leftInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      },

      right: {
        Extend: 'triangleBorder',
        transform: 'translate(20px, -14px) rotate(180deg)'
      },
      rightInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.pointer },
    _react2.default.createElement(
      'div',
      { style: styles.left },
      _react2.default.createElement('div', { style: styles.leftInside })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.right },
      _react2.default.createElement('div', { style: styles.rightInside })
    )
  );
};

exports.default = PhotoshopPointerCircle;

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopButton = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopButton = exports.PhotoshopButton = function PhotoshopButton(_ref) {
  var onClick = _ref.onClick,
      label = _ref.label,
      children = _ref.children,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      button: {
        backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
        border: '1px solid #878787',
        borderRadius: '2px',
        height: '20px',
        boxShadow: '0 1px 0 0 #EAEAEA',
        fontSize: '14px',
        color: '#000',
        lineHeight: '20px',
        textAlign: 'center',
        marginBottom: '10px',
        cursor: 'pointer'
      }
    },
    'active': {
      button: {
        boxShadow: '0 0 0 1px #878787'
      }
    }
  }, { active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.button, onClick: onClick },
    label || children
  );
};

exports.default = PhotoshopButton;

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPreviews = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPreviews = exports.PhotoshopPreviews = function PhotoshopPreviews(_ref) {
  var rgb = _ref.rgb,
      currentColor = _ref.currentColor;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        border: '1px solid #B3B3B3',
        borderBottom: '1px solid #F0F0F0',
        marginBottom: '2px',
        marginTop: '1px'
      },
      new: {
        height: '34px',
        background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
      },
      current: {
        height: '34px',
        background: currentColor,
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
      },
      label: {
        fontSize: '14px',
        color: '#000',
        textAlign: 'center'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'new'
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement('div', { style: styles.new }),
      _react2.default.createElement('div', { style: styles.current })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'current'
    )
  );
};

exports.default = PhotoshopPreviews;

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sketch = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _SketchFields = __webpack_require__(488);

var _SketchFields2 = _interopRequireDefault(_SketchFields);

var _SketchPresetColors = __webpack_require__(489);

var _SketchPresetColors2 = _interopRequireDefault(_SketchPresetColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sketch = exports.Sketch = function Sketch(_ref) {
  var width = _ref.width,
      rgb = _ref.rgb,
      hex = _ref.hex,
      hsv = _ref.hsv,
      hsl = _ref.hsl,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      disableAlpha = _ref.disableAlpha,
      presetColors = _ref.presetColors,
      renderers = _ref.renderers,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': _extends({
      picker: {
        width: width,
        padding: '10px 10px 0',
        boxSizing: 'initial',
        background: '#fff',
        borderRadius: '4px',
        boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
      },
      saturation: {
        width: '100%',
        paddingBottom: '75%',
        position: 'relative',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '3px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      controls: {
        display: 'flex'
      },
      sliders: {
        padding: '4px 0',
        flex: '1'
      },
      color: {
        width: '24px',
        height: '24px',
        position: 'relative',
        marginTop: '4px',
        marginLeft: '4px',
        borderRadius: '3px'
      },
      activeColor: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '2px',
        background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      hue: {
        position: 'relative',
        height: '10px',
        overflow: 'hidden'
      },
      Hue: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },

      alpha: {
        position: 'relative',
        height: '10px',
        marginTop: '4px',
        overflow: 'hidden'
      },
      Alpha: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      }
    }, passedStyles),
    'disableAlpha': {
      color: {
        height: '10px'
      },
      hue: {
        height: '10px'
      },
      alpha: {
        display: 'none'
      }
    }
  }, passedStyles), { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'sketch-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.controls, className: 'flexbox-fix' },
      _react2.default.createElement(
        'div',
        { style: styles.sliders },
        _react2.default.createElement(
          'div',
          { style: styles.hue },
          _react2.default.createElement(_common.Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.alpha },
          _react2.default.createElement(_common.Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          })
        )
      ),
      _react2.default.createElement(
        'div',
        { style: styles.color },
        _react2.default.createElement(_common.Checkboard, null),
        _react2.default.createElement('div', { style: styles.activeColor })
      )
    ),
    _react2.default.createElement(_SketchFields2.default, {
      rgb: rgb,
      hsl: hsl,
      hex: hex,
      onChange: onChange,
      disableAlpha: disableAlpha
    }),
    _react2.default.createElement(_SketchPresetColors2.default, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover: onSwatchHover
    })
  );
};

Sketch.propTypes = {
  disableAlpha: _propTypes2.default.bool,
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  styles: _propTypes2.default.object
};

Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF']
};

exports.default = (0, _common.ColorWrap)(Sketch);

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SketchFields = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign */

var SketchFields = exports.SketchFields = function SketchFields(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hex = _ref.hex,
      disableAlpha = _ref.disableAlpha;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingTop: '4px'
      },
      single: {
        flex: '1',
        paddingLeft: '6px'
      },
      alpha: {
        flex: '1',
        paddingLeft: '6px'
      },
      double: {
        flex: '2'
      },
      input: {
        width: '80%',
        padding: '4px 10% 3px',
        border: 'none',
        boxShadow: 'inset 0 0 0 1px #ccc',
        fontSize: '11px'
      },
      label: {
        display: 'block',
        textAlign: 'center',
        fontSize: '11px',
        color: '#222',
        paddingTop: '3px',
        paddingBottom: '4px',
        textTransform: 'capitalize'
      }
    },
    'disableAlpha': {
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: 'rgb'
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }

      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement(
      'div',
      { style: styles.double },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'hex',
        value: hex.replace('#', ''),
        onChange: handleChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'r',
        value: rgb.r,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'g',
        value: rgb.g,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'b',
        value: rgb.b,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.alpha },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'a',
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '100'
      })
    )
  );
};

exports.default = SketchFields;

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SketchPresetColors = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SketchPresetColors = exports.SketchPresetColors = function SketchPresetColors(_ref) {
  var colors = _ref.colors,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0, _reactcss2.default)({
    'default': {
      colors: {
        margin: '0 -10px',
        padding: '10px 0 0 10px',
        borderTop: '1px solid #eee',
        display: 'flex',
        flexWrap: 'wrap',
        position: 'relative'
      },
      swatchWrap: {
        width: '16px',
        height: '16px',
        margin: '0 10px 10px 0'
      },
      swatch: {
        borderRadius: '3px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
      }
    },
    'no-presets': {
      colors: {
        display: 'none'
      }
    }
  }, {
    'no-presets': !colors || !colors.length
  });

  var handleClick = function handleClick(hex, e) {
    onClick({
      hex: hex,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.colors, className: 'flexbox-fix' },
    colors.map(function (colorObjOrString) {
      var c = typeof colorObjOrString === 'string' ? { color: colorObjOrString } : colorObjOrString;
      var key = '' + c.color + (c.title || '');
      return _react2.default.createElement(
        'div',
        { key: key, style: styles.swatchWrap },
        _react2.default.createElement(_common.Swatch, _extends({}, c, {
          style: styles.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ' + c.color
          }
        }))
      );
    })
  );
};

SketchPresetColors.propTypes = {
  colors: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
    color: _propTypes2.default.string,
    title: _propTypes2.default.string
  })])).isRequired
};

exports.default = SketchPresetColors;

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slider = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _common = __webpack_require__(8);

var _SliderSwatches = __webpack_require__(491);

var _SliderSwatches2 = _interopRequireDefault(_SliderSwatches);

var _SliderPointer = __webpack_require__(493);

var _SliderPointer2 = _interopRequireDefault(_SliderPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slider = exports.Slider = function Slider(_ref) {
  var hsl = _ref.hsl,
      onChange = _ref.onChange,
      pointer = _ref.pointer,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      hue: {
        height: '12px',
        position: 'relative'
      },
      Hue: {
        radius: '2px'
      }
    }
  }, passedStyles));

  return _react2.default.createElement(
    'div',
    { style: styles.wrap || {}, className: 'slider-picker ' + className },
    _react2.default.createElement(
      'div',
      { style: styles.hue },
      _react2.default.createElement(_common.Hue, {
        style: styles.Hue,
        hsl: hsl,
        pointer: pointer,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement(_SliderSwatches2.default, { hsl: hsl, onClick: onChange })
    )
  );
};

Slider.propTypes = {
  styles: _propTypes2.default.object
};
Slider.defaultProps = {
  pointer: _SliderPointer2.default,
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Slider);

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _SliderSwatch = __webpack_require__(492);

var _SliderSwatch2 = _interopRequireDefault(_SliderSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatches = exports.SliderSwatches = function SliderSwatches(_ref) {
  var onClick = _ref.onClick,
      hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginTop: '20px'
      },
      swatch: {
        boxSizing: 'border-box',
        width: '20%',
        paddingRight: '1px',
        float: 'left'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  // Acceptible difference in floating point equality
  var epsilon = 0.1;

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.80',
        active: Math.abs(hsl.l - 0.80) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick,
        first: true
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.65',
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.50',
        active: Math.abs(hsl.l - 0.50) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.35',
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.20',
        active: Math.abs(hsl.l - 0.20) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick,
        last: true
      })
    ),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = SliderSwatches;

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatch = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatch = exports.SliderSwatch = function SliderSwatch(_ref) {
  var hsl = _ref.hsl,
      offset = _ref.offset,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      active = _ref.active,
      first = _ref.first,
      last = _ref.last;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        height: '12px',
        background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
        cursor: 'pointer'
      }
    },
    'first': {
      swatch: {
        borderRadius: '2px 0 0 2px'
      }
    },
    'last': {
      swatch: {
        borderRadius: '0 2px 2px 0'
      }
    },
    'active': {
      swatch: {
        transform: 'scaleY(1.8)',
        borderRadius: '3.6px/2px'
      }
    }
  }, { active: active, first: first, last: last });

  var handleClick = function handleClick(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset,
      source: 'hsl'
    }, e);
  };

  return _react2.default.createElement('div', { style: styles.swatch, onClick: handleClick });
};

exports.default = SliderSwatch;

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '14px',
        height: '14px',
        borderRadius: '6px',
        transform: 'translate(-7px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatches = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _materialColors = __webpack_require__(218);

var material = _interopRequireWildcard(_materialColors);

var _common = __webpack_require__(8);

var _SwatchesGroup = __webpack_require__(495);

var _SwatchesGroup2 = _interopRequireDefault(_SwatchesGroup);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Swatches = exports.Swatches = function Swatches(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      picker: {
        width: width,
        height: height
      },
      overflow: {
        height: height,
        overflowY: 'scroll'
      },
      body: {
        padding: '16px 0 6px 16px'
      },
      clear: {
        clear: 'both'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    return onChange({ hex: data, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'swatches-picker ' + className },
    _react2.default.createElement(
      _common.Raised,
      null,
      _react2.default.createElement(
        'div',
        { style: styles.overflow },
        _react2.default.createElement(
          'div',
          { style: styles.body },
          (0, _map2.default)(colors, function (group) {
            return _react2.default.createElement(_SwatchesGroup2.default, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }),
          _react2.default.createElement('div', { style: styles.clear })
        )
      )
    )
  );
};

Swatches.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.arrayOf(_propTypes2.default.string)),
  styles: _propTypes2.default.object

  /* eslint-disable max-len */
};Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[material.red['900'], material.red['700'], material.red['500'], material.red['300'], material.red['100']], [material.pink['900'], material.pink['700'], material.pink['500'], material.pink['300'], material.pink['100']], [material.purple['900'], material.purple['700'], material.purple['500'], material.purple['300'], material.purple['100']], [material.deepPurple['900'], material.deepPurple['700'], material.deepPurple['500'], material.deepPurple['300'], material.deepPurple['100']], [material.indigo['900'], material.indigo['700'], material.indigo['500'], material.indigo['300'], material.indigo['100']], [material.blue['900'], material.blue['700'], material.blue['500'], material.blue['300'], material.blue['100']], [material.lightBlue['900'], material.lightBlue['700'], material.lightBlue['500'], material.lightBlue['300'], material.lightBlue['100']], [material.cyan['900'], material.cyan['700'], material.cyan['500'], material.cyan['300'], material.cyan['100']], [material.teal['900'], material.teal['700'], material.teal['500'], material.teal['300'], material.teal['100']], ['#194D33', material.green['700'], material.green['500'], material.green['300'], material.green['100']], [material.lightGreen['900'], material.lightGreen['700'], material.lightGreen['500'], material.lightGreen['300'], material.lightGreen['100']], [material.lime['900'], material.lime['700'], material.lime['500'], material.lime['300'], material.lime['100']], [material.yellow['900'], material.yellow['700'], material.yellow['500'], material.yellow['300'], material.yellow['100']], [material.amber['900'], material.amber['700'], material.amber['500'], material.amber['300'], material.amber['100']], [material.orange['900'], material.orange['700'], material.orange['500'], material.orange['300'], material.orange['100']], [material.deepOrange['900'], material.deepOrange['700'], material.deepOrange['500'], material.deepOrange['300'], material.deepOrange['100']], [material.brown['900'], material.brown['700'], material.brown['500'], material.brown['300'], material.brown['100']], [material.blueGrey['900'], material.blueGrey['700'], material.blueGrey['500'], material.blueGrey['300'], material.blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']],
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Swatches);

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesGroup = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _SwatchesColor = __webpack_require__(496);

var _SwatchesColor2 = _interopRequireDefault(_SwatchesColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesGroup = exports.SwatchesGroup = function SwatchesGroup(_ref) {
  var onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      group = _ref.group,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      group: {
        paddingBottom: '10px',
        width: '40px',
        float: 'left',
        marginRight: '10px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.group },
    (0, _map2.default)(group, function (color, i) {
      return _react2.default.createElement(_SwatchesColor2.default, {
        key: color,
        color: color,
        active: color.toLowerCase() === active,
        first: i === 0,
        last: i === group.length - 1,
        onClick: onClick,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

exports.default = SwatchesGroup;

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesColor = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

var _CheckIcon = __webpack_require__(497);

var _CheckIcon2 = _interopRequireDefault(_CheckIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesColor = exports.SwatchesColor = function SwatchesColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      first = _ref.first,
      last = _ref.last,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        width: '40px',
        height: '24px',
        cursor: 'pointer',
        background: color,
        marginBottom: '1px'
      },
      check: {
        color: _color2.default.getContrastingColor(color),
        marginLeft: '8px',
        display: 'none'
      }
    },
    'first': {
      color: {
        overflow: 'hidden',
        borderRadius: '2px 2px 0 0'
      }
    },
    'last': {
      color: {
        overflow: 'hidden',
        borderRadius: '0 0 2px 2px'
      }
    },
    'active': {
      check: {
        display: 'block'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      check: {
        color: '#333'
      }
    },
    'transparent': {
      check: {
        color: '#333'
      }
    }
  }, {
    first: first,
    last: last,
    active: active,
    'color-#FFFFFF': color === '#FFFFFF',
    'transparent': color === 'transparent'
  });

  return _react2.default.createElement(
    _common.Swatch,
    {
      color: color,
      style: styles.color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    _react2.default.createElement(
      'div',
      { style: styles.check },
      _react2.default.createElement(_CheckIcon2.default, null)
    )
  );
};

exports.default = SwatchesColor;

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var DEFAULT_SIZE = 24;

exports.default = function (_ref) {
  var _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
      _ref$width = _ref.width,
      width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? {} : _ref$style,
      props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);

  return _react2.default.createElement(
    'svg',
    _extends({
      viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
      style: _extends({ fill: fill, width: width, height: height }, style)
    }, props),
    _react2.default.createElement('path', { d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z' })
  );
};

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Twitter = undefined;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactcss = __webpack_require__(2);

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = __webpack_require__(34);

var _map2 = _interopRequireDefault(_map);

var _merge = __webpack_require__(17);

var _merge2 = _interopRequireDefault(_merge);

var _color = __webpack_require__(26);

var _color2 = _interopRequireDefault(_color);

var _common = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Twitter = exports.Twitter = function Twitter(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0, _reactcss2.default)((0, _merge2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '0 solid rgba(0,0,0,0.25)',
        boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
        borderRadius: '4px',
        position: 'relative'
      },
      body: {
        padding: '15px 9px 9px 15px'
      },
      label: {
        fontSize: '18px',
        color: '#fff'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent #fff transparent',
        position: 'absolute'
      },
      triangleShadow: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
        position: 'absolute'
      },
      hash: {
        background: '#F0F0F0',
        height: '30px',
        width: '30px',
        borderRadius: '4px 0 0 4px',
        float: 'left',
        color: '#98A1A4',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      input: {
        width: '100px',
        fontSize: '14px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '28px',
        boxShadow: 'inset 0 0 0 1px #F0F0F0',
        boxSizing: 'content-box',
        borderRadius: '0 4px 4px 0',
        float: 'left',
        paddingLeft: '8px'
      },
      swatch: {
        width: '30px',
        height: '30px',
        float: 'left',
        borderRadius: '4px',
        margin: '0 6px 6px 0'
      },
      clear: {
        clear: 'both'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-10px',
        left: '12px'
      },
      triangleShadow: {
        top: '-11px',
        left: '12px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-10px',
        right: '12px'
      },
      triangleShadow: {
        top: '-11px',
        right: '12px'
      }
    }
  }, passedStyles), {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right'
  });

  var handleChange = function handleChange(hexcode, e) {
    _color2.default.isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'twitter-picker ' + className },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      (0, _map2.default)(colors, function (c, i) {
        return _react2.default.createElement(_common.Swatch, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: '0 0 4px ' + c
          }
        });
      }),
      _react2.default.createElement(
        'div',
        { style: styles.hash },
        '#'
      ),
      _react2.default.createElement(_common.EditableInput, {
        label: null,
        style: { input: styles.input },
        value: hex.replace('#', ''),
        onChange: handleChange
      }),
      _react2.default.createElement('div', { style: styles.clear })
    )
  );
};

Twitter.propTypes = {
  width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  triangle: _propTypes2.default.oneOf(['hide', 'top-left', 'top-right']),
  colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
  styles: _propTypes2.default.object
};

Twitter.defaultProps = {
  width: 276,
  colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
  triangle: 'top-left',
  styles: {}
};

exports.default = (0, _common.ColorWrap)(Twitter);

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    /************************************
        Variables
    ************************************/

    var numeral,
        _,
        VERSION = '2.0.6',
        formats = {},
        locales = {},
        defaults = {
            currentLocale: 'en',
            zeroFormat: null,
            nullFormat: null,
            defaultFormat: '0,0',
            scalePercentBy100: true
        },
        options = {
            currentLocale: defaults.currentLocale,
            zeroFormat: defaults.zeroFormat,
            nullFormat: defaults.nullFormat,
            defaultFormat: defaults.defaultFormat,
            scalePercentBy100: defaults.scalePercentBy100
        };


    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(input, number) {
        this._input = input;

        this._value = number;
    }

    numeral = function(input) {
        var value,
            kind,
            unformatFunction,
            regexp;

        if (numeral.isNumeral(input)) {
            value = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            value = 0;
        } else if (input === null || _.isNaN(input)) {
            value = null;
        } else if (typeof input === 'string') {
            if (options.zeroFormat && input === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                for (kind in formats) {
                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

                    if (regexp && input.match(regexp)) {
                        unformatFunction = formats[kind].unformat;

                        break;
                    }
                }

                unformatFunction = unformatFunction || numeral._.stringToNumber;

                value = unformatFunction(input);
            }
        } else {
            value = Number(input)|| null;
        }

        return new Numeral(input, value);
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function(obj) {
        return obj instanceof Numeral;
    };

    // helper functions
    numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format, roundingFunction) {
            var locale = locales[numeral.options.currentLocale],
                negP = false,
                optDec = false,
                leadingCount = 0,
                abbr = '',
                trillion = 1000000000000,
                billion = 1000000000,
                million = 1000000,
                thousand = 1000,
                decimal = '',
                neg = false,
                abbrForce, // force abbreviation
                abs,
                min,
                max,
                power,
                int,
                precision,
                signed,
                thousands,
                output;

            // make sure we never format a null value
            value = value || 0;

            abs = Math.abs(value);

            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (numeral._.includes(format, '(')) {
                negP = true;
                format = format.replace(/[\(|\)]/g, '');
            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
                format = format.replace(/[\+|\-]/g, '');
            }

            // see if abbreviation is wanted
            if (numeral._.includes(format, 'a')) {
                abbrForce = format.match(/a(k|m|b|t)?/);

                abbrForce = abbrForce ? abbrForce[1] : false;

                // check for space before abbreviation
                if (numeral._.includes(format, ' a')) {
                    abbr = ' ';
                }

                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

                if (abs >= trillion && !abbrForce || abbrForce === 't') {
                    // trillion
                    abbr += locale.abbreviations.trillion;
                    value = value / trillion;
                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
                    // billion
                    abbr += locale.abbreviations.billion;
                    value = value / billion;
                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
                    // million
                    abbr += locale.abbreviations.million;
                    value = value / million;
                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
                    // thousand
                    abbr += locale.abbreviations.thousand;
                    value = value / thousand;
                }
            }

            // check for optional decimals
            if (numeral._.includes(format, '[.]')) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            // break number and format
            int = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');
            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

            if (precision) {
                if (numeral._.includes(precision, '[')) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
                }

                int = decimal.split('.')[0];

                if (numeral._.includes(decimal, '.')) {
                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
                } else {
                    decimal = '';
                }

                if (optDec && Number(decimal.slice(1)) === 0) {
                    decimal = '';
                }
            } else {
                int = numeral._.toFixed(value, 0, roundingFunction);
            }

            // check abbreviation again after rounding
            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
                int = String(Number(int) / 1000);

                switch (abbr) {
                    case locale.abbreviations.thousand:
                        abbr = locale.abbreviations.million;
                        break;
                    case locale.abbreviations.million:
                        abbr = locale.abbreviations.billion;
                        break;
                    case locale.abbreviations.billion:
                        abbr = locale.abbreviations.trillion;
                        break;
                }
            }


            // format number
            if (numeral._.includes(int, '-')) {
                int = int.slice(1);
                neg = true;
            }

            if (int.length < leadingCount) {
                for (var i = leadingCount - int.length; i > 0; i--) {
                    int = '0' + int;
                }
            }

            if (thousands > -1) {
                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                int = '';
            }

            output = int + decimal + (abbr ? abbr : '');

            if (negP) {
                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
            } else {
                if (signed >= 0) {
                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
                } else if (neg) {
                    output = '-' + output;
                }
            }

            return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
            var locale = locales[options.currentLocale],
                stringOriginal = string,
                abbreviations = {
                    thousand: 3,
                    million: 6,
                    billion: 9,
                    trillion: 12
                },
                abbreviation,
                value,
                i,
                regexp;

            if (options.zeroFormat && string === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                value = 1;

                if (locale.delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
                }

                for (abbreviation in abbreviations) {
                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

                    if (stringOriginal.match(regexp)) {
                        value *= Math.pow(10, abbreviations[abbreviation]);
                        break;
                    }
                }

                // check for negative number
                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

                // remove non numbers
                string = string.replace(/[^0-9\.]+/g, '');

                value *= Number(string);
            }

            return value;
        },
        isNaN: function(value) {
            return typeof value === 'number' && isNaN(value);
        },
        includes: function(string, search) {
            return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            var t = Object(array),
                len = t.length >>> 0,
                k = 0,
                value;

            if (arguments.length === 3) {
                value = arguments[2];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }

                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }

                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function (x) {
            var parts = x.toString().split('.');

            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function () {
            var args = Array.prototype.slice.call(arguments);

            return args.reduce(function(accum, next) {
                var mn = _.multiplier(next);
                return accum > mn ? accum : mn;
            }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split('.'),
                minDecimals = maxDecimals - (optionals || 0),
                boundedPrecision,
                optionalsRegExp,
                power,
                output;

            // Use the smallest precision value possible to avoid errors from floating point representation
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }

            power = Math.pow(10, boundedPrecision);

            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

            if (optionals > maxDecimals - boundedPrecision) {
                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
                output = output.replace(optionalsRegExp, '');
            }

            return output;
        }
    };

    // avaliable options
    numeral.options = options;

    // avaliable formats
    numeral.formats = formats;

    // avaliable formats
    numeral.locales = locales;

    // This function sets the current locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    numeral.locale = function(key) {
        if (key) {
            options.currentLocale = key.toLowerCase();
        }

        return options.currentLocale;
    };

    // This function provides access to the loaded locale data.  If
    // no arguments are passed in, it will simply return the current
    // global locale object.
    numeral.localeData = function(key) {
        if (!key) {
            return locales[options.currentLocale];
        }

        key = key.toLowerCase();

        if (!locales[key]) {
            throw new Error('Unknown locale : ' + key);
        }

        return locales[key];
    };

    numeral.reset = function() {
        for (var property in defaults) {
            options[property] = defaults[property];
        }
    };

    numeral.zeroFormat = function(format) {
        options.zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.nullFormat = function (format) {
        options.nullFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function(format) {
        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    numeral.register = function(type, name, format) {
        name = name.toLowerCase();

        if (this[type + 's'][name]) {
            throw new TypeError(name + ' ' + type + ' already registered.');
        }

        this[type + 's'][name] = format;

        return format;
    };


    numeral.validate = function(val, culture) {
        var _decimalSep,
            _thousandSep,
            _currSymbol,
            _valArray,
            _abbrObj,
            _thousandRegEx,
            localeData,
            temp;

        //coerce val to string
        if (typeof val !== 'string') {
            val += '';

            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }

        //trim whitespaces from either sides
        val = val.trim();

        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }

        //if val is empty return false
        if (val === '') {
            return false;
        }

        //get the decimal and thousands separator from numeral.localeData
        try {
            //check if the culture is understood by numeral. if not, default it to current locale
            localeData = numeral.localeData(culture);
        } catch (e) {
            localeData = numeral.localeData(numeral.locale());
        }

        //setup the delimiters and currency symbol based on culture/locale
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = localeData.delimiters.thousands;
        }

        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }

        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }

        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
                } else {
                    if (_valArray[0].length === 1) {
                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else {
                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    }
                }
            }
        }

        return false;
    };


    /************************************
        Numeral Prototype
    ************************************/

    numeral.fn = Numeral.prototype = {
        clone: function() {
            return numeral(this);
        },
        format: function(inputString, roundingFunction) {
            var value = this._value,
                format = inputString || options.defaultFormat,
                kind,
                output,
                formatFunction;

            // make sure we have a roundingFunction
            roundingFunction = roundingFunction || Math.round;

            // format based on value
            if (value === 0 && options.zeroFormat !== null) {
                output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
                output = options.nullFormat;
            } else {
                for (kind in formats) {
                    if (format.match(formats[kind].regexps.format)) {
                        formatFunction = formats[kind].format;

                        break;
                    }
                }

                formatFunction = formatFunction || numeral._.numberToFormat;

                output = formatFunction(value, format, roundingFunction);
            }

            return output;
        },
        value: function() {
            return this._value;
        },
        input: function() {
            return this._input;
        },
        set: function(value) {
            this._value = Number(value);

            return this;
        },
        add: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum + Math.round(corrFactor * curr);
            }

            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

            return this;
        },
        subtract: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum - Math.round(corrFactor * curr);
            }

            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

            return this;
        },
        multiply: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback, 1);

            return this;
        },
        divide: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback);

            return this;
        },
        difference: function(value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }
    };

    /************************************
        Default Locale && Format
    ************************************/

    numeral.register('locale', 'en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function(number) {
            var b = number % 10;
            return (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    

(function() {
        numeral.register('format', 'bps', {
            regexps: {
                format: /(BPS)/,
                unformat: /(BPS)/
            },
            format: function(value, format, roundingFunction) {
                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
                    output;

                value = value * 10000;

                // check for space before BPS
                format = format.replace(/\s?BPS/, '');

                output = numeral._.numberToFormat(value, format, roundingFunction);

                if (numeral._.includes(output, ')')) {
                    output = output.split('');

                    output.splice(-1, 0, space + 'BPS');

                    output = output.join('');
                } else {
                    output = output + space + 'BPS';
                }

                return output;
            },
            unformat: function(string) {
                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
            }
        });
})();


(function() {
        var decimal = {
            base: 1000,
            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        },
        binary = {
            base: 1024,
            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };

    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
            return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|');
        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

    numeral.register('format', 'bytes', {
        regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
        },
        format: function(value, format, roundingFunction) {
            var output,
                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
                power,
                min,
                max;

            // check for space before
            format = format.replace(/\s?i?b/, '');

            for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);

                if (value === null || value === 0 || value >= min && value < max) {
                    suffix += bytes.suffixes[power];

                    if (min > 0) {
                        value = value / min;
                    }

                    break;
                }
            }

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + suffix;
        },
        unformat: function(string) {
            var value = numeral._.stringToNumber(string),
                power,
                bytesMultiplier;

            if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                    if (numeral._.includes(string, decimal.suffixes[power])) {
                        bytesMultiplier = Math.pow(decimal.base, power);

                        break;
                    }

                    if (numeral._.includes(string, binary.suffixes[power])) {
                        bytesMultiplier = Math.pow(binary.base, power);

                        break;
                    }
                }

                value *= (bytesMultiplier || 1);
            }

            return value;
        }
    });
})();


(function() {
        numeral.register('format', 'currency', {
        regexps: {
            format: /(\$)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                symbols = {
                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                },
                output,
                symbol,
                i;

            // strip format of spaces and $
            format = format.replace(/\s?\$\s?/, '');

            // format the number
            output = numeral._.numberToFormat(value, format, roundingFunction);

            // update the before and after based on value
            if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, '');
                symbols.after = symbols.after.replace(/[\-\)]/, '');
            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                symbols.before = '-' + symbols.before;
            }

            // loop through each before symbol
            for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];

                switch (symbol) {
                    case '$':
                        output = numeral._.insert(output, locale.currency.symbol, i);
                        break;
                    case ' ':
                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                        break;
                }
            }

            // loop through each after symbol
            for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];

                switch (symbol) {
                    case '$':
                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                        break;
                    case ' ':
                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                        break;
                }
            }


            return output;
        }
    });
})();


(function() {
        numeral.register('format', 'exponential', {
        regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
        },
        format: function(value, format, roundingFunction) {
            var output,
                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
                parts = exponential.split('e');

            format = format.replace(/e[\+|\-]{1}0/, '');

            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

            return output + 'e' + parts[1];
        },
        unformat: function(string) {
            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
                value = Number(parts[0]),
                power = Number(parts[1]);

            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

            function cback(accum, curr, currI, O) {
                var corrFactor = numeral._.correctionFactor(accum, curr),
                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
            }

            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
        }
    });
})();


(function() {
        numeral.register('format', 'ordinal', {
        regexps: {
            format: /(o)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                output,
                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

            // check for space before
            format = format.replace(/\s?o/, '');

            ordinal += locale.ordinal(value);

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + ordinal;
        }
    });
})();


(function() {
        numeral.register('format', 'percentage', {
        regexps: {
            format: /(%)/,
            unformat: /(%)/
        },
        format: function(value, format, roundingFunction) {
            var space = numeral._.includes(format, ' %') ? ' ' : '',
                output;

            if (numeral.options.scalePercentBy100) {
                value = value * 100;
            }

            // check for space before %
            format = format.replace(/\s?\%/, '');

            output = numeral._.numberToFormat(value, format, roundingFunction);

            if (numeral._.includes(output, ')')) {
                output = output.split('');

                output.splice(-1, 0, space + '%');

                output = output.join('');
            } else {
                output = output + space + '%';
            }

            return output;
        },
        unformat: function(string) {
            var number = numeral._.stringToNumber(string);
            if (numeral.options.scalePercentBy100) {
                return number * 0.01;
            }
            return number;
        }
    });
})();


(function() {
        numeral.register('format', 'time', {
        regexps: {
            format: /(:)/,
            unformat: /(:)/
        },
        format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60),
                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        },
        unformat: function(string) {
            var timeArray = string.split(':'),
                seconds = 0;

            // turn hours and minutes into seconds and add them all up
            if (timeArray.length === 3) {
                // hours
                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
                // minutes
                seconds = seconds + (Number(timeArray[1]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
                // minutes
                seconds = seconds + (Number(timeArray[0]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
        }
    });
})();

return numeral;
}));


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticBarChart = void 0;
const React = __importStar(__webpack_require__(0));
const HTMLLegend_1 = __importDefault(__webpack_require__(72));
const tooltip_content_1 = __importStar(__webpack_require__(44));
const utilities_1 = __webpack_require__(77);
const shared_1 = __webpack_require__(219);
exports.semioticBarChart = (data, schema, options, colorHashOverride, colorDimOverride) => {
    const { selectedDimensions, chart, colors, setColor, barGrouping } = options;
    const { dim1, metric1, metric3, metric4 } = chart;
    const oAccessor = selectedDimensions.length === 0
        ? dim1
        : (datapoint) => selectedDimensions
            .map(selectedDim => datapoint[selectedDim])
            .join(",");
    const rAccessor = metric1;
    const additionalSettings = {};
    const colorHash = colorHashOverride || { Other: "grey" };
    const sortedData = shared_1.sortByOrdinalRange(oAccessor, (metric3 !== "none" && metric3) || rAccessor, dim1, data);
    if (metric3 && metric3 !== "none") {
        additionalSettings.dynamicColumnWidth = metric3;
    }
    let errorBarAnnotations;
    if (barGrouping === "Clustered" && metric4 && metric4 !== "none") {
        additionalSettings.rExtent = [
            Math.min(...data.map(d => d[metric1] - d[metric4])),
            Math.max(...data.map(d => d[metric1] + d[metric4]))
        ];
        errorBarAnnotations = (d, i, xy) => {
            const errorBarSize = Math.abs(xy.rScale(d[metric1]) - xy.rScale(d[metric1] + d[metric4]));
            return (React.createElement("g", null,
                React.createElement("rect", { width: xy.width, height: xy.height, style: xy.styleFn(d) }),
                React.createElement("g", { transform: `translate(${xy.width / 2},${d.negative ? xy.height : 0})`, stroke: "#333", strokeWidth: "1", opacity: "0.75" },
                    React.createElement("line", { y1: -errorBarSize, y2: -errorBarSize, x1: Math.min(0, -xy.width / 2 + 2), x2: Math.max(0, xy.width / 2 - 2) }),
                    React.createElement("line", { x1: 0, x2: 0, y1: -errorBarSize, y2: errorBarSize }),
                    React.createElement("line", { y1: errorBarSize, y2: errorBarSize, x1: Math.min(0, -xy.width / 2 + 2), x2: Math.max(0, xy.width / 2 - 2) }))));
        };
    }
    const uniqueValues = sortedData.reduce((uniques, datapoint) => !uniques.find((uniqueDimName) => uniqueDimName === datapoint[dim1].toString())
        ? [...uniques, datapoint[dim1].toString()]
        : uniques, []);
    if (!colorHashOverride && dim1 && dim1 !== "none") {
        uniqueValues.forEach((value, index) => {
            // Color the first 18 values after that everything gets grey because more than 18 colors is unreadable no matter what you want
            colorHash[value] = index > 18 ? "grey" : colors[index % colors.length];
        });
        additionalSettings.afterElements = (React.createElement(HTMLLegend_1.default, { valueHash: {}, colorHash: colorHash, setColor: setColor, colors: colors }));
        if (barGrouping === "Clustered" ||
            (selectedDimensions.length > 0 && selectedDimensions.join(",") !== dim1)) {
            additionalSettings.pieceHoverAnnotation = true;
            additionalSettings.tooltipContent = hoveredDatapoint => {
                return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
                    React.createElement("div", { style: { display: "flex", flexWrap: "wrap" } },
                        React.createElement("div", null, options.dimensions.map((dim, index) => {
                            return (React.createElement("div", { style: {
                                    margin: "2px 5px 0",
                                    display: "inline-block",
                                    minWidth: "100px"
                                }, key: `dim-${index}` },
                                React.createElement("span", { style: { fontWeight: 600 } }, dim.name),
                                ":",
                                " ",
                                tooltip_content_1.safeDisplayValue(hoveredDatapoint[dim.name])));
                        })),
                        React.createElement("div", null, options.metrics.map((dim, index) => (React.createElement("div", { style: {
                                margin: "2px 5px 0",
                                display: "inline-block",
                                minWidth: "100px"
                            }, key: `dim-${index}` },
                            React.createElement("span", { style: { fontWeight: 600 } }, dim.name),
                            ":",
                            " ",
                            tooltip_content_1.safeDisplayValue(hoveredDatapoint[dim.name]))))))));
            };
        }
    }
    const barSettings = Object.assign({ type: barGrouping === "Clustered"
            ? { type: "clusterbar", customMark: errorBarAnnotations }
            : { type: "bar", customMark: errorBarAnnotations }, data: sortedData, oAccessor,
        rAccessor, style: (datapoint) => ({
            fill: colorHash[datapoint[colorDimOverride || dim1]] || colors[0],
            stroke: colorHash[datapoint[colorDimOverride || dim1]] || colors[0]
        }), oPadding: uniqueValues.length > 30 ? 1 : 5, oLabel: uniqueValues.length > 30
            ? false
            : (columnLabel) => {
                return React.createElement("text", { transform: "rotate(90)" }, columnLabel);
            }, hoverAnnotation: true, margin: { top: 10, right: 10, bottom: 100, left: 70 }, axes: [
            {
                orient: "left",
                label: rAccessor,
                tickFormat: utilities_1.numeralFormatting
            }
        ], tooltipContent: (hoveredDatapoint) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.column.xyData[0].xy.x, y: hoveredDatapoint.column.xyData[0].xy.y },
                React.createElement("p", null, typeof oAccessor === "function"
                    ? oAccessor(hoveredDatapoint.pieces[0])
                    : hoveredDatapoint.pieces[0][oAccessor]),
                React.createElement("p", null,
                    rAccessor,
                    ":",
                    " ",
                    hoveredDatapoint.pieces
                        .map((piece) => piece[rAccessor])
                        .reduce((total, value) => total + value, 0)),
                metric3 && metric3 !== "none" && (React.createElement("p", null,
                    metric3,
                    ":",
                    " ",
                    hoveredDatapoint.pieces
                        .map((piece) => piece[metric3])
                        .reduce((total, value) => total + value, 0)))));
        }, baseMarkProps: { forceUpdate: true }, size: [500, 600] }, additionalSettings);
    return { frameSettings: barSettings, colorDim: dim1, colorHash };
};


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticHierarchicalChart = void 0;
const d3_collection_1 = __webpack_require__(27);
const d3_interpolate_1 = __webpack_require__(12);
const React = __importStar(__webpack_require__(0));
const tooltip_content_1 = __importDefault(__webpack_require__(44));
const overrideFrameHover = (hierarchyType) => (annotation) => {
    const { d } = annotation;
    if (d.type === "frame-hover" && hierarchyType !== "treemap") {
        return;
    }
    return null;
};
const hierarchicalAnnotation = (hierarchyType, selectedDimensions, metric) => (annotation) => {
    const { d, networkFrameState, nodes: drawnNodes } = annotation;
    const { type, parent } = d;
    const { networkFrameRender } = networkFrameState;
    if (hierarchyType !== "treemap" && parent && type === "highlight") {
        const { nodes } = networkFrameRender;
        const { customMark, styleFn: baseStyle } = nodes;
        const ancestors = parent.ancestors();
        const parentPlusPieces = [parent, ...ancestors];
        const drawnPieces = parentPlusPieces.map(d => drawnNodes.find((p) => (p.depth === 0 && d.depth === 0) ||
            p.hierarchicalID === d.hierarchicalID));
        const allPieces = [d, ...drawnPieces];
        const baseMarkProps = { forceUpdate: true };
        const ancestorHighlight = allPieces.map((node, nodei) => {
            const transform = `translate(${node.x},${node.y})`;
            const styleFn = (d) => (Object.assign(Object.assign({}, baseStyle(d)), { fill: "red", opacity: 0.5, stroke: "red", strokeWidth: "4px" }));
            const customNode = customMark({
                d: node,
                styleFn,
                transform: transform,
                baseMarkProps,
                key: `highlight-${nodei}-parent`
            });
            const thisLevelName = selectedDimensions[node.depth - 1];
            return (React.createElement("g", null,
                customNode,
                React.createElement("text", { transform: transform },
                    thisLevelName && `${thisLevelName}: ${node.key}`,
                    node.depth !== 0 && node[metric] && `${metric}: ${node[metric]}`)));
        });
        return React.createElement("g", null, ancestorHighlight);
    }
    return null;
};
const parentPath = (datapoint, pathArray) => {
    if (datapoint.parent) {
        pathArray = parentPath(datapoint.parent, [datapoint.key, ...pathArray]);
    }
    else {
        pathArray = [...pathArray];
    }
    return pathArray;
};
const hierarchicalTooltip = (datapoint, primaryKey, metric, selectedDimensions) => {
    const pathString = datapoint.parent
        ? parentPath(datapoint.parent, (datapoint.key && [datapoint.key]) || []).map((d, i) => (React.createElement("p", null,
            selectedDimensions[i],
            ": ",
            d)))
        : "";
    const content = [];
    if (!datapoint.parent) {
        content.push(React.createElement("h2", { key: "hierarchy-title" }, "Root"));
    }
    else if (datapoint.key) {
        content.push(React.createElement("h2", { key: "hierarchy-title" }, datapoint.key));
        content.push(React.createElement("p", { key: "path-string" }, pathString));
        content.push(React.createElement("p", { key: "hierarchy-value" },
            "Total Value: ",
            datapoint.value));
        content.push(React.createElement("p", { key: "hierarchy-children" },
            "Children: ",
            datapoint.children.length));
    }
    else {
        content.push(pathString, React.createElement("p", { key: "leaf-label" }, primaryKey.map((pkey) => datapoint[pkey]).join(", ")));
        content.push(React.createElement("p", { key: "hierarchy-value" },
            metric,
            ": ",
            datapoint[metric]));
    }
    return content;
};
const hierarchicalColor = (colorHash, datapoint) => {
    if (datapoint.depth === 0) {
        return "white";
    }
    if (datapoint.depth === 1) {
        return colorHash[datapoint.key];
    }
    let colorNode = datapoint;
    for (let x = datapoint.depth; x > 1; x--) {
        colorNode = colorNode.parent;
    }
    const lightenScale = d3_interpolate_1.interpolateLab("white", colorHash[colorNode.key]);
    return lightenScale(Math.max(0, datapoint.depth / 6));
};
exports.semioticHierarchicalChart = (data, schema, options, colorHashOverride, colorDimOverride) => {
    const { hierarchyType: baseHierarchyType = "dendrogram", chart, selectedDimensions, primaryKey, colors } = options;
    const { metric1 } = chart;
    // a sunburst is just a radial partition
    const hierarchyType = baseHierarchyType === "sunburst" ? "partition" : baseHierarchyType;
    if (selectedDimensions.length === 0) {
        return {};
    }
    const nestingParams = d3_collection_1.nest();
    selectedDimensions.forEach((dim) => {
        nestingParams.key((param) => param[dim]);
    });
    const colorHash = colorHashOverride || {};
    const sanitizedData = [];
    data.forEach((datapoint) => {
        if (!colorDimOverride && !colorHash[datapoint[selectedDimensions[0]]]) {
            colorHash[datapoint[selectedDimensions[0]]] =
                colors[Object.keys(colorHash).length];
        }
        sanitizedData.push(Object.assign(Object.assign({}, datapoint), { sanitizedR: datapoint.r, r: undefined }));
    });
    const entries = nestingParams.entries(sanitizedData.sort((a, b) => a[metric1] - b[metric1]));
    const rootNode = { id: "all", values: entries };
    const hierarchySettings = {
        edges: rootNode,
        edgeStyle: () => ({ fill: "lightgray", stroke: "gray" }),
        nodeStyle: (node) => {
            return {
                fill: hierarchicalColor(colorHash, node),
                stroke: node.depth === 1 ? "white" : "black",
                strokeOpacity: node.depth * 0.1 + 0.2
            };
        },
        networkType: {
            type: hierarchyType,
            projection: baseHierarchyType === "sunburst" && "radial",
            hierarchySum: (node) => node[metric1],
            hierarchyChildren: (node) => node.values,
            padding: hierarchyType === "treemap" ? 3 : 0,
            zoom: false
        },
        edgeRenderKey: (edge, index) => {
            return index;
        },
        nodeIDAccessor: (d, i) => d.id || d.key || i,
        baseMarkProps: { forceUpdate: true },
        margin: { left: 10, right: 10, top: 10, bottom: 10 },
        hoverAnnotation: [
            { type: "frame-hover" },
            {
                type: "highlight",
                style: {
                    stroke: "red",
                    strokeOpacity: 0.5,
                    strokeWidth: 5,
                    fill: "none"
                }
            }
        ],
        svgAnnotationRules: hierarchicalAnnotation(hierarchyType, selectedDimensions, metric1),
        htmlAnnotationRules: overrideFrameHover(hierarchyType),
        tooltipContent: (hoveredDatapoint) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y }, hierarchicalTooltip(hoveredDatapoint, primaryKey, metric1, selectedDimensions)));
        }
    };
    return {
        frameSettings: hierarchySettings,
        colorDim: selectedDimensions[0],
        colorHash
    };
};


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticLineChart = void 0;
const d3_scale_1 = __webpack_require__(78);
const d3_shape_1 = __webpack_require__(18);
const React = __importStar(__webpack_require__(0));
const tooltip_content_1 = __importDefault(__webpack_require__(44));
const utilities_1 = __webpack_require__(77);
exports.semioticLineChart = (data, schema, options) => {
    let lineData;
    const { chart, selectedMetrics, lineType, metrics, primaryKey, colors } = options;
    // const F = (a: number, b:Dx.Chart): string[]=> selectedMetrics;
    const { timeseriesSort } = chart;
    const timeSeriesFields = schema.fields.find(field => field && field.name === timeseriesSort);
    const sortType = timeseriesSort === "array-order"
        ? "integer"
        : timeSeriesFields && timeSeriesFields.type
            ? timeSeriesFields.type
            : null;
    const formatting = (tickValue) => sortType === "datetime"
        ? tickValue.toLocaleString().split(",")[0]
        : utilities_1.numeralFormatting(tickValue);
    const xScale = sortType === "datetime" ? d3_scale_1.scaleTime() : d3_scale_1.scaleLinear();
    lineData = metrics
        .map((metric, index) => {
        const metricData = timeseriesSort === "array-order"
            ? data
            : data.sort(
            // Using some questionable type assertions here
            (datapointA, datapointB) => datapointA[timeseriesSort] - datapointB[timeseriesSort]);
        return {
            color: colors[index % colors.length],
            label: metric.name,
            type: metric.type,
            coordinates: metricData.map((datapoint, datapointValue) => ({
                value: datapoint[metric.name],
                x: timeseriesSort === "array-order"
                    ? datapointValue
                    : datapoint[timeseriesSort],
                label: metric.name,
                color: colors[index % colors.length],
                originalData: datapoint
            }))
        };
    })
        .filter((metric) => selectedMetrics.length === 0 ||
        selectedMetrics.some(selectedMetric => selectedMetric === metric.label));
    const canvasRender = lineData[0].coordinates.length > 250;
    const lineSettings = {
        lineType: { type: lineType, interpolator: d3_shape_1.curveMonotoneX },
        lines: lineData,
        xScaleType: xScale,
        canvasLines: canvasRender,
        renderKey: (line, index) => {
            return line.coordinates
                ? `line-${line.label}`
                : `linepoint=${line.label}-${index}`;
        },
        lineStyle: (line) => ({
            fill: lineType === "line" ? "none" : line.color,
            stroke: line.color,
            fillOpacity: 0.75
        }),
        pointStyle: (point) => {
            return {
                fill: point.color,
                fillOpacity: 0.75
            };
        },
        axes: [
            { orient: "left", tickFormat: utilities_1.numeralFormatting },
            {
                orient: "bottom",
                ticks: 5,
                tickFormat: (tickValue) => {
                    const label = formatting(tickValue);
                    const rotation = label.length > 4 ? "45" : "0";
                    const textAnchor = label.length > 4 ? "start" : "middle";
                    return (React.createElement("text", { transform: `rotate(${rotation})`, textAnchor: textAnchor }, label));
                }
            }
        ],
        hoverAnnotation: true,
        xAccessor: "x",
        yAccessor: "value",
        showLinePoints: !canvasRender && lineType === "line",
        margin: {
            top: 20,
            right: 200,
            bottom: sortType === "datetime" ? 80 : 40,
            left: 50
        },
        legend: {
            title: "Legend",
            position: "right",
            width: 200,
            legendGroups: [
                {
                    label: "",
                    styleFn: (legendItem) => ({ fill: legendItem.color }),
                    items: lineData
                }
            ]
        },
        tooltipContent: (hoveredDatapoint) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
                React.createElement("p", null, hoveredDatapoint.parentLine && hoveredDatapoint.parentLine.label),
                React.createElement("p", null, (hoveredDatapoint.value &&
                    hoveredDatapoint.value.toLocaleString()) ||
                    hoveredDatapoint.value),
                React.createElement("p", null,
                    timeseriesSort,
                    ": ",
                    formatting(hoveredDatapoint.x)),
                primaryKey.map((pkey, index) => (React.createElement("p", { key: `key-${index}` },
                    pkey,
                    ":",
                    " ",
                    (hoveredDatapoint.originalData[pkey].toString &&
                        hoveredDatapoint.originalData[pkey].toString()) ||
                        hoveredDatapoint.originalData[pkey])))));
        }
    };
    return { frameSettings: lineSettings, colorDim: "none", colorHash: {} };
};


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticNetwork = void 0;
const d3_scale_1 = __webpack_require__(78);
const React = __importStar(__webpack_require__(0));
const tooltip_content_1 = __importDefault(__webpack_require__(44));
const fontScale = d3_scale_1.scaleLinear()
    .domain([5, 30])
    .range([8, 16])
    .clamp(true);
const edgeStyles = {
    force: (colorHash) => (edge) => ({
        fill: colorHash[edge.source.id],
        stroke: colorHash[edge.source.id],
        strokeOpacity: 0.25
    }),
    sankey: (colorHash) => (edge) => ({
        fill: colorHash[edge.source.id],
        stroke: colorHash[edge.source.id],
        strokeOpacity: 0.25
    }),
    matrix: (colorHash) => (edge) => ({
        fill: colorHash[edge.source.id],
        stroke: "none"
    }),
    arc: (colorHash) => (edge) => ({
        fill: "none",
        stroke: colorHash[edge.source.id],
        strokeWidth: edge.weight || 1,
        strokeOpacity: 0.75
    })
};
const nodeStyles = {
    force: (colorHash) => (node) => ({
        fill: colorHash[node.id],
        stroke: colorHash[node.id],
        strokeOpacity: 0.5
    }),
    sankey: (colorHash) => (node) => ({
        fill: colorHash[node.id],
        stroke: colorHash[node.id],
        strokeOpacity: 0.5
    }),
    matrix: (colorHash) => (node) => ({
        fill: "none",
        stroke: "#666",
        strokeOpacity: 1
    }),
    arc: (colorHash) => (node) => ({
        fill: colorHash[node.id],
        stroke: colorHash[node.id],
        strokeOpacity: 0.5
    })
};
const nodeLinkHover = [
    { type: "frame-hover" },
    {
        type: "highlight",
        style: { stroke: "red", strokeOpacity: 0.5, strokeWidth: 5, fill: "none" }
    }
];
const hoverAnnotationSettings = {
    force: nodeLinkHover,
    sankey: nodeLinkHover,
    matrix: [
        { type: "frame-hover" },
        { type: "highlight", style: { fill: "red", fillOpacity: 0.5 } }
    ],
    arc: nodeLinkHover
};
const nodeLabeling = {
    none: false,
    static: true,
    scaled: (d) => {
        if (!d.nodeSize || d.nodeSize < 5) {
            return null;
        }
        return (React.createElement("text", { textAnchor: "middle", y: fontScale(d.nodeSize) / 2, fontSize: `${fontScale(d.nodeSize)}px` }, d.id));
    }
};
exports.semioticNetwork = (data, schema, options, colorHashOverride, colorDimOverride) => {
    const { networkType = "force", chart, colors } = options;
    const { dim1: sourceDimension, dim2: targetDimension, metric1, networkLabel } = chart;
    if (!sourceDimension ||
        sourceDimension === "none" ||
        !targetDimension ||
        targetDimension === "none") {
        return {};
    }
    const edgeHash = {};
    const networkData = [];
    data.forEach(edge => {
        if (!edgeHash[`${edge[sourceDimension]}-${edge[targetDimension]}`]) {
            edgeHash[`${edge[sourceDimension]}-${edge[targetDimension]}`] = {
                source: edge[sourceDimension],
                target: edge[targetDimension],
                value: 0,
                weight: 0
            };
            networkData.push(edgeHash[`${edge[sourceDimension]}-${edge[targetDimension]}`]);
        }
        edgeHash[`${edge[sourceDimension]}-${edge[targetDimension]}`].value +=
            edge[metric1] || 1;
        edgeHash[`${edge[sourceDimension]}-${edge[targetDimension]}`].weight += 1;
    });
    const colorHash = colorHashOverride || {};
    if (!colorHashOverride) {
        data.forEach(edge => {
            if (!colorHash[edge[sourceDimension]]) {
                colorHash[edge[sourceDimension]] =
                    colors[Object.keys(colorHash).length % colors.length];
            }
            if (!colorHash[edge[targetDimension]]) {
                colorHash[edge[targetDimension]] =
                    colors[Object.keys(colorHash).length % colors.length];
            }
        });
    }
    networkData.forEach(edge => {
        edge.weight = Math.min(10, edge.weight);
    });
    const networkSettings = {
        edges: networkData,
        edgeType: networkType === "force" && "halfarrow",
        edgeStyle: edgeStyles[networkType](colorHash),
        nodeStyle: nodeStyles[networkType](colorHash),
        nodeSizeAccessor: (node) => node.degree,
        networkType: {
            type: networkType,
            iterations: 1000
        },
        hoverAnnotation: hoverAnnotationSettings[networkType],
        tooltipContent: (hoveredNode) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredNode.x, y: hoveredNode.y },
                React.createElement("h3", null, hoveredNode.id),
                React.createElement("p", null,
                    "Links: ",
                    hoveredNode.degree),
                hoveredNode.value && React.createElement("p", null,
                    "Value: ",
                    hoveredNode.value)));
        },
        nodeLabels: networkType === "matrix" ? false : nodeLabeling[networkLabel],
        margin: { left: 100, right: 100, top: 10, bottom: 10 }
    };
    return { frameSettings: networkSettings, colorDim: sourceDimension, colorHash };
};


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticSummaryChart = void 0;
const d3_scale_1 = __webpack_require__(78);
const React = __importStar(__webpack_require__(0));
const HTMLLegend_1 = __importDefault(__webpack_require__(72));
const tooltip_content_1 = __importStar(__webpack_require__(44));
const utilities_1 = __webpack_require__(77);
const fontScale = d3_scale_1.scaleLinear()
    .domain([8, 25])
    .range([14, 8])
    .clamp(true);
exports.semioticSummaryChart = (data, schema, options, colorHashOverride, colorDimOverride) => {
    const additionalSettings = {};
    const colorHash = colorHashOverride || {};
    const { chart, summaryType, primaryKey, colors, setColor, showLegend } = options;
    const { dim1, metric1 } = chart;
    const oAccessor = dim1;
    const rAccessor = metric1;
    const uniqueValues = data.reduce((uniqueArray, datapoint) => (!uniqueArray.find((dimValue) => dimValue === datapoint[dim1].toString()) && [...uniqueArray, datapoint[dim1].toString()]) ||
        uniqueArray, []);
    if (!colorHashOverride && dim1 && dim1 !== "none") {
        uniqueValues.sort().forEach((dimValue, index) => {
            colorHash[dimValue] = colors[index % colors.length];
        });
        if (showLegend) {
            additionalSettings.afterElements = (React.createElement(HTMLLegend_1.default, { valueHash: {}, colorHash: colorHash, setColor: setColor, colors: colors }));
        }
    }
    const summarySettings = Object.assign({ summaryType: { type: summaryType, bins: 16, amplitude: 20 }, type: summaryType === "violin" && data.length < 250 && "swarm", projection: "horizontal", data,
        oAccessor,
        rAccessor, summaryStyle: (summaryDatapoint) => ({
            fill: colorHash[summaryDatapoint[colorDimOverride || dim1]] || colors[0],
            fillOpacity: 0.8,
            stroke: colorHash[summaryDatapoint[colorDimOverride || dim1]] || colors[0]
        }), style: (pieceDatapoint) => ({
            fill: colorHash[pieceDatapoint[colorDimOverride || dim1]] || colors[0],
            stroke: "white"
        }), oPadding: 5, oLabel: uniqueValues.length > 30
            ? false
            : (columnName) => (React.createElement("text", { textAnchor: "end", fontSize: `${(columnName && fontScale(columnName.length)) ||
                    12}px` }, columnName)), margin: { top: 25, right: 10, bottom: 50, left: 100 }, axes: [
            {
                orient: "bottom",
                label: rAccessor,
                tickFormat: utilities_1.numeralFormatting
            }
        ], baseMarkProps: { forceUpdate: true }, pieceHoverAnnotation: summaryType === "violin", tooltipContent: (hoveredDatapoint) => {
            const dimensions = options.dimensions.filter(dim => dim.name !== dim1);
            const furtherDims = dimensions.map(dim => (React.createElement("p", null,
                dim.name,
                ": ",
                tooltip_content_1.safeDisplayValue(hoveredDatapoint[dim.name]))));
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
                React.createElement("h3", null, primaryKey.map(pkey => hoveredDatapoint[pkey]).join(", ")),
                React.createElement("p", null,
                    dim1,
                    ": ",
                    tooltip_content_1.safeDisplayValue(hoveredDatapoint[dim1])),
                furtherDims,
                React.createElement("p", null,
                    rAccessor,
                    ": ",
                    tooltip_content_1.safeDisplayValue(hoveredDatapoint[rAccessor]))));
        } }, additionalSettings);
    return { frameSettings: summarySettings, colorDim: dim1, colorHash };
};


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semioticXYPlot = exports.semioticScatterplot = exports.semioticHexbin = void 0;
const d3_scale_1 = __webpack_require__(78);
const React = __importStar(__webpack_require__(0));
const semiotic_1 = __webpack_require__(81);
const HTMLLegend_1 = __importDefault(__webpack_require__(72));
const tooltip_content_1 = __importDefault(__webpack_require__(44));
const utilities_1 = __webpack_require__(77);
const shared_1 = __webpack_require__(219);
const styled_components_1 = __importDefault(__webpack_require__(19));
const TooltipHeader = styled_components_1.default.div `
  font-size: 14px;
  text-transform: uppercase;
  margin: 5px;
  font-weight: 900;
`;
const TooltipP = styled_components_1.default.div `
  fontsize: 12px;
  texttransform: uppercase;
  margin: 5px;
`;
const binHash = {
    heatmap: semiotic_1.heatmapping,
    hexbin: semiotic_1.hexbinning
};
const steps = ["none", "#FBEEEC", "#f3c8c2", "#e39787", "#ce6751", "#b3331d"];
const thresholds = d3_scale_1.scaleThreshold()
    .domain([0.01, 0.2, 0.4, 0.6, 0.8])
    .range(steps);
function combineTopAnnotations(topQ, topSecondQ, dim2) {
    const combinedAnnotations = [];
    const combinedHash = {};
    [...topQ, ...topSecondQ].forEach(topDatapoint => {
        const hashD = combinedHash[topDatapoint[dim2]];
        if (hashD) {
            const newCoordinates = (hashD.coordinates && [
                ...hashD.coordinates,
                topDatapoint
            ]) || [topDatapoint, hashD];
            Object.keys(combinedHash[topDatapoint[dim2]]).forEach(key => {
                delete combinedHash[topDatapoint[dim2]][key];
            });
            combinedHash[topDatapoint[dim2]].id = topDatapoint[dim2];
            combinedHash[topDatapoint[dim2]].label = topDatapoint[dim2];
            combinedHash[topDatapoint[dim2]].type = "react-annotation";
            combinedHash[topDatapoint[dim2]].coordinates = newCoordinates;
        }
        else {
            combinedHash[topDatapoint[dim2]] = Object.assign({ type: "react-annotation", label: topDatapoint[dim2], id: topDatapoint[dim2], coordinates: [] }, topDatapoint);
            combinedAnnotations.push(combinedHash[topDatapoint[dim2]]);
        }
    });
    return combinedAnnotations;
}
exports.semioticHexbin = (data, schema, options, colorHashOverride, colorDimOverride) => {
    return exports.semioticXYPlot(data, schema, options, options.areaType, colorHashOverride, colorDimOverride);
};
exports.semioticScatterplot = (data, schema, options, colorHashOverride, colorDimOverride) => {
    return exports.semioticXYPlot(data, schema, options, "scatterplot", colorHashOverride, colorDimOverride);
};
exports.semioticXYPlot = (data, schema, options, type = "scatterplot", colorHashOverride, colorDimOverride) => {
    const height = options.height - 150 || 500;
    const { chart, primaryKey, colors, setColor, dimensions, trendLine, marginalGraphics } = options;
    const { dim1, dim2, dim3, metric1, metric2, metric3 } = chart;
    const filteredData = data.filter((datapoint) => datapoint[metric1] &&
        datapoint[metric2] &&
        (!metric3 || metric3 === "none" || datapoint[metric3]));
    const pointTooltip = (hoveredDatapoint) => {
        return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
            React.createElement("h3", null, primaryKey.map(pkey => hoveredDatapoint[pkey]).join(", ")),
            dimensions.map(dim => (React.createElement("p", { key: `tooltip-dim-${dim.name}` },
                dim.name,
                ":",
                " ",
                (hoveredDatapoint[dim.name].toString &&
                    hoveredDatapoint[dim.name].toString()) ||
                    hoveredDatapoint[dim.name]))),
            React.createElement("p", null,
                metric1,
                ": ",
                hoveredDatapoint[metric1]),
            React.createElement("p", null,
                metric2,
                ": ",
                hoveredDatapoint[metric2]),
            metric3 && metric3 !== "none" && (React.createElement("p", null,
                metric3,
                ": ",
                hoveredDatapoint[metric3]))));
    };
    const areaTooltip = (hoveredDatapoint) => {
        const binItems = hoveredDatapoint.binItems || hoveredDatapoint.data || [];
        if (binItems.length === 0) {
            return null;
        }
        return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
            React.createElement(TooltipHeader, null,
                "ID, ",
                metric1,
                ", ",
                metric2),
            binItems.map((binnedDatapoint, index) => {
                const id = dimensions
                    .map(dim => (binnedDatapoint[dim.name].toString &&
                    binnedDatapoint[dim.name].toString()) ||
                    binnedDatapoint[dim.name])
                    .join(",");
                return (React.createElement(TooltipP, { key: id + index },
                    id,
                    ", ",
                    binnedDatapoint[metric1],
                    ", ",
                    binnedDatapoint[metric2]));
            })));
    };
    let sizeScale = () => 5;
    const colorHash = colorHashOverride || { Other: "grey" };
    const additionalSettings = {};
    let annotations;
    if (dim2 && dim2 !== "none") {
        const topQ = [...filteredData]
            .sort((datapointA, datapointB) => datapointB[metric1] - datapointA[metric1])
            .filter((d, index) => index < 3);
        const topSecondQ = [...filteredData]
            .sort((datapointA, datapointB) => datapointB[metric2] - datapointA[metric2])
            .filter(datapoint => topQ.indexOf(datapoint) === -1)
            .filter((d, index) => index < 3);
        annotations = combineTopAnnotations(topQ, topSecondQ, dim2);
    }
    // disabling annotations for now
    annotations = undefined;
    if (metric3 && metric3 !== "none") {
        const dataMin = Math.min(...filteredData.map(datapoint => datapoint[metric3]));
        const dataMax = Math.max(...filteredData.map(datapoint => datapoint[metric3]));
        sizeScale = d3_scale_1.scaleLinear()
            .domain([dataMin, dataMax])
            .range([2, 20]);
    }
    const sortedData = shared_1.sortByOrdinalRange(metric1, (metric3 !== "none" && metric3) || metric2, "none", data);
    if ((type === "scatterplot" || type === "contour") &&
        dim1 &&
        dim1 !== "none") {
        const uniqueValues = sortedData.reduce((uniqueArray, datapoint) => (!uniqueArray.find((uniqueDim) => uniqueDim === datapoint[dim1].toString()) && [...uniqueArray, datapoint[dim1].toString()]) ||
            uniqueArray, []);
        if (!colorHashOverride) {
            uniqueValues.sort().forEach((dimValue, index) => {
                colorHash[dimValue] = index > 18 ? "grey" : colors[index % colors.length];
            });
        }
        additionalSettings.afterElements = (React.createElement(HTMLLegend_1.default, { valueHash: {}, colorHash: colorHash, setColor: setColor, colors: colors }));
    }
    let areas = [];
    if (type === "heatmap" ||
        type === "hexbin" ||
        (type === "contour" && dim3 === "none")) {
        areas = [{ coordinates: filteredData }];
        if (type !== "contour") {
            const calculatedAreas = binHash[type]({
                summaryType: { type, bins: 10 },
                data: {
                    coordinates: filteredData.map(datapoint => (Object.assign(Object.assign({}, datapoint), { x: datapoint[metric1], y: datapoint[metric2] })))
                },
                size: [height, height]
            });
            areas = calculatedAreas;
            const thresholdSteps = [0.2, 0.4, 0.6, 0.8, 1]
                .map(thresholdValue => Math.floor(calculatedAreas.binMax * thresholdValue))
                .reduce((thresholdArray, thresholdValue) => thresholdValue === 0 ||
                thresholdArray.indexOf(thresholdValue) !== -1
                ? thresholdArray
                : [...thresholdArray, thresholdValue], []);
            const withZeroThresholdSteps = [0, ...thresholdSteps];
            const hexValues = [];
            withZeroThresholdSteps.forEach((thresholdValue, index) => {
                const nextValue = withZeroThresholdSteps[index + 1];
                if (nextValue) {
                    hexValues.push(`${thresholdValue + 1} - ${nextValue}`);
                }
            });
            const thresholdColors = [
                "#FBEEEC",
                "#f3c8c2",
                "#e39787",
                "#ce6751",
                "#b3331d"
            ];
            const hexHash = {};
            hexValues.forEach((binLabel, index) => {
                hexHash[binLabel] = thresholdColors[index];
            });
            thresholds
                .domain([0.01, ...thresholdSteps])
                .range([
                "none",
                ...thresholdColors.filter((d, index) => index < thresholdSteps.length)
            ]);
            additionalSettings.afterElements = (React.createElement(HTMLLegend_1.default, { valueHash: {}, values: hexValues, colorHash: hexHash, colors: colors, setColor: setColor }));
        }
    }
    else if (type === "contour") {
        const multiclassHash = {};
        areas = [];
        filteredData.forEach(datapoint => {
            if (!multiclassHash[datapoint[dim1]]) {
                multiclassHash[datapoint[dim1]] = {
                    label: datapoint[dim1],
                    color: colorHash[datapoint[dim1]],
                    coordinates: []
                };
                areas.push(multiclassHash[datapoint[dim1]]);
            }
            multiclassHash[datapoint[dim1]].coordinates.push(datapoint);
        });
    }
    const renderInCanvas = (type === "scatterplot" || type === "contour") && data.length > 999;
    let marginalGraphicsAxes = [];
    if (marginalGraphics !== "none" && type === "scatterplot") {
        marginalGraphicsAxes = [
            {
                orient: "right",
                tickLineGenerator: () => React.createElement("g", null),
                tickFormat: () => "",
                marginalSummaryType: {
                    type: marginalGraphics,
                    showPoints: !renderInCanvas
                }
            },
            {
                orient: "top",
                tickLineGenerator: () => React.createElement("g", null),
                tickFormat: () => "",
                marginalSummaryType: {
                    type: marginalGraphics,
                    showPoints: !renderInCanvas
                }
            }
        ];
    }
    let calculatedSummaryType;
    if (type === "scatterplot" && trendLine !== "none") {
        calculatedSummaryType = { type: "trendline", regressionType: trendLine };
    }
    else if (type !== "scatterplot") {
        calculatedSummaryType = {
            type,
            bins: 10,
            thresholds: dim3 === "none" ? 6 : 3
        };
    }
    const xyPlotSettings = Object.assign({ xAccessor: type === "hexbin" || type === "heatmap" ? "x" : metric1, yAccessor: type === "hexbin" || type === "heatmap" ? "y" : metric2, axes: [
            {
                orient: "left",
                ticks: 6,
                label: metric2,
                tickFormat: utilities_1.numeralFormatting,
                baseline: type === "scatterplot",
                tickSize: type === "heatmap" ? 0 : undefined
            },
            {
                orient: "bottom",
                ticks: 6,
                label: metric1,
                tickFormat: utilities_1.numeralFormatting,
                footer: type === "heatmap",
                baseline: type === "scatterplot",
                tickSize: type === "heatmap" ? 0 : undefined
            },
            ...marginalGraphicsAxes
        ], points: (type === "scatterplot" || type === "contour") && data, canvasPoints: renderInCanvas, summaryType: calculatedSummaryType, summaryStyle: (areaDatapoint) => {
            if (type === "scatterplot") {
                return { stroke: "darkred", strokeWidth: 2, fill: "none" };
            }
            return {
                fill: type === "contour"
                    ? "none"
                    : thresholds((areaDatapoint.binItems || areaDatapoint.data).length),
                stroke: type !== "contour"
                    ? undefined
                    : dim3 === "none"
                        ? "#BBB"
                        : areaDatapoint.parentSummary.color,
                strokeWidth: type === "contour" ? 2 : 1
            };
        }, pointStyle: (datapoint) => {
            return {
                r: renderInCanvas
                    ? 2
                    : type === "contour"
                        ? 3
                        : `${sizeScale(datapoint[metric3])}px`,
                fill: colorHash[datapoint[colorDimOverride || dim1]] || "black",
                fillOpacity: 0.75,
                stroke: renderInCanvas ? "none" : type === "contour" ? "white" : "black",
                strokeWidth: type === "contour" ? 0.5 : 1,
                strokeOpacity: 0.9
            };
        }, hoverAnnotation: true, responsiveWidth: false, size: [height + 105, height + 80], margin: { left: 75, bottom: 75, right: 30, top: 30 }, annotations: (type === "scatterplot" && annotations) || undefined, annotationSettings: {
            layout: { type: "marginalia", orient: "right", marginOffset: 30 }
        }, tooltipContent: ((type === "hexbin" || type === "heatmap") && areaTooltip) ||
            pointTooltip }, additionalSettings);
    if (type !== "scatterplot") {
        xyPlotSettings.summaries = areas;
    }
    return { frameSettings: xyPlotSettings, colorDim: dim1, colorHash };
};


/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.colors = void 0;
exports.colors = [
    "#DA752E",
    "#E5C209",
    "#1441A0",
    "#B86117",
    "#4D430C",
    "#1DB390",
    "#B3331D",
    "#088EB2",
    "#417505",
    "#E479A8",
    "#F9F39E",
    "#5782DC",
    "#EBA97B",
    "#A2AB60",
    "#B291CF",
    "#8DD2C2",
    "#E6A19F",
    "#3DC7E0",
    "#98CE5B"
];


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
const chart_docs_1 = __webpack_require__(220);
const styled_components_1 = __importStar(__webpack_require__(19));
const commonCSS = styled_components_1.css `
  h2 {
    text-transform: capitalize;
    margin-bottom: 10px;
  }
  select {
    height: 30px;
  }

  .selected {
    background-color: #d8e1e8 !important;
    background-image: none !important;
  }
`;
const ControlWrapper = styled_components_1.default.div `
  margin-right: 30px;
  ${commonCSS}
`;
const Wrapper = styled_components_1.default.div `
  display: flex;
  flex-wrap: wrap;
  justify-content: left;
  margin-bottom: 30px;
  ${commonCSS}
`;
const metricDimSelector = (values, selectionFunction, title, required, selectedValue, contextTooltip = "Help me help you help yourself", facetingFunction) => {
    const metricsList = required ? values : ["none", ...values];
    let displayMetrics;
    if (metricsList.length > 1) {
        displayMetrics = (React.createElement("select", { onChange: (event) => {
                selectionFunction(event.target.value);
            }, value: selectedValue }, metricsList.map((metricName, i) => (React.createElement("option", { "aria-selected": selectedValue === metricName, key: `display-metric-${i}`, label: metricName, value: metricName }, metricName)))));
    }
    else {
        displayMetrics = React.createElement("p", { style: { margin: 0 } }, metricsList[0]);
    }
    let generateFacetButton;
    if (facetingFunction) {
        generateFacetButton = (React.createElement("button", { onClick: () => {
                facetingFunction("metric", title);
            } }, "Facet"));
    }
    return (React.createElement(ControlWrapper, { title: contextTooltip },
        React.createElement("div", null,
            React.createElement("h3", null, title)),
        displayMetrics,
        generateFacetButton));
};
const availableLineTypes = [
    {
        type: "line",
        label: "Line Chart"
    },
    {
        type: "stackedarea",
        label: "Stacked Area Chart"
    },
    {
        type: "stackedpercent",
        label: "Stacked Area Chart (Percent)"
    },
    {
        type: "bumparea",
        label: "Ranked Area Chart"
    }
];
const availableAreaTypes = [
    {
        type: "hexbin",
        label: "Hexbin"
    },
    {
        type: "heatmap",
        label: "Heatmap"
    },
    {
        type: "contour",
        label: "Contour Plot"
    }
];
exports.default = ({ view, chart, metrics, dimensions, updateChart, selectedDimensions, selectedMetrics, hierarchyType, trendLine, marginalGraphics, barGrouping, summaryType, networkType, setLineType, updateMetrics, updateDimensions, lineType, areaType, setAreaType, data, generateFacets }) => {
    const metricNames = metrics.map(metric => metric.name);
    const dimensionNames = dimensions.map(dim => dim.name);
    const updateChartGenerator = (chartProperty) => {
        return (metricOrDim) => updateChart({ chart: Object.assign(Object.assign({}, chart), { [chartProperty]: metricOrDim }) });
    };
    const getControlHelpText = (view, metricOrDim) => {
        if (Object.keys(chart_docs_1.controlHelpText).find(mOrD => mOrD === metricOrDim)) {
            const mOrD = metricOrDim;
            const views = chart_docs_1.controlHelpText[mOrD] !== undefined ? chart_docs_1.controlHelpText[mOrD] : null;
            if (views == null) {
                return "";
            }
            if (typeof views === "string") {
                return views;
            }
            if (views[view] != null) {
                return views[view];
            }
            else {
                return views.default;
            }
        }
        return "";
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(Wrapper, null,
            (view === "summary" ||
                view === "scatter" ||
                view === "hexbin" ||
                view === "bar" ||
                view === "network" ||
                view === "hierarchy") &&
                metricDimSelector(metricNames, updateChartGenerator("metric1"), view === "scatter" || view === "hexbin" ? "X" : "Metric", true, chart.metric1, getControlHelpText(view, "metric1"), generateFacets("metric1")),
            (view === "scatter" || view === "hexbin") &&
                metricDimSelector(metricNames, updateChartGenerator("metric2"), "Y", true, chart.metric2, getControlHelpText(view, "metric2"), generateFacets("metric2")),
            ((view === "scatter" && data.length < 1000) || view === "bar") &&
                metricDimSelector(metricNames, updateChartGenerator("metric3"), view === "bar" ? "Width" : "Size", false, chart.metric3, getControlHelpText(view, "metric3"), generateFacets("metric3")),
            view === "bar" &&
                metricDimSelector(metricNames, updateChartGenerator("metric4"), "Error Bars", false, chart.metric4, getControlHelpText(view, "metric4"), generateFacets("metric4")),
            view === "bar" &&
                metricDimSelector(["Clustered", "Stacked"], selectedBarGrouping => updateChart({ barGrouping: selectedBarGrouping }), "Stack or Cluster", true, barGrouping, chart_docs_1.controlHelpText.barGrouping),
            view === "scatter" &&
                metricDimSelector(["boxplot", "violin", "heatmap", "ridgeline", "histogram"], selectedMarginalGraphics => updateChart({ marginalGraphics: selectedMarginalGraphics }), "Marginal Graphics", false, marginalGraphics, chart_docs_1.controlHelpText.marginalGraphics),
            view === "scatter" &&
                metricDimSelector(["linear", "polynomial", "power", "exponential", "logarithmic"], selectedRegressionType => updateChart({ trendLine: selectedRegressionType }), "Trendline", false, trendLine, chart_docs_1.controlHelpText.trendLine),
            (view === "summary" ||
                view === "scatter" ||
                (view === "hexbin" && areaType === "contour") ||
                view === "bar" ||
                view === "parallel") &&
                metricDimSelector(dimensionNames, updateChartGenerator("dim1"), view === "summary" ? "Category" : "Color", true, chart.dim1, getControlHelpText(view, "dim1")),
            view === "scatter" &&
                metricDimSelector(dimensionNames, updateChartGenerator("dim2"), "Labels", false, chart.dim2, getControlHelpText(view, "dim2")),
            view === "hexbin" &&
                areaType === "contour" &&
                metricDimSelector(["by color"], updateChartGenerator("dim3"), "Multiclass", false, chart.dim3, getControlHelpText(view, "dim3")),
            view === "network" &&
                metricDimSelector(dimensionNames, updateChartGenerator("dim1"), "SOURCE", true, chart.dim1, getControlHelpText(view, "dim1")),
            view === "network" &&
                metricDimSelector(dimensionNames, updateChartGenerator("dim2"), "TARGET", true, chart.dim2, getControlHelpText(view, "dim2")),
            view === "network" &&
                metricDimSelector(["matrix", "arc", "force", "sankey"], selectedNetworkType => updateChart({ networkType: selectedNetworkType }), "Type", true, networkType, chart_docs_1.controlHelpText.networkType),
            view === "network" &&
                metricDimSelector(["static", "scaled"], updateChartGenerator("networkLabel"), "Show Labels", false, chart.networkLabel, chart_docs_1.controlHelpText.networkLabel),
            view === "hierarchy" &&
                metricDimSelector(["dendrogram", "treemap", "partition", "sunburst"], selectedHierarchyType => updateChart({ hierarchyType: selectedHierarchyType }), "Type", true, hierarchyType, chart_docs_1.controlHelpText.hierarchyType),
            view === "summary" &&
                metricDimSelector(["violin", "boxplot", "ridgeline", "heatmap", "histogram"], selectedSummaryType => updateChart({ summaryType: selectedSummaryType }), "Type", true, summaryType, chart_docs_1.controlHelpText.summaryType),
            view === "line" &&
                metricDimSelector(["array-order", ...metricNames], updateChartGenerator("timeseriesSort"), "Sort by", true, chart.timeseriesSort, chart_docs_1.controlHelpText.timeseriesSort),
            view === "line" && (React.createElement("div", { title: chart_docs_1.controlHelpText.lineType, style: { display: "inline-block" } },
                React.createElement("div", null,
                    React.createElement("h3", null, "Chart Type")),
                availableLineTypes.map(lineTypeOption => (React.createElement("button", { key: lineTypeOption.type, className: `button-text ${lineType === lineTypeOption.type &&
                        "selected"}`, onClick: () => setLineType(lineTypeOption.type) }, lineTypeOption.label))))),
            view === "hexbin" && (React.createElement("div", { className: "control-wrapper", title: chart_docs_1.controlHelpText.areaType },
                React.createElement("div", null,
                    React.createElement("h3", null, "Chart Type")),
                availableAreaTypes.map(areaTypeOption => {
                    const areaTypeOptionType = areaTypeOption.type;
                    if (areaTypeOptionType === "contour" ||
                        areaTypeOptionType === "hexbin" ||
                        areaTypeOptionType === "heatmap") {
                        return (React.createElement("button", { className: `button-text ${areaType === areaTypeOptionType &&
                                "selected"}`, key: areaTypeOptionType, onClick: () => setAreaType(areaTypeOptionType) }, areaTypeOption.label));
                    }
                    else {
                        return React.createElement("div", null);
                    }
                }))),
            view === "hierarchy" && (React.createElement("div", { className: "control-wrapper", title: chart_docs_1.controlHelpText.nestingDimensions },
                React.createElement("div", null,
                    React.createElement("h3", null, "Nesting")),
                selectedDimensions.length === 0
                    ? "Select categories to nest"
                    : `root, ${selectedDimensions.join(", ")}`)),
            (view === "bar" || view === "hierarchy") && (React.createElement("div", { className: "control-wrapper", title: chart_docs_1.controlHelpText.barDimensions },
                React.createElement("div", null,
                    React.createElement("h3", null, "Categories")),
                dimensions.map(dim => (React.createElement("button", { key: `dimensions-select-${dim.name}`, className: `button-text ${selectedDimensions.indexOf(dim.name) !== -1 && "selected"}`, onClick: () => updateDimensions(dim.name) }, dim.name))))),
            view === "line" && (React.createElement("div", { className: "control-wrapper", title: chart_docs_1.controlHelpText.lineDimensions },
                React.createElement("div", null,
                    React.createElement("h3", null, "Metrics")),
                metrics.map(metric => (React.createElement("button", { key: `metrics-select-${metric.name}`, className: `button-text ${selectedMetrics.indexOf(metric.name) !== -1 && "selected"}`, onClick: () => updateMetrics(metric.name) }, metric.name))))))));
};


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(__webpack_require__(0));
function default_1(props) {
    const { removeFunction, focusFunction, dxSettings, facetIndex } = props;
    return React.createElement("div", null,
        React.createElement("button", { onClick: () => { removeFunction(facetIndex); } }, "Remove"),
        React.createElement("button", { onClick: () => { focusFunction(dxSettings); } }, "Focus"));
}
exports.default = default_1;


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParallelCoordinatesIcon = exports.BarChartIcon = exports.HexbinIcon = exports.LineChartIcon = exports.ScatterplotIcon = exports.NetworkIcon = exports.TreeIcon = exports.BoxplotIcon = void 0;
const octicons_1 = __webpack_require__(223);
const React = __importStar(__webpack_require__(0));
const styled_components_1 = __importDefault(__webpack_require__(19));
const IconPath = styled_components_1.default.path `
  & {
    fill: var(--theme-app-bg, #ccc);
    stroke: var(--theme-app-fg, #2b2b2b);
  }
`;
exports.BoxplotIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Summary Diagram"),
    React.createElement(IconPath, { d: "M 9.2300893,12.746467 15.329337,12.746467 M 0.73981357,15.376296 6.8390612,15.376296 M 3.9346579,0.6634694 3.9346579,15.376296 M 0.73981357,0.6634694 6.8390612,0.6634694 M 12.424932,1.5163867 12.424932,12.817543 M 9.2300893,1.5163867 15.329337,1.5163867 M 9.3149176,3.8522966 15.454941,3.8522966 15.454941,10.067428 9.3149176,10.067428 Z M 0.63101533,5.4042547 6.771038,5.4042547 6.771038,13.040916 0.63101533,13.040916 Z" })));
exports.TreeIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Dendrogram"),
    React.createElement(IconPath, { d: "M 5.3462352,16.86934 5.3462352,11.568531 M 5.0378073,11.186463 10.665375,16.453304 M 5.5794816,11.049276 -0.04808655,16.316116 M 10.903757,11.840357 10.903757,6.5395482 M 10.722225,5.9958343 16.349791,11.262675 M 10.758529,6.1997119 5.1309613,11.466552 M 5.3851096,6.1997401 5.3851096,0.06818774 M 5.3488028,0.96685111 10.976372,6.2336914 M 5.3851095,0.89889187 -0.24245868,6.1657322" })));
exports.NetworkIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Network"),
    React.createElement(IconPath, { d: "M 12.272948,3.9756652 9.2580839,6.8311579 M 3.7415227,3.9107679 6.435657,6.5066704 M 3.9981069,12.087859 6.6280954,9.6866496 M 12.208802,12.217654 9.0656456,9.556855 M 0.58721146,13.461599 A 2.0038971,2.0273734 0 0 0 2.591109,15.488973 2.0038971,2.0273734 0 0 0 4.5950056,13.461599 2.0038971,2.0273734 0 0 0 2.591109,11.434226 2.0038971,2.0273734 0 0 0 0.58721146,13.461599 Z M 11.483612,2.5370283 A 2.0038971,2.0273734 0 0 0 13.487509,4.5644013 2.0038971,2.0273734 0 0 0 15.491407,2.5370283 2.0038971,2.0273734 0 0 0 13.487509,0.50965432 2.0038971,2.0273734 0 0 0 11.483612,2.5370283 Z M 15.491407,13.461599 A 2.0038971,2.0273734 0 0 1 13.487509,15.488973 2.0038971,2.0273734 0 0 1 11.483612,13.461599 2.0038971,2.0273734 0 0 1 13.487509,11.434226 2.0038971,2.0273734 0 0 1 15.491407,13.461599 Z M 9.9298938,8.1089002 A 2.0038971,2.0273734 0 0 1 7.9259965,10.136275 2.0038971,2.0273734 0 0 1 5.9220989,8.1089002 2.0038971,2.0273734 0 0 1 7.9259965,6.0815273 2.0038971,2.0273734 0 0 1 9.9298938,8.1089002 Z M 4.5950056,2.5370283 A 2.0038971,2.0273734 0 0 1 2.591109,4.5644013 2.0038971,2.0273734 0 0 1 0.58721146,2.5370283 2.0038971,2.0273734 0 0 1 2.591109,0.50965432 2.0038971,2.0273734 0 0 1 4.5950056,2.5370283 Z" })));
exports.ScatterplotIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Scatterplot"),
    React.createElement(IconPath, { d: "M 6.2333524,7.1483631 A 2.1883047,2.1883047 0 0 1 4.0450478,9.3366678 2.1883047,2.1883047 0 0 1 1.8567431,7.1483631 2.1883047,2.1883047 0 0 1 4.0450478,4.9600585 2.1883047,2.1883047 0 0 1 6.2333524,7.1483631 Z M 12.201456,4.0316868 A 2.1883047,2.1883047 0 0 1 10.013151,6.2199914 2.1883047,2.1883047 0 0 1 7.8248465,4.0316868 2.1883047,2.1883047 0 0 1 10.013151,1.8433821 2.1883047,2.1883047 0 0 1 12.201456,4.0316868 Z M 14.787634,11.45866 A 2.1883047,2.1883047 0 0 1 12.599329,13.646965 2.1883047,2.1883047 0 0 1 10.411024,11.45866 2.1883047,2.1883047 0 0 1 12.599329,9.2703555 2.1883047,2.1883047 0 0 1 14.787634,11.45866 Z M 0.06631226,-0.01336003 0.06631226,16.100519 16.113879,16.100519" })));
exports.LineChartIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Line Chart"),
    React.createElement(IconPath, { d: "M 1.98856,5.3983376 3.9789255,1.5485605 6.8981275,9.2481137 10.215403,6.6815963 15.257662,12.071285 M 0.46261318,0.00862976 0.46261318,15.600225 16.518227,15.600225" })));
exports.HexbinIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Hexbin"),
    React.createElement(IconPath, { d: "M 7.6646201,7.248835 10.200286,8.7365914 12.71271,7.2956277 12.71271,4.2993354 10.200286,2.8583717 7.6481891,4.3220885 Z M 2.5260861,7.248835 5.0617524,8.7365914 7.5741798,7.2956277 7.5741798,4.2993354 5.0617524,2.8583717 2.509655,4.3220885 Z M 10.151008,11.430063 12.686686,12.917818 15.199098,11.476854 15.199098,8.4805611 12.686686,7.0395985 10.134577,8.5033165 Z M 5.0124743,11.430063 7.5481406,12.917818 10.060567,11.476854 10.060567,8.4805611 7.5481406,7.0395985 4.9960421,8.5033165 Z M 0.59322509,-0.02976587 0.59322509,16.053058 16.562547,16.008864" })));
exports.BarChartIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Bar Chart"),
    React.createElement(IconPath, { d: "M 11.58591,8.3025699 15.255735,8.3025699 15.255735,15.691481 11.58591,15.691481 Z M 6.2401471,3.973457 9.9358173,3.973457 9.9358173,15.626376 6.2401471,15.626376 Z M 0.533269,0.53717705 4.6376139,0.53717705 4.6376139,15.583893 0.533269,15.583893 Z" })));
exports.ParallelCoordinatesIcon = (props) => (React.createElement(octicons_1.SVGWrapper, { width: 16, height: 16, viewBox: "0 0 16 16", outerProps: props },
    React.createElement("title", null, "Parallel Coordinates"),
    React.createElement(IconPath, { d: "M 2.7232684,11.593098 8.8105743,9.8309837 14.417303,4.2242547 M 12.356336,0.72968704 15.29192,0.72968704 15.29192,8.4261754 12.356336,8.4261754 Z M 6.8447585,6.4156084 10.103282,6.4156084 10.103282,12.352066 6.8447585,12.352066 Z M 0.51572132,6.0114684 3.9294777,6.0114684 3.9294777,16.25395 0.51572132,16.25395 Z" })));


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IconButton = void 0;
const React = __importStar(__webpack_require__(0));
const styled_components_1 = __importDefault(__webpack_require__(19));
const baseButtonStyle = `
width: 32px;
height: 32px;
cursor: pointer;
color: var(--theme-app-fg);
`;
const BaseButton = styled_components_1.default.button `
  ${baseButtonStyle}
  border: 1px solid var(--theme-app-fg);
  background-color: var(--theme-app-bg);
`;
const SelectedButton = styled_components_1.default.button `
  ${baseButtonStyle}

  border: 1px outset #666;
  background-color: #aaa;
`;
class IconButton extends React.PureComponent {
    render() {
        const { message, onClick, children, selected } = this.props;
        const { title = message } = this.props;
        const WhichButton = selected ? SelectedButton : BaseButton;
        return (React.createElement(WhichButton, { onClick: onClick, key: message, title: title }, children));
    }
}
exports.IconButton = IconButton;


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPrimaryKey = void 0;
// If this string is the same as another field name, it would be a problem
// so it must be unique
exports.defaultPrimaryKey = "dx-default-pk";


/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "contours", function() { return /* reexport */ src_contours; });
__webpack_require__.d(__webpack_exports__, "contourDensity", function() { return /* reexport */ src_density; });

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/bisector.js


/* harmony default export */ var bisector = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/cross.js


/* harmony default export */ var cross = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/variance.js


/* harmony default export */ var variance = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/deviation.js


/* harmony default export */ var deviation = (function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/range.js
/* harmony default export */ var range = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/histogram.js









/* harmony default export */ var src_histogram = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/quantile.js


/* harmony default export */ var quantile = (function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/threshold/scott.js


/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/mean.js


/* harmony default export */ var src_mean = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/median.js




/* harmony default export */ var median = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/merge.js
/* harmony default export */ var merge = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/scan.js


/* harmony default export */ var scan = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-contour/node_modules/d3-array/src/index.js




























// CONCATENATED MODULE: ./node_modules/d3-contour/src/array.js
var src_array_array = Array.prototype;

var array_slice = src_array_array.slice;

// CONCATENATED MODULE: ./node_modules/d3-contour/src/ascending.js
/* harmony default export */ var src_ascending = (function(a, b) {
  return a - b;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/area.js
/* harmony default export */ var src_area = (function(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/constant.js
/* harmony default export */ var src_constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/contains.js
/* harmony default export */ var contains = (function(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
});

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

// CONCATENATED MODULE: ./node_modules/d3-contour/src/noop.js
/* harmony default export */ var noop = (function() {});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/contours.js








var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

/* harmony default export */ var src_contours = (function() {
  var dx = 1,
      dy = 1,
      threshold = sturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = extent(values), start = domain[0], stop = domain[1];
      tz = tickStep(start, stop, tz);
      tz = range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(src_ascending);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (src_area(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? src_constant(array_slice.call(_)) : src_constant(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/blur.js
// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

// CONCATENATED MODULE: ./node_modules/d3-contour/src/density.js






function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

/* harmony default export */ var src_density = (function() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = src_constant(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = src_max(values0);
      tz = tickStep(0, stop, tz);
      tz = range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return src_contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : src_constant(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : src_constant(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : src_constant(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? src_constant(array_slice.call(_)) : src_constant(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
});

// CONCATENATED MODULE: ./node_modules/d3-contour/src/index.js




/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "chord", function() { return /* reexport */ src_chord; });
__webpack_require__.d(__webpack_exports__, "ribbon", function() { return /* reexport */ src_ribbon; });

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/ascending.js
/* harmony default export */ var ascending = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/bisector.js


/* harmony default export */ var bisector = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/bisect.js



var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ var bisect = (bisectRight);

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/pairs.js
/* harmony default export */ var pairs = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/cross.js


/* harmony default export */ var cross = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/descending.js
/* harmony default export */ var descending = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/number.js
/* harmony default export */ var number = (function(x) {
  return x === null ? NaN : +x;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/variance.js


/* harmony default export */ var variance = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/deviation.js


/* harmony default export */ var deviation = (function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/extent.js
/* harmony default export */ var extent = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/array.js
var array_array = Array.prototype;

var slice = array_array.slice;
var map = array_array.map;

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/range.js
/* harmony default export */ var range = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ var ticks = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/threshold/sturges.js
/* harmony default export */ var sturges = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/histogram.js









/* harmony default export */ var src_histogram = (function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisect(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/quantile.js


/* harmony default export */ var quantile = (function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/threshold/freedmanDiaconis.js





/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/threshold/scott.js


/* harmony default export */ var scott = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/max.js
/* harmony default export */ var src_max = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/mean.js


/* harmony default export */ var src_mean = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/median.js




/* harmony default export */ var median = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/merge.js
/* harmony default export */ var merge = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/min.js
/* harmony default export */ var src_min = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/permute.js
/* harmony default export */ var permute = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/scan.js


/* harmony default export */ var scan = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/shuffle.js
/* harmony default export */ var shuffle = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/sum.js
/* harmony default export */ var src_sum = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/transpose.js


/* harmony default export */ var src_transpose = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function transpose_length(d) {
  return d.length;
}

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/zip.js


/* harmony default export */ var zip = (function() {
  return src_transpose(arguments);
});

// CONCATENATED MODULE: ./node_modules/d3-chord/node_modules/d3-array/src/index.js




























// CONCATENATED MODULE: ./node_modules/d3-chord/src/math.js
var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var math_max = Math.max;

// CONCATENATED MODULE: ./node_modules/d3-chord/src/chord.js



function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

/* harmony default export */ var src_chord = (function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = math_max(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = math_max(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/src/array.js
var array_slice = Array.prototype.slice;

// CONCATENATED MODULE: ./node_modules/d3-chord/src/constant.js
/* harmony default export */ var src_constant = (function(x) {
  return function() {
    return x;
  };
});

// EXTERNAL MODULE: ./node_modules/d3-path/src/path.js
var path = __webpack_require__(520);

// CONCATENATED MODULE: ./node_modules/d3-chord/src/ribbon.js





function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

/* harmony default export */ var src_ribbon = (function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = array_slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = Object(path["a" /* default */])();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : src_constant(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : src_constant(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : src_constant(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
});

// CONCATENATED MODULE: ./node_modules/d3-chord/src/index.js




/***/ }),
/* 514 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "voronoi", function() { return /* reexport */ src_voronoi; });

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/point.js
function point_x(d) {
  return d[0];
}

function point_y(d) {
  return d[1];
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

/* harmony default export */ var src_RedBlackTree = (RedBlackTree);

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/Edge.js


function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = Diagram_edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = Diagram_edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = Diagram_edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete Diagram_edges[i];
    }
  }
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/Cell.js



function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, Diagram_edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!Diagram_edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, Diagram_edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, Diagram_edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, Diagram_edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        Diagram_edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        Diagram_edges.push(createBorderEdge(site, v01, v11)) - 1,
        Diagram_edges.push(createBorderEdge(site, v11, v10)) - 1,
        Diagram_edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/Circle.js



var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/Beach.js






var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/Diagram.js






var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var Diagram_edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  Diagram_edges = [];
  cells = new Array(sites.length);
  beaches = new src_RedBlackTree;
  circles = new src_RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = Diagram_edges;
  this.cells = cells;

  beaches =
  circles =
  Diagram_edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/voronoi.js




/* harmony default export */ var src_voronoi = (function() {
  var x = point_x,
      y = point_y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / epsilon) * epsilon, Math.round(y(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
});

// CONCATENATED MODULE: ./node_modules/d3-voronoi/src/index.js



/***/ }),
/* 515 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "brush", function() { return /* reexport */ src_brush; });
__webpack_require__.d(__webpack_exports__, "brushX", function() { return /* reexport */ brushX; });
__webpack_require__.d(__webpack_exports__, "brushY", function() { return /* reexport */ brushY; });
__webpack_require__.d(__webpack_exports__, "brushSelection", function() { return /* reexport */ brushSelection; });

// EXTERNAL MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var dispatch = __webpack_require__(521);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/select.js
var src_select = __webpack_require__(99);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/selection/on.js
var on = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/d3-drag/src/noevent.js


function nopropagation() {
  on["c" /* event */].stopImmediatePropagation();
}

/* harmony default export */ var noevent = (function() {
  on["c" /* event */].preventDefault();
  on["c" /* event */].stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-drag/src/nodrag.js



/* harmony default export */ var nodrag = (function(view) {
  var root = view.document.documentElement,
      selection = Object(src_select["a" /* default */])(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(src_select["a" /* default */])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

// EXTERNAL MODULE: ./node_modules/d3-interpolate/src/value.js
var value = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/touch.js
var touch = __webpack_require__(166);

// EXTERNAL MODULE: ./node_modules/d3-selection/src/mouse.js
var mouse = __webpack_require__(165);

// EXTERNAL MODULE: ./node_modules/d3-transition/src/index.js + 29 modules
var src = __webpack_require__(112);

// CONCATENATED MODULE: ./node_modules/d3-brush/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/event.js
/* harmony default export */ var src_event = (function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/noevent.js


function noevent_nopropagation() {
  on["c" /* event */].stopImmediatePropagation();
}

/* harmony default export */ var src_noevent = (function() {
  on["c" /* event */].preventDefault();
  on["c" /* event */].stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-brush/src/brush.js









var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return Object(touch["a" /* default */])(target, on["c" /* event */].touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(brush_type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(brush_type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(brush_type),
  input: function(xy) { return xy == null ? null : number2(xy); },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function brush_type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !on["c" /* event */].ctrlKey && !on["c" /* event */].button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush_brush(X);
}

function brushY() {
  return brush_brush(Y);
}

/* harmony default export */ var src_brush = (function() {
  return brush_brush(XY);
});

function brush_brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = Object(dispatch["a" /* default */])("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([brush_type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          Object(src_select["a" /* default */])(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([brush_type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = Object(value["a" /* default */])(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            Object(src["interrupt"])(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = Object(src_select["a" /* default */])(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      Object(on["a" /* customEvent */])(new src_event(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !on["c" /* event */].touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = on["c" /* event */].target.__data__.type,
        mode = (keys && on["c" /* event */].metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && on["c" /* event */].altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && on["c" /* event */].shiftKey,
        lockX,
        lockY,
        pointer = on["c" /* event */].touches ? toucher(on["c" /* event */].changedTouches[0].identifier) : mouse["a" /* default */],
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = Object(src_select["a" /* default */])(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (on["c" /* event */].touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = Object(src_select["a" /* default */])(on["c" /* event */].view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)

      nodrag(on["c" /* event */].view);
    }

    noevent_nopropagation();
    Object(src["interrupt"])(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      src_noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      noevent_nopropagation();
      if (on["c" /* event */].touches) {
        if (on["c" /* event */].touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        yesdrag(on["c" /* event */].view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (on["c" /* event */].keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      src_noevent();
    }

    function keyupped() {
      switch (on["c" /* event */].keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (on["c" /* event */].altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      src_noevent();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush) : touchable;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

// CONCATENATED MODULE: ./node_modules/d3-brush/src/index.js



/***/ }),
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "polygonArea", function() { return /* reexport */ src_area; });
__webpack_require__.d(__webpack_exports__, "polygonCentroid", function() { return /* reexport */ centroid; });
__webpack_require__.d(__webpack_exports__, "polygonHull", function() { return /* reexport */ hull; });
__webpack_require__.d(__webpack_exports__, "polygonContains", function() { return /* reexport */ contains; });
__webpack_require__.d(__webpack_exports__, "polygonLength", function() { return /* reexport */ src_length; });

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/area.js
/* harmony default export */ var src_area = (function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/centroid.js
/* harmony default export */ var centroid = (function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/cross.js
// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
/* harmony default export */ var cross = (function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/hull.js


function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

/* harmony default export */ var hull = (function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/contains.js
/* harmony default export */ var contains = (function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/length.js
/* harmony default export */ var src_length = (function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
});

// CONCATENATED MODULE: ./node_modules/d3-polygon/src/index.js







/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "hexbin", function() { return /* reexport */ hexbin; });

// CONCATENATED MODULE: ./node_modules/d3-hexbin/src/hexbin.js
var thirdPi = Math.PI / 3,
    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

function pointX(d) {
  return d[0];
}

function pointY(d) {
  return d[1];
}

/* harmony default export */ var hexbin = (function() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1,
      x = pointX,
      y = pointY,
      r,
      dx,
      dy;

  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;

    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point = points[i], i, points))
          || isNaN(py = +y.call(null, point, i, points))) continue;

      var point,
          px,
          py,
          pj = Math.round(py = py / dy),
          pi = Math.round(px = px / dx - (pj & 1) / 2),
          py1 = py - pj;

      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi,
            pi2 = pi + (px < pi ? -1 : 1) / 2,
            pj2 = pj + (py < pj ? -1 : 1),
            px2 = px - pi2,
            py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }

      var id = pi + "-" + pj, bin = binsById[id];
      if (bin) bin.push(point);
      else {
        bins.push(bin = binsById[id] = [point]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }

    return bins;
  }

  function hexagon(radius) {
    var x0 = 0, y0 = 0;
    return angles.map(function(angle) {
      var x1 = Math.sin(angle) * radius,
          y1 = -Math.cos(angle) * radius,
          dx = x1 - x0,
          dy = y1 - y0;
      x0 = x1, y0 = y1;
      return [dx, dy];
    });
  }

  hexbin.hexagon = function(radius) {
    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
  };

  hexbin.centers = function() {
    var centers = [],
        j = Math.round(y0 / dy),
        i = Math.round(x0 / dx);
    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
        centers.push([x, y]);
      }
    }
    return centers;
  };

  hexbin.mesh = function() {
    var fragment = hexagon(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
  };

  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };

  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };

  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };

  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };

  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };

  return hexbin.radius(1);
});

// CONCATENATED MODULE: ./node_modules/d3-hexbin/index.js



/***/ }),
/* 518 */,
/* 519 */,
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ __webpack_exports__["a"] = (path);


/***/ }),
/* 521 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["a"] = (dispatch);


/***/ }),
/* 522 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


/* harmony default export */ __webpack_exports__["a"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value) / 3))) * 3 - Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Math.abs(step)));
});


/***/ }),
/* 523 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


/* harmony default export */ __webpack_exports__["a"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(max) - Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(step)) + 1;
});


/***/ }),
/* 524 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


/* harmony default export */ __webpack_exports__["a"] = (function(step) {
  return Math.max(0, -Object(_exponent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Math.abs(step)));
});


/***/ }),
/* 525 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export years */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var year = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (year);
var years = year.range;


/***/ }),
/* 526 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export months */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var month = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (month);
var months = month.range;


/***/ }),
/* 527 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return monday; });
/* unused harmony export tuesday */
/* unused harmony export wednesday */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return thursday; });
/* unused harmony export friday */
/* unused harmony export saturday */
/* unused harmony export sundays */
/* unused harmony export mondays */
/* unused harmony export tuesdays */
/* unused harmony export wednesdays */
/* unused harmony export thursdays */
/* unused harmony export fridays */
/* unused harmony export saturdays */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



function weekday(i) {
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"]) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationWeek */ "e"];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),
/* 528 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export days */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var day = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"]) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationDay */ "a"];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (day);
var days = day.range;


/***/ }),
/* 529 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export hours */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var hour = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationSecond */ "d"] - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"]);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationHour */ "b"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationHour */ "b"];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["a"] = (hour);
var hours = hour.range;


/***/ }),
/* 530 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export minutes */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var minute = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationSecond */ "d"]);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (minute);
var minutes = minute.range;


/***/ }),
/* 531 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export seconds */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var second = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationSecond */ "d"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationSecond */ "d"];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["a"] = (second);
var seconds = second.range;


/***/ }),
/* 532 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export milliseconds */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var millisecond = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["a"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),
/* 533 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utcMonday; });
/* unused harmony export utcTuesday */
/* unused harmony export utcWednesday */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return utcThursday; });
/* unused harmony export utcFriday */
/* unused harmony export utcSaturday */
/* unused harmony export utcSundays */
/* unused harmony export utcMondays */
/* unused harmony export utcTuesdays */
/* unused harmony export utcWednesdays */
/* unused harmony export utcThursdays */
/* unused harmony export utcFridays */
/* unused harmony export utcSaturdays */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



function utcWeekday(i) {
  return Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationWeek */ "e"];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),
/* 534 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcDays */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var utcDay = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationDay */ "a"];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["a"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),
/* 535 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcYears */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var utcYear = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),
/* 536 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcMonths */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var utcMonth = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),
/* 537 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcHours */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var utcHour = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationHour */ "b"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationHour */ "b"];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["a"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),
/* 538 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export utcMinutes */
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);



var utcMinute = Object(_interval_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"]);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__[/* durationMinute */ "c"];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["a"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),
/* 539 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ defaultLocale_format; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ defaultLocale_formatPrefix; });

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./node_modules/d3-format/src/exponent.js
var src_exponent = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatGroup.js
/* harmony default export */ var formatGroup = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ var formatNumerals = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});

// EXTERNAL MODULE: ./node_modules/d3-format/src/formatSpecifier.js
var formatSpecifier = __webpack_require__(152);

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ var formatTrim = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});

// EXTERNAL MODULE: ./node_modules/d3-format/src/formatDecimal.js
var formatDecimal = __webpack_require__(48);

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ var formatPrefixAuto = (function(x, p) {
  var d = Object(formatDecimal["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(formatDecimal["a" /* default */])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatRounded.js


/* harmony default export */ var formatRounded = (function(x, p) {
  var d = Object(formatDecimal["a" /* default */])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/formatTypes.js



/* harmony default export */ var formatTypes = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/identity.js
/* harmony default export */ var identity = (function(x) {
  return x;
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ var src_locale = (function(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = Object(formatSpecifier["a" /* default */])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(formatSpecifier["a" /* default */])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(src_exponent["a" /* default */])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});

// CONCATENATED MODULE: ./node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var defaultLocale_formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  defaultLocale_locale = src_locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}


/***/ }),
/* 540 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ timeFormat; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ utcFormat; });

// UNUSED EXPORTS: timeParse, utcParse, default

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcWeek.js
var utcWeek = __webpack_require__(533);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcDay.js
var utcDay = __webpack_require__(534);

// EXTERNAL MODULE: ./node_modules/d3-time/src/week.js
var src_week = __webpack_require__(527);

// EXTERNAL MODULE: ./node_modules/d3-time/src/day.js
var src_day = __webpack_require__(528);

// EXTERNAL MODULE: ./node_modules/d3-time/src/year.js
var year = __webpack_require__(525);

// EXTERNAL MODULE: ./node_modules/d3-time/src/utcYear.js
var utcYear = __webpack_require__(535);

// CONCATENATED MODULE: ./node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcWeek["a" /* utcMonday */].ceil(week) : Object(utcWeek["a" /* utcMonday */])(week);
          week = utcDay["a" /* default */].offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? src_week["a" /* monday */].ceil(week) : Object(src_week["a" /* monday */])(week);
          week = src_day["a" /* default */].offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + src_day["a" /* default */].count(Object(year["a" /* default */])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(src_week["b" /* sunday */].count(Object(year["a" /* default */])(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? Object(src_week["c" /* thursday */])(d) : src_week["c" /* thursday */].ceil(d);
  return pad(src_week["c" /* thursday */].count(Object(year["a" /* default */])(d), d) + (Object(year["a" /* default */])(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(src_week["a" /* monday */].count(Object(year["a" /* default */])(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay["a" /* default */].count(Object(utcYear["a" /* default */])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcWeek["b" /* utcSunday */].count(Object(utcYear["a" /* default */])(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? Object(utcWeek["c" /* utcThursday */])(d) : utcWeek["c" /* utcThursday */].ceil(d);
  return pad(utcWeek["c" /* utcThursday */].count(Object(utcYear["a" /* default */])(d), d) + (Object(utcYear["a" /* default */])(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcWeek["a" /* utcMonday */].count(Object(utcYear["a" /* default */])(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

// CONCATENATED MODULE: ./node_modules/d3-time-format/src/defaultLocale.js


var defaultLocale_locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  defaultLocale_locale = formatLocale(definition);
  timeFormat = defaultLocale_locale.format;
  timeParse = defaultLocale_locale.parse;
  utcFormat = defaultLocale_locale.utcFormat;
  utcParse = defaultLocale_locale.utcParse;
  return defaultLocale_locale;
}


/***/ })
/******/ ]);
});
//# sourceMappingURL=lib.js.map